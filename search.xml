<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo+github搭建免费博客</title>
    <url>/2020/05/19/diyici/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用github pages服务搭建博客的好处有：</p>
<ul>
<li><p>全是静态文件，访问速度快；</p>
</li>
<li><p>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</p>
</li>
<li><p>可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</p>
</li>
<li><p>数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</p>
</li>
<li><p>博客内容可以轻松打包、转移、发布到其它平台；</p>
</li>
<li><p>等等；</p>
</li>
</ul>
<a id="more"></a>

<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul>
<li>有一个github账号，没有的话去注册一个；</li>
<li>安装了node.js、npm，并了解相关基础知识；</li>
<li>安装了git for windows（或者其它git客户端）</li>
</ul>
<h1 id="搭建github博客"><a href="#搭建github博客" class="headerlink" title="搭建github博客"></a>搭建github博客</h1><ul>
<li><p>创建仓库<br>新建一个名为  你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效）</p>
</li>
<li><p>配置SSH key</p>
<p>  $ cd ~/. ssh #检查本机已存在的ssh密钥</p>
<p>  $ ssh-keygen -t rsa -C “邮件地址”</p>
</li>
<li><p>然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\id_rsa.pub文件</p>
<pre><code>复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：</code></pre></li>
</ul>
<h1 id="配置："><a href="#配置：" class="headerlink" title="配置："></a>配置：</h1><ul>
<li>$ git config –global user.name “liuxianan”// 你的github用户名，非昵称</li>
<li>$ git config –global user.email  “<a href="mailto:xxx@qq.com">xxx@qq.com</a>“// 填写你的github注册邮箱</li>
</ul>
<h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><ul>
<li><p>$ npm install -g hexo</p>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>在电脑的某个地方新建一个名为hexo的文件夹由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放注意一定要是空文件夹。</p>
</li>
<li><p>$ cd /f/Workspaces/hexo/</p>
</li>
<li><p>$ hexo init</p>
</li>
</ul>
<h1 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h1><ul>
<li>$ hexo g # 生成</li>
<li>$ hexo s # 启动服务</li>
</ul>
<h1 id="主题替换"><a href="#主题替换" class="headerlink" title="主题替换"></a>主题替换</h1><ul>
<li>git clone <a href="https://github.com/litten/hexo-theme-yilia.git" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia.git</a> themes/yilia</li>
</ul>
<h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><p>*修改_config.yml中的theme: landscape改为theme: yilia，然后重新执行hexo g来重新生成。</p>
<p>如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布</p>
<ul>
<li>deploy:<ul>
<li>type: git</li>
<li>repository: <a href="mailto:git@github.com">git@github.com</a>:liuxianan/liuxianan.github.io.git</li>
<li>branch: master</li>
</ul>
</li>
</ul>
<p>执行npm install hexo-deployer-git –save</p>
<h1 id="常用hexo命令"><a href="#常用hexo命令" class="headerlink" title="常用hexo命令"></a>常用hexo命令</h1><p>hexo new “postName” #新建文章</p>
<p>hexo new page “pageName” #新建页面</p>
<p>hexo generate #生成静态页面至public目录</p>
<p>hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）</p>
<p>hexo deploy #部署到GitHub</p>
<p>hexo help  # 查看帮助</p>
<p>hexo version  #查看Hexo的版本</p>
<p>hexo s -g #生成并本地预览</p>
<p>hexo d -g #生成并上传</p>
<h1 id="写博客工具"><a href="#写博客工具" class="headerlink" title="写博客工具"></a>写博客工具</h1><p>推荐 Visual Studio Code</p>
<h1 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h1><p>liushijiexy.github.io</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://blog.haoji.me/build-blog-website-by-hexo-github.html?from=xa" target="_blank" rel="noopener">http://blog.haoji.me/build-blog-website-by-hexo-github.html?from=xa</a></p>
]]></content>
      <categories>
        <category>默认分类</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>git基本</title>
    <url>/2020/05/19/git/</url>
    <content><![CDATA[<h1 id="前言-git"><a href="#前言-git" class="headerlink" title="前言 git"></a>前言 git</h1><ul>
<li><p>认识 Git</p>
</li>
<li><p>Git 与其他版本管理系统的主要区别</p>
</li>
<li><p>Git 的三种状态</p>
</li>
<li><p>基本的 Git 工作流程</p>
</li>
<li><p>基本命令</p>
<a id="more"></a>

</li>
</ul>
<h2 id="认识-Git"><a href="#认识-Git" class="headerlink" title="认识 Git"></a>认识 Git</h2><p>​        Linux 内核项目组当时使用分布式版本控制系统 BitKeeper 来管理和维护代码。但是，后来开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统，而且对新的版本控制系统做了很多改进。</p>
<h3 id="Git-与其他版本管理系统的主要区别"><a href="#Git-与其他版本管理系统的主要区别" class="headerlink" title="Git 与其他版本管理系统的主要区别"></a>Git 与其他版本管理系统的主要区别</h3><p>主要差别：<strong>对待数据的方式</strong>。</p>
<p><strong>Git采用的是直接记录快照的方式，而非差异比较。我后面会详细介绍这两种方式的差别。</strong></p>
<p>大部分版本控制系统（CVS、Subversion、Perforce、Bazaar 等等）都是以文件变更列表的方式存储信息，这类系统<strong>将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。</strong></p>
<p><img src="C:%5CUsers%5Cx%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200519074004392.png" alt="image-20200519074004392"></p>
<p><strong>我们怎样才能得到一个文件的最终版本呢？</strong></p>
<p>很简单，高中数学的基本知识，我们只需要将这些原文件和这些增加进行相加就行了。</p>
<p><strong>这种方式有什么问题呢？</strong></p>
<p>比如我们的增量特别特别多的话，如果我们要得到最终的文件是不是会耗费时间和性能。</p>
<p>Git 不按照以上方式对待或保存数据。 反之，Git 更像是把数据看作是对小型文件系统的一组快照。 每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 <strong>快照流</strong>。下图来源于Git官网。</p>
<p><img src="C:%5CUsers%5Cx%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200519074105838.png" alt="image-20200519074105838"></p>
<h3 id="Git-的三种状态"><a href="#Git-的三种状态" class="headerlink" title="Git 的三种状态"></a>Git 的三种状态</h3><p>Git 有三种状态，你的文件可能处于其中之一：</p>
<p>•<strong>已提交（committed）</strong>：数据已经安全的保存在本地数据库中。•<strong>已修改（modified）</strong>：已修改表示修改了文件，但还没保存到数据库中。•<strong>已暂存（staged）</strong>：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</p>
<p>由此引入 Git 项目的三个工作区域的概念：<strong>Git 仓库(.git directoty) 、**</strong>工作目录(Working Directory)** 以及 <strong>暂存区域(Staging Area)</strong> 。</p>
<p><img src="C:%5CUsers%5Cx%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200519074139658.png" alt="image-20200519074139658"></p>
<p><strong>基本的 Git 工作流程如下：</strong></p>
<p>•在工作目录中修改文件。•暂存文件，将文件的快照放入暂存区域。•提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。</p>
<h3 id="获取-Git-仓库"><a href="#获取-Git-仓库" class="headerlink" title="获取 Git 仓库"></a>获取 Git 仓库</h3><p>有两种取得 Git 项目仓库的方法。</p>
<p>•在现有目录中初始化仓库: 进入项目目录运行 <code>git init</code> 命令,该命令将创建一个名为 <code>.git</code> 的子目录。•从一个服务器克隆一个现有的 Git 仓库: <code>git clone [url]</code> 自定义本地仓库的名字: <code>git clone [url]</code> directoryname</p>
<h3 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h3><p>•<strong>检测当前文件状态</strong> : <code>git status</code>•<strong>提出更改（把它们添加到暂存区</strong>）：<code>git add filename</code> (针对特定文件)、<code>git add *</code>(所有文件)、<code>git add *.txt</code>（支持通配符，所有 .txt 文件）•<strong>忽略文件</strong>：<code>.gitignore</code> 文件•<strong>提交更新:</strong> <code>git commit -m &quot;代码提交信息&quot;</code> （每次准备提交前，先用 <code>git status</code> 看下，是不是都已暂存起来了， 然后再运行提交命令 <code>git commit</code>）•<strong>跳过使用暂存区域更新的方式</strong> : <code>git commit -a -m &quot;代码提交信息&quot;</code>。 <code>git commit</code> 加上 <code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤。•<strong>移除文件</strong> ：<code>git rm filename</code> （从暂存区域移除，然后提交。）•<strong>对文件重命名</strong> ：<code>git mv README.md README</code>(这个命令相当于<code>mv README.md README</code>、<code>git rm README.md</code>、<code>git add README</code> 这三条命令的集合)</p>
<h3 id="推送改动到远程仓库"><a href="#推送改动到远程仓库" class="headerlink" title="推送改动到远程仓库"></a>推送改动到远程仓库</h3><ul>
<li>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：·<code>git remote add origin</code> ,比如我们要让本地的一个仓库和 Github 上创建的一个仓库关联可以这样<code>git remote add origin https://github.com/Snailclimb/test.git</code>将</li>
<li>将这些改动提交到远端仓库：<code>git push origin master</code> (可以把 <strong>master</strong> 换成你想要推送的任何分支)</li>
</ul>
<h3 id="远程仓库的移除与重命名"><a href="#远程仓库的移除与重命名" class="headerlink" title="远程仓库的移除与重命名"></a>远程仓库的移除与重命名</h3><p>•将 test 重命名位 test1：<code>git remote rename test test1</code>•移除远程仓库 test1:<code>git remote rm test1</code></p>
<h3 id="远程仓库的移除与重命名-1"><a href="#远程仓库的移除与重命名-1" class="headerlink" title="远程仓库的移除与重命名"></a>远程仓库的移除与重命名</h3><p>•将 test 重命名位 test1：<code>git remote rename test test1</code>•移除远程仓库 test1:<code>git remote rm test1</code></p>
<p><strong>可以添加一些参数来查看自己希望看到的内容：</strong></p>
<ul>
<li>只看某个人的提交记录：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --author&#x3D;xxx可以添加一些参数来查看自己希望看到的内容：</span><br></pre></td></tr></table></figure>

<h3 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h3><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 <code>--amend</code> 选项的提交命令尝试重新提交：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>

<p>取消暂存的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset filename</span><br></pre></td></tr></table></figure>

<p>撤消对文件的修改:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -- filename</span><br></pre></td></tr></table></figure>

<p>假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch origingit reset --hard origin&#x2F;master</span><br></pre></td></tr></table></figure>

<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，<strong>master</strong> 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。</p>
<p>我们通常在开发新功能、修复一个紧急 bug 等等时候会选择创建分支。单分支开发好还是多分支开发好，还是要看具体场景来说。</p>
<p>创建一个名字叫做 test 的分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch test</span><br></pre></td></tr></table></figure>

<p>切换当前分支到 test（当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout test</span><br></pre></td></tr></table></figure>

<p>你也可以直接这样创建分支并切换过去(上面两条命令的合写)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b feature_x</span><br></pre></td></tr></table></figure>

<p>切换到主分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>

<p>合并分支(可能会有冲突)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge test</span><br></pre></td></tr></table></figure>

<p>把新建的分支删掉</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -d feature_x</span><br></pre></td></tr></table></figure>

<p>将分支推送到远端仓库（推送成功后其他人可见）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>基本命令</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>linux 基础入门</title>
    <url>/2020/05/19/linux%20%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><ul>
<li><p>Linux 基本命令；</p>
</li>
<li><p>比如目录的增删改查命令；</p>
</li>
<li><p>文件的增删改查命令;</p>
</li>
</ul>
<a id="more"></a>

<h1 id="一-从认识操作系统开始："><a href="#一-从认识操作系统开始：" class="headerlink" title="一 从认识操作系统开始："></a>一 从认识操作系统开始：</h1><h3 id="1-1-操作系统简介"><a href="#1-1-操作系统简介" class="headerlink" title="1.1 操作系统简介"></a>1.1 操作系统简介</h3><p>我通过以下四点介绍什么操作系统：</p>
<ul>
<li><strong>操作系统（Operation System，简称OS）是管理计算机硬件与软件资源的程序，是计算机系统的内核与基石；</strong></li>
<li><strong>操作系统本质上是运行在计算机上的软件程序 ；</strong></li>
<li><strong>为用户提供一个与系统交互的操作界面 ；</strong></li>
<li><strong>操作系统分内核与外壳（我们可以把外壳理解成围绕着内核的应用程序，而内核就是能操作硬件的程序）。</strong></li>
</ul>
<h3 id="1-2-操作系统简单分类"><a href="#1-2-操作系统简单分类" class="headerlink" title="1.2 操作系统简单分类"></a>1.2 操作系统简单分类</h3><ol>
<li><strong>Windows:</strong> 目前最流行的个人桌面操作系统 ，不做多的介绍，大家都清楚。</li>
<li><strong>Unix：</strong> 最早的多用户、多任务操作系统 .按照操作系统的分类，属于分时操作系统。Unix 大多被用在服务器、工作站，现在也有用在个人计算机上。它在创建互联网、计算机网络或客户端/服务器模型方面发挥着非常重要的作用。</li>
<li><strong>Linux:</strong> Linux是一套免费使用和自由传播的类Unix操作系统.Linux存在着许多不同的Linux版本，但它们都使用了 <strong>Linux内核</strong> 。Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、视频游戏控制台、台式计算机、大型机和超级计算机。严格来讲，Linux这个词本身只表示Linux内核，但实际上人们已经习惯了用Linux来形容整个基于Linux内核，并且使用GNU 工程各种工具和数据库的操作系统。</li>
</ol>
<h1 id="二-初识Linux"><a href="#二-初识Linux" class="headerlink" title="二 初识Linux"></a>二 初识Linux</h1><h3 id="2-1-Linux简介"><a href="#2-1-Linux简介" class="headerlink" title="2.1 Linux简介"></a>2.1 Linux简介</h3><ul>
<li><strong>类Unix系统：</strong> Linux是一种自由、开放源码的类似Unix的操作系统</li>
<li><strong>Linux内核：</strong> 严格来说，Linux这个词本身只表示Linux内核</li>
<li><strong>Linux之父：</strong> 一个编程领域的传奇式人物。他是Linux内核的最早作者，随后发起了这个开源项目，担任Linux内核的首要架构师与项目协调者，是当今世界最著名的电脑程序员、黑客之一。他还发起了Git这个开源项目，并为主要的开发者。</li>
</ul>
<h3 id="2-2-Linux诞生"><a href="#2-2-Linux诞生" class="headerlink" title="2.2 Linux诞生"></a>2.2 Linux诞生</h3><ul>
<li>1991年，芬兰的业余计算机爱好者Linus Torvalds编写了一款类似Minix的系统（基于微内核架构的类Unix操作系统）被ftp管理员命名为Linux 加入到自由软件基金的GNU计划中;</li>
<li>Linux以一只可爱的企鹅作为标志，象征着敢作敢为、热爱生活。</li>
</ul>
<h3 id="2-3-Linux的分类"><a href="#2-3-Linux的分类" class="headerlink" title="2.3 Linux的分类"></a>2.3 Linux的分类</h3><p><strong>Linux根据原生程度，分为两种：</strong></p>
<ol>
<li><strong>内核版本：</strong> Linux不是一个操作系统，严格来讲，Linux只是一个操作系统中的内核。内核是什么？内核建立了计算机软件与硬件之间通讯的平台，内核提供系统服务，比如文件管理、虚拟内存、设备I/O等；</li>
<li><strong>发行版本：</strong> 一些组织或公司在内核版基础上进行二次开发而重新发行的版本。Linux发行版本有很多种（ubuntu和CentOS用的都很多，初学建议选择CentOS；</li>
</ol>
<h1 id="三-Linux文件系统概览"><a href="#三-Linux文件系统概览" class="headerlink" title="三 Linux文件系统概览"></a>三 Linux文件系统概览</h1><h3 id="3-1-Linux文件系统简介"><a href="#3-1-Linux文件系统简介" class="headerlink" title="3.1 Linux文件系统简介"></a>3.1 Linux文件系统简介</h3><p><strong>在Linux操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。</strong></p>
<p>也就是说在LINUX系统中有一个重要的概念：<strong>一切都是文件</strong>。其实这是UNIX哲学的一个体现，而Linux是重写UNIX而来，所以这个概念也就传承了下来。在UNIX系统中，把一切资源都看作是文件，包括硬件设备。UNIX系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就可以用读写文件的方式实现对硬件的访问。</p>
<h3 id="3-2-常见目录说明："><a href="#3-2-常见目录说明：" class="headerlink" title="3.2 常见目录说明："></a><strong>3.2 常见目录说明：</strong></h3><ul>
<li><strong>/bin：</strong> 存放二进制可执行文件(ls、cat、mkdir等)，常用命令一般都在这里；</li>
<li><strong>/etc：</strong> 存放系统管理和配置文件；</li>
<li><strong>/home：</strong> 存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示；</li>
<li><strong>/usr ：</strong> 用于存放系统应用程序；</li>
<li><strong>/opt：</strong> 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里；</li>
<li><strong>/proc：</strong> 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；</li>
<li><strong>/root：</strong> 超级用户（系统管理员）的主目录（特权阶级^o^）；</li>
<li><strong>/sbin:</strong> 存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等；</li>
<li><strong>/dev：</strong> 用于存放设备文件；</li>
<li><strong>/mnt：</strong> 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；</li>
<li><strong>/boot：</strong> 存放用于系统引导时使用的各种文件；</li>
<li><strong>/lib ：</strong> 存放着和系统运行相关的库文件 ；</li>
<li><strong>/tmp：</strong> 用于存放各种临时文件，是公用的临时文件存储点；</li>
<li><strong>/var：</strong> 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；</li>
<li><strong>/lost+found：</strong> 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里。</li>
</ul>
<h1 id="四-Linux基本命令"><a href="#四-Linux基本命令" class="headerlink" title="四 Linux基本命令"></a>四 Linux基本命令</h1><p>下面只是给出了一些比较常用的命令。推荐一个Linux命令快查网站，大家如果遗忘某些命令或者对某些命令不理解都可以在这里得到解决。</p>
<p>Linux命令大全：<a href="http://man.linuxde.net/" target="_blank" rel="noopener">http://man.linuxde.net/</a></p>
<h3 id="4-1-目录切换命令"><a href="#4-1-目录切换命令" class="headerlink" title="4.1 目录切换命令"></a>4.1 目录切换命令</h3><ul>
<li><strong>cd usr</strong>： 切换到该目录下 usr 目录</li>
<li><strong>cd ..（或cd../）</strong>： 切换到上一层目录</li>
<li><strong>cd /</strong>： 切换到系统根目录</li>
<li><strong>cd ~</strong>： 切换到用户主目录</li>
<li><strong>cd -</strong>： 切换到上一个操作所在目录</li>
</ul>
<p>4.2 目录的操作命令(增删改查)</p>
<ol>
<li><strong>mkdir 目录名称</strong>： 增加目录</li>
<li><strong>ls或者ll</strong>（ll是ls -l的别名，ll命令可以看到该目录下的所有目录和文件的详细信息）：查看目录信息</li>
<li><strong>find 目录 参数</strong>： 寻找目录（查）</li>
</ol>
<p>示例：</p>
<ul>
<li><ul>
<li>列出当前目录及子目录下所有文件和文件夹: find .</li>
<li>在/home目录下查找以.txt结尾的文件名:find /home -name “*.txt”</li>
<li>同上，但忽略大小写: find /home -iname “*.txt”</li>
<li>当前目录及子目录下查找所有以.txt和.pdf结尾的文件:find . ( -name “<em>.txt” -o -name “</em>.pdf” )或find . -name “<em>.txt” -o -name “</em>.pdf”</li>
</ul>
</li>
</ul>
<ol>
<li><strong>mv 目录名称 新目录名称**</strong>：** 修改目录的名称（改）</li>
</ol>
<p>注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行 重命名的操作。mv命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。后面会介绍到mv命令的另一个用法。</p>
<ol>
<li><strong>mv 目录名称 目录的新位置</strong>： 移动目录的位置—剪切（改）</li>
</ol>
<p>注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。另外mv与cp的结果不同，mv好像文件“搬家”，文件个数并未增加。而cp对文件进行复制，文件个数增加了。</p>
<ol>
<li><strong>cp -r 目录名称 目录拷贝的目标位置*</strong> 拷贝目录（改），-r代表递归拷贝 </li>
</ol>
<p>注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不 用写-r递归</p>
<ol>
<li><strong>rm -rf</strong> 目录/文件/压缩包</li>
</ol>
<p>4.3 文件的操作命令(增删改查)</p>
<ol>
<li><strong>touch 文件名称</strong>: 文件的创建（增）</li>
<li><strong>cat/more/less/tail 文件名称</strong> 文件的查看（查）</li>
</ol>
<ul>
<li><ul>
<li><strong>cat</strong>： 查看显示文件内容</li>
<li><strong>more</strong>： 可以显示百分比，回车可以向下一行， 空格可以向下一页，q可以退出查看</li>
<li><strong>less</strong>：可以使用键盘上的PgUp和PgDn向上 和向下翻页，q结束查看</li>
<li><strong>tail-10</strong> <strong>：</strong> 查看文件的后10行，Ctrl+C结束</li>
</ul>
</li>
</ul>
<p>注意：命令 tail -f 文件 可以对某个文件进行动态监控，例如tomcat的日志文件， 会随着程序的运行，日志会变化，可以使用tail -f …..1541.log 监控 文 件的变化</p>
<ol>
<li><strong>vim 文件</strong>： 修改文件的内容（改）</li>
</ol>
<p>vim编辑器是Linux中的强大组件，是vi编辑器的加强版，vim编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用vim编辑修改文件的方式基本会使用就可以了。</p>
<h3 id="在实际开发中，使用vim编辑器主要作用就是修改配置文件，下面是一般步骤："><a href="#在实际开发中，使用vim编辑器主要作用就是修改配置文件，下面是一般步骤：" class="headerlink" title="在实际开发中，使用vim编辑器主要作用就是修改配置文件，下面是一般步骤："></a><strong>在实际开发中，使用vim编辑器主要作用就是修改配置文件，下面是一般步骤：</strong></h3><p>vim 文件——&gt;进入文件—–&gt;命令模式——&gt;按i进入编辑模式—–&gt;编辑文件 ——-&gt;按Esc进入底行模式—–&gt;输入：wq/q! （输入wq代表写入内容并退出，即保存；输入q!代表强制退出不保存。）</p>
<ol>
<li><strong>rm -rf 文件</strong>： 删除文件（删）</li>
</ol>
<p>同目录删除：熟记 rm -rf 文件 即可</p>
<p>4.4 压缩文件的操作命令</p>
<p><strong>1）打包并压缩文件：</strong></p>
<p>Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。</p>
<p>而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。</p>
<p>命令：<strong>tar -zcvf 打包压缩后的文件名 要打包压缩的文件</strong></p>
<p>其中：</p>
<p>z：调用gzip压缩命令进行压缩</p>
<p>c：打包文件</p>
<p>v：显示运行过程</p>
<p>f：指定文件名</p>
<p>比如：加入test目录下有三个文件分别是：aaa.txt bbb.txt ccc.txt，如果我们要打包test目录并指定压缩后的压缩包名称为test.tar.gz可以使用命令：<strong>tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt**</strong>或：<strong>**tar -zcvf test.tar.gz /test/</strong></p>
<p><strong>2）解压压缩包：</strong></p>
<p>命令：tar [-xvf] 压缩文件</p>
<p>其中：x：代表解压</p>
<p>示例：</p>
<p>1 将/test下的test.tar.gz解压到当前目录下可以使用命令：<strong>tar -xvf test.tar.gz</strong></p>
<p>2 将/test下的test.tar.gz解压到根目录/usr下:<strong>tar -xvf xxx.tar.gz -C /usr</strong>（- C代表指定解压的位置）</p>
<p>4.5 Linux的权限命令</p>
<p>操作系统中每个文件都拥有特定的权限、所属用户和所属组。权限是操作系统用来限制资源访问的机制，在Linux中权限一般分为读(readable)、写(writable)和执行(excutable)，分为三组。分别对应文件的属主(owner)，属组(group)和其他用户(other)，通过这样的机制来限制哪些用户、哪些组可以对特定的文件进行什么样的操作。通过 <strong>ls -l</strong> 命令我们可以 查看某个目录下的文件或目录的权限</p>
<p>示例：在随意某个目录下ls -l</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/ff57f96cdec1f148fd7e1cb5a73453c4." alt="img"></p>
<p>第一列的内容的信息解释如下：</p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/109975850c71f073b36f0129503739cf." alt="img"></p>
<p>下面将详细讲解文件的类型、Linux中权限以及文件有所有者、所在组、其它组具体是什么？</p>
<p><strong>文件的类型：</strong></p>
<ul>
<li>d： 代表目录</li>
<li>-： 代表文件</li>
<li>l： 代表软链接（可以认为是window中的快捷方式）</li>
</ul>
<p><strong>Linux中权限分为以下几种：</strong></p>
<ul>
<li>r：代表权限是可读，r也可以用数字4表示</li>
<li>w：代表权限是可写，w也可以用数字2表示</li>
<li>x：代表权限是可执行，x也可以用数字1表示</li>
</ul>
<p><strong>文件和目录权限的区别：</strong></p>
<p>对文件和目录而言，读写执行表示不同的意义。</p>
<p>对于文件：</p>
<table>
<thead>
<tr>
<th>权限名称</th>
<th>可执行操作</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>可以使用cat查看文件的内容</td>
</tr>
<tr>
<td>w</td>
<td>可以修改文件的内容</td>
</tr>
<tr>
<td>x</td>
<td>可以将其运行为二进制文件</td>
</tr>
</tbody></table>
<p>对于目录：</p>
<table>
<thead>
<tr>
<th>权限名称</th>
<th>可执行操作</th>
</tr>
</thead>
<tbody><tr>
<td>r</td>
<td>可以查看目录下列表</td>
</tr>
<tr>
<td>w</td>
<td>可以创建和删除目录下文件</td>
</tr>
<tr>
<td>x</td>
<td>可以使用cd进入目录</td>
</tr>
</tbody></table>
<p><strong>需要注意的是超级用户可以无视普通用户的权限，即使文件目录权限是000，依旧可以访问。</strong></p>
<p><strong>在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者、所在组、其它组的概念。</strong></p>
<ul>
<li><strong>所有者</strong></li>
</ul>
<p>一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者，用ls ‐ahl命令可以看到文件的所有者 也可以使用chown 用户名 文件名来修改文件的所有者 。</p>
<ul>
<li><strong>文件所在组</strong></li>
</ul>
<p>当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组 用ls ‐ahl命令可以看到文件的所有组 也可以使用chgrp 组名 文件名来修改文件所在的组。</p>
<ul>
<li><strong>其它组</strong></li>
</ul>
<p>除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组</p>
<p>我们再来看看如何修改文件/目录的权限。</p>
<p><strong>修改文件/目录的权限的命令：**</strong>chmod**</p>
<p>示例：修改/test下的aaa.txt的权限为属主有全部权限，属主所在的组有读写权限，</p>
<p>其他用户只有读的权限</p>
<p><strong>chmod u=rwx,g=rw,o=r aaa.txt</strong></p>
<p><img src="https://images.xiaozhuanlan.com/photo/2019/d698d9b526e2ed8c55afac32f087a00d." alt="img"></p>
<p>上述示例还可以使用数字表示：</p>
<p>chmod 765 aaa.txt</p>
<h1 id="补充一个比较常用的东西"><a href="#补充一个比较常用的东西" class="headerlink" title="补充一个比较常用的东西:"></a><strong>补充一个比较常用的东西:</strong></h1><p>假如我们装了一个zookeeper，我们每次开机到要求其自动启动该怎么办？</p>
<ol>
<li>新建一个脚本zookeeper</li>
<li>为新建的脚本zookeeper添加可执行权限，命令是:chmod +x zookeeper</li>
<li>把zookeeper这个脚本添加到开机启动项里面，命令是：chkconfig –add zookeeper</li>
<li>如果想看看是否添加成功，命令是：chkconfig –list</li>
</ol>
<p>4.6 Linux 用户管理</p>
<p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p>
<p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p>
<p><strong>Linux用户管理相关命令:</strong></p>
<ul>
<li>useradd 选项 用户名:添加用户账号</li>
<li>userdel 选项 用户名:删除用户帐号</li>
<li>usermod 选项 用户名:修改帐号</li>
<li>passwd 用户名:更改或创建用户的密码</li>
<li>passwd -S 用户名 :显示用户账号密码信息</li>
<li>passwd -d 用户名: 清除用户密码</li>
</ul>
<p>useradd命令用于Linux中创建的新的系统用户。useradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码．而可用userdel删除帐号。使用useradd指令所建立的帐号，实际上是保存在/etc/passwd文本文件中。</p>
<p>passwd命令用于设置用户的认证信息，包括用户密码、密码过期时间等。系统管理者则能用它管理系统用户的密码。只有管理者可以指定用户名称，一般用户只能变更自己的密码。</p>
<p>4.7 Linux系统用户组的管理</p>
<p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p>
<p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。</p>
<p><strong>Linux系统用户组的管理相关命令:</strong></p>
<ul>
<li>groupadd 选项 用户组 :增加一个新的用户组</li>
<li>groupdel 用户组:要删除一个已有的用户组</li>
<li>groupmod 选项 用户组 : 修改用户组的属性</li>
</ul>
<p>4.8 其他常用命令</p>
<ul>
<li><strong>pwd**</strong>：** 显示当前所在位置</li>
<li><strong>grep 要搜索的字符串 要搜索的文件 –color**</strong>：** 搜索命令，–color代表高亮显示</li>
<li><strong>ps -ef**</strong>/<strong><strong>ps -aux</strong></strong>：** 这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：<strong>ps aux|grep redis</strong> （查看包括redis字符串的进程），也可使用 pgrep redis -a。</li>
</ul>
<p>注意：如果直接用ps（（Process Status））命令，会显示所有进程的状态，通常结合grep命令查看某进程的状态。</p>
<ul>
<li><strong>kill -9 进程的pid**</strong>：** 杀死进程（-9 表示强制终止。）</li>
</ul>
<p>先用ps查找进程，然后用kill杀掉</p>
<ul>
<li><p><strong>网络通信命令：</strong></p>
</li>
<li><ul>
<li>查看当前系统的网卡信息：ifconfig</li>
<li>查看与某台机器的连接情况：ping</li>
<li>查看当前系统的端口使用：netstat -an</li>
</ul>
</li>
<li><p><strong>net-tools 和 iproute2 ：</strong></p>
</li>
</ul>
<p>net-tools起源于BSD的TCP/IP工具箱，后来成为老版本Linux内核中配置网络功能的工具。但自2001年起，Linux社区已经对其停止维护。同时，一些Linux发行版比如Arch Linux和CentOS/RHEL 7则已经完全抛弃了net-tools，只支持iproute2。linux ip命令类似于ifconfig，但功能更强大，旨在替代它。更多详情请阅读<a href="https://linoxide.com/linux-command/use-ip-command-linux" target="_blank" rel="noopener">如何在Linux中使用IP命令和示例</a></p>
<ul>
<li><strong>shutdown**</strong>：** shutdown -h now： 指定现在立即关机；shutdown +5 “System will shutdown after 5 minutes”：指定5分钟后关机，同时送出警告信息给登入用户。</li>
<li><strong>reboot**</strong>：** <strong>reboot**</strong>：** 重开机。<strong>reboot -w**</strong>：** 做个重开机的模拟（只有纪录并不会真的重开机）。</li>
</ul>
]]></content>
      <categories>
        <category>基本命令</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>容器</title>
    <url>/2020/05/19/Java%20%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>集合：</p>
<ul>
<li>list；</li>
<li>set；</li>
<li>map</li>
</ul>
<a id="more"></a>

<h1 id="说说List-Set-Map三者的区别？"><a href="#说说List-Set-Map三者的区别？" class="headerlink" title="说说List,Set,Map三者的区别？"></a>说说List,Set,Map三者的区别？</h1><ul>
<li><strong>List(对付顺序的好帮手)：</strong> List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象</li>
<li><strong>Set(注重独一无二的性质):</strong> 不允许重复的集合。不会有多个元素引用相同的对象。</li>
<li><strong>Map(用Key来搜索的专家):</strong> 使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。</li>
</ul>
<h1 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别?"></a>Arraylist 与 LinkedList 区别?</h1><ul>
<li><strong>1. 是否保证线程安全：</strong> ArrayList 和 LinkedList 都是不同步的，也就是<strong>不保证线程安全</strong>；</li>
<li><strong>2. 底层数据结构：</strong> Arraylist 底层使用的是<strong>Object数组</strong>；LinkedList 底层使用的是<strong>双向链表数据结构</strong>（JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li>
<li><strong>3. 插入和删除是否受元素位置的影响：</strong> ① <strong>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② <strong>LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O（1）而数组为近似 O（n）。</strong></li>
<li><strong>4. 是否支持快速随机访问：</strong> <strong>LinkedList 不支持高效的随机元素访问</strong>，而 <strong>ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。</strong></li>
<li><strong>5. 内存空间占用：</strong> ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>
</ul>
<h1 id="ArrayList-与-Vector-区别呢-为什么要用Arraylist取代Vector呢？"><a href="#ArrayList-与-Vector-区别呢-为什么要用Arraylist取代Vector呢？" class="headerlink" title="ArrayList 与 Vector 区别呢?为什么要用Arraylist取代Vector呢？"></a>ArrayList 与 Vector 区别呢?为什么要用Arraylist取代Vector呢？</h1><p>Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。</p>
<p>Arraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。</p>
<h1 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h1><ol>
<li><strong>线程是否安全：</strong> HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过synchronized 修饰。（如果你要保证线程安全的话就使用 <strong>ConcurrentHashMap</strong> 吧！）；</li>
<li><strong>效率：</strong> 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li>
<li><strong>对Null key 和Null value的支持：</strong> HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。</li>
<li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小（HashMap 中的tableSizeFor()方法保证，下面给出了源代码）。也就是说 HashMap 总是使用2的幂作为哈希表的大小,后面会介绍到为什么是2的幂次方。</li>
<li><strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li>
</ol>
<h1 id="HashMap-和-HashSet区别"><a href="#HashMap-和-HashSet区别" class="headerlink" title="HashMap 和 HashSet区别"></a>HashMap 和 HashSet区别</h1><p>HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 clone()、writeObject()、readObject()是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。</p>
<h1 id="HashSet如何检查重复"><a href="#HashSet如何检查重复" class="headerlink" title="HashSet如何检查重复"></a>HashSet如何检查重复</h1><p>当你把对象<strong>加入HashSet</strong>时，HashSet会<strong>先计算对象的hashcode值</strong>来<strong>判断</strong>对象<strong>加入的位置</strong>，同时<strong>也会与**</strong>其他加入<strong>的对象的</strong>hashcode<strong>值作比较，如果</strong>没有<strong>相符的hashcode</strong>，HashSet会假<strong>设对象没有重复</strong>出现。但是如果<strong>发现有相同ha</strong>shcode值的对象，这时会调<strong>用equals（）方</strong>法来检查hashcode相等的对象是否真的相同。如果<strong>两者相同，HashSet就不会让加入操作成功</strong>。</p>
<h1 id="hashCode（）与equals（）的相关规定："><a href="#hashCode（）与equals（）的相关规定：" class="headerlink" title="hashCode（）与equals（）的相关规定："></a><strong>hashCode（）与equals（）的相关规定：</strong></h1><ol>
<li>如果两个对象相等，则hashcode一定也是相同的</li>
<li>两个对象相等,对两个equals方法返回true</li>
<li>两个对象有相同的hashcode值，它们也不一定是相等的</li>
<li>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</li>
<li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li>
</ol>
<h1 id="与equals的区别"><a href="#与equals的区别" class="headerlink" title="==与equals的区别"></a><strong>==与equals的区别</strong></h1><ol>
<li>==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同</li>
<li>==是指对内存地址进行比较 equals()是对字符串的内容进行比较</li>
<li>==指引用是否相同 equals()指的是值是否相同</li>
</ol>
<h1 id="HashMap的底层实现"><a href="#HashMap的底层实现" class="headerlink" title="HashMap的底层实现"></a>HashMap的底层实现</h1><p>JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。<strong>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p>
<p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p>
<p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
<h1 id="HashMap-的长度为什么是2的幂次方"><a href="#HashMap-的长度为什么是2的幂次方" class="headerlink" title="HashMap 的长度为什么是2的幂次方"></a>HashMap 的长度为什么是2的幂次方</h1><p>为了能让 <strong>HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀</strong>。我们上面也讲到了过了，<strong>Hash 值的范围值</strong>-2147483648到2147483647，前后加起来大概<strong>40亿的映射空间</strong>，<strong>只要哈希函数映射得比较均匀松</strong>散，一般应用是很难出现碰撞的。<strong>但问题是一个40亿长度的数组</strong>，<strong>内存是放不下的</strong>。所以这个散列值是不<strong>能直接拿来用</strong>的。用<strong>之前还要先做对数组的长度取模运算</strong>，得<strong>到的余数</strong>才能<strong>用来要存放的位置</strong>也就是<strong>对应的数组下标</strong>。这个数组下标的计算方法是<strong>“ (n - 1) &amp; hash”</strong>。（n代表数组长度）。这也就<strong>解释了 HashMap 的长度为什么是2的幂次方</strong>。</p>
<p><strong>这个算法应该如何设计呢？</strong></p>
<p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：<strong>“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方；）。”</strong> 并且 <strong>采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</strong></p>
<h1 id="HashMap-多线程操作导致死循环问题"><a href="#HashMap-多线程操作导致死循环问题" class="headerlink" title="HashMap 多线程操作导致死循环问题"></a>HashMap 多线程操作导致死循环问题</h1><p>主要原因在于 <strong>并发下的Rehash 会造成元素之间会形成一个循环链表</strong>。<strong>不过，jdk 1.8 后解决了这个问题</strong>，但是还是不建议在多线程下使用 HashMap,<strong>因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失</strong>。<strong>并发</strong>环境下推荐使用 <strong>ConcurrentHashMap</strong> 。</p>
<h1 id="ConcurrentHashMap-和-Hashtable-的区别"><a href="#ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别"></a>ConcurrentHashMap 和 Hashtable 的区别</h1><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在<strong>实现线程安全的方式上不同</strong>。</p>
<ul>
<li><strong>底层数据结构：</strong> <strong>JDK1.7的 ConcurrentHashMap 底层</strong>采用 <strong>分段的数组+链表</strong> 实现，<strong>JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树</strong>。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，<strong>数组是 HashMap 的主体</strong>，链表则是主要为了<strong>解决哈希冲突而存在的</strong>；</li>
<li><strong>实现线程安全的方式（重要）：</strong> ① <strong>在JDK1.7的时候，ConcurrentHashMap（分段锁）</strong> 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong>Hashtable(同一把锁)</strong> :使用 <strong>synchronized 来保证线程安全</strong>，效率非常低下。<strong>当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</strong></li>
</ul>
<h1 id="ConcurrentHashMap线程安全的具体实现方式-底层具体实现"><a href="#ConcurrentHashMap线程安全的具体实现方式-底层具体实现" class="headerlink" title="ConcurrentHashMap线程安全的具体实现方式/底层具体实现"></a>ConcurrentHashMap线程安全的具体实现方式/底层具体实现</h1><h3 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h3><p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>
<p><strong>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成</strong>。</p>
<p>Segment 实现了 ReentrantLock,所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。</p>
<ul>
<li><strong>static</strong> <strong>class</strong> <strong>Segment</strong>&lt;<strong>K</strong>,<strong>V</strong>&gt; <strong>extends</strong> <strong>ReentrantLock</strong> <strong>implements</strong> <strong>Serializable</strong> {</li>
<li>}</li>
</ul>
<p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</p>
<h3 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h3><p>ConcurrentHashMap<strong>取消了Segment分段锁采用CAS和synchronized来保证并发安全。数据结构跟HashMap1.8的结构类似，数组+链表/红黑二叉树。Java 8在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为O(N)）转换为红黑树（寻址时间复杂度为O(long(N))）</strong></p>
<p><strong>synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</strong></p>
<h2 id="comparable-和-Comparator的区别"><a href="#comparable-和-Comparator的区别" class="headerlink" title="comparable 和 Comparator的区别"></a>comparable 和 Comparator的区别</h2><ul>
<li>comparable接口实际上是出自java.lang包 它有一个 compareTo(Object obj)方法用来排序</li>
<li>comparator接口实际上是出自 java.util 包它有一个compare(Object obj1, Object obj2)方法用来排序</li>
</ul>
<p>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo()方法或compare()方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo()方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 Collections.sort().</p>
<h2 id="Comparator定制排序"><a href="#Comparator定制排序" class="headerlink" title="Comparator定制排序"></a>Comparator定制排序</h2><ul>
<li>​        ArrayList<Integer> arrayList = <strong>new</strong> ArrayList<Integer>();</li>
<li>​        arrayList.add(-1);</li>
<li>​        arrayList.add(3);</li>
<li>​        arrayList.add(3);</li>
<li>​        arrayList.add(-5);</li>
<li>​        arrayList.add(7);</li>
<li>​        arrayList.add(4);</li>
<li>​        arrayList.add(-9);</li>
<li>​        arrayList.add(-7);</li>
<li>​        System.out.println(“原始数组:”);</li>
<li>​        System.out.println(arrayList);</li>
<li>​        <em>// void reverse(List list)：反转</em></li>
<li>​        Collections.reverse(arrayList);</li>
<li>​        System.out.println(“Collections.reverse(arrayList):”);</li>
<li>​        System.out.println(arrayList);</li>
<li></li>
<li>​        <em>// void sort(List list),按自然排序的升序排序</em></li>
<li>​        Collections.sort(arrayList);</li>
<li>​        System.out.println(“Collections.sort(arrayList):”);</li>
<li>​        System.out.println(arrayList);</li>
<li>​        <em>// 定制排序的用法</em></li>
<li>​        Collections.sort(arrayList, <strong>new</strong> Comparator<Integer>() {</li>
<li></li>
<li>​            <strong>@Override</strong></li>
<li>​            <strong>public</strong> <strong>int</strong> <strong>compare</strong>(Integer o1, Integer o2) {</li>
<li>​                <strong>return</strong> o2.compareTo(o1);</li>
<li>​            }</li>
<li>​        });</li>
<li>​        System.out.println(“定制排序后：”);</li>
<li>​        System.out.println(arrayList);</li>
</ul>
<p>Output:</p>
<ul>
<li>原始数组:</li>
<li>[-1, 3, 3, -5, 7, 4, -9, -7]</li>
<li><strong>Collections</strong>.reverse(<strong>arrayList</strong>):</li>
<li>[-7, -9, 4, 7, -5, 3, 3, -1]</li>
<li><strong>Collections</strong>.sort(<strong>arrayList</strong>):</li>
<li>[-9, -7, -5, -1, 3, 3, 4, 7]</li>
<li>定制排序后：</li>
<li>[7, 4, 3, 3, -1, -5, -7, -9]</li>
</ul>
<h2 id="重写compareTo方法实现按年龄来排序"><a href="#重写compareTo方法实现按年龄来排序" class="headerlink" title="重写compareTo方法实现按年龄来排序"></a>重写compareTo方法实现按年龄来排序</h2><ul>
<li><p><em>// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列</em></p>
</li>
<li><p><em>// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他</em></p>
</li>
<li><p><em>// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了</em></p>
</li>
<li></li>
<li><p><strong>public</strong>  <strong>class</strong> <strong>Person</strong> <strong>implements</strong> <strong>Comparable</strong>&lt;<strong>Person</strong>&gt; {</p>
</li>
<li><p>​    <strong>private</strong> String name;</p>
</li>
<li><p>​    <strong>private</strong> <strong>int</strong> age;</p>
</li>
<li></li>
<li><p>​    <strong>public</strong> <strong>Person</strong>(String name, <strong>int</strong> age) {</p>
</li>
<li><p>​        <strong>super</strong>();</p>
</li>
<li><p>​        <strong>this</strong>.name = name;</p>
</li>
<li><p>​        <strong>this</strong>.age = age;</p>
</li>
<li><p>​    }</p>
</li>
<li></li>
<li><p>​    <strong>public</strong> String <strong>getName</strong>() {</p>
</li>
<li><p>​        <strong>return</strong> name;</p>
</li>
<li><p>​    }</p>
</li>
<li></li>
<li><p>​    <strong>public</strong> <strong>void</strong> <strong>setName</strong>(String name) {</p>
</li>
<li><p>​        <strong>this</strong>.name = name;</p>
</li>
<li><p>​    }</p>
</li>
<li></li>
<li><p>​    <strong>public</strong> <strong>int</strong> <strong>getAge</strong>() {</p>
</li>
<li><p>​        <strong>return</strong> age;</p>
</li>
<li><p>​    }</p>
</li>
<li></li>
<li><p>​    <strong>public</strong> <strong>void</strong> <strong>setAge</strong>(<strong>int</strong> age) {</p>
</li>
<li><p>​        <strong>this</strong>.age = age;</p>
</li>
<li><p>​    }</p>
</li>
<li></li>
<li><p>​    <em>/**</em></p>
</li>
<li><p>​     <em>* TODO重写compareTo方法实现按年龄来排序</em></p>
</li>
<li><p>​     <em>*/</em></p>
</li>
<li><p>​    <strong>@Override</strong></p>
</li>
<li><p>​    <strong>public</strong> <strong>int</strong> <strong>compareTo</strong>(Person o) {</p>
</li>
<li><p>​        <em>// TODO Auto-generated method stub</em></p>
</li>
<li><p>​        <strong>if</strong> (<strong>this</strong>.age &gt; o.getAge()) {</p>
</li>
<li><p>​            <strong>return</strong> 1;</p>
</li>
<li><p>​        } <strong>else</strong> <strong>if</strong> (<strong>this</strong>.age &lt; o.getAge()) {</p>
</li>
<li><p>​            <strong>return</strong> -1;</p>
</li>
<li><p>​        }</p>
</li>
<li><p>​        <strong>return</strong> age;</p>
</li>
<li><p>​    }</p>
</li>
<li><p>}</p>
</li>
<li><p>​    <strong>public</strong> <strong>static</strong> <strong>void</strong> <strong>main</strong>(String[] args) {</p>
</li>
<li><p>​        TreeMap&lt;Person, String&gt; pdata = <strong>new</strong> TreeMap&lt;Person, String&gt;();</p>
</li>
<li><p>​        pdata.put(<strong>new</strong> Person(“张三”, 30), “zhangsan”);</p>
</li>
<li><p>​        pdata.put(<strong>new</strong> Person(“李四”, 20), “lisi”);</p>
</li>
<li><p>​        pdata.put(<strong>new</strong> Person(“王五”, 10), “wangwu”);</p>
</li>
<li><p>​        pdata.put(<strong>new</strong> Person(“小红”, 5), “xiaohong”);</p>
</li>
<li><p>​        <em>// 得到key的值的同时得到key所对应的值</em></p>
</li>
<li><p>​        Set<Person> keys = pdata.keySet();</p>
</li>
<li><p>​        <strong>for</strong> (Person key : keys) {</p>
</li>
<li><p>​            System.out.println(key.getAge() + “-“ + key.getName());</p>
</li>
<li></li>
<li><p>​        }</p>
</li>
<li><p>​    }</p>
</li>
</ul>
<p>Output：</p>
<ul>
<li>5-小红</li>
<li>10-王五</li>
<li>20-李四</li>
<li>30-张三</li>
</ul>
<h1 id="集合框架底层数据结构总结"><a href="#集合框架底层数据结构总结" class="headerlink" title="集合框架底层数据结构总结"></a>集合框架底层数据结构总结</h1><p>Collection</p>
<p>\1. List</p>
<ul>
<li><strong>Arraylist：</strong> Object数组</li>
<li><strong>Vector：</strong> Object数组</li>
<li><strong>LinkedList：</strong> 双向链表(JDK1.6之前为循环链表，JDK1.7取消了循环) 详细可阅读<a href="https://www.cnblogs.com/xingele0917/p/3696593.html" target="_blank" rel="noopener">JDK1.7-LinkedList循环链表优化</a></li>
</ul>
<p>\2. Set</p>
<ul>
<li><strong>HashSet（无序，唯一）:</strong> 基于 HashMap 实现的，底层采用 HashMap 来保存元素</li>
<li><strong>LinkedHashSet：</strong> LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。</li>
<li><strong>TreeSet（有序，唯一）：</strong> 红黑树(自平衡的排序二叉树。)</li>
</ul>
<p>Map</p>
<ul>
<li><strong>HashMap：</strong> JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间</li>
<li><strong>LinkedHashMap：</strong> LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<a href="https://www.imooc.com/article/22931" target="_blank" rel="noopener">《LinkedHashMap 源码详细分析（JDK1.8）》</a></li>
<li><strong>Hashtable：</strong> 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li>
<li><strong>TreeMap：</strong> 红黑树（自平衡的排序二叉树）</li>
</ul>
<h1 id="如何选用集合"><a href="#如何选用集合" class="headerlink" title="如何选用集合?"></a>如何选用集合?</h1><h2 id="集合的选用"><a href="#集合的选用" class="headerlink" title="集合的选用"></a>集合的选用</h2><p>主要根据<strong>集合的特点来选用</strong>，比如我们需要<strong>根据键值获取到元素值时就选用Map接口下的集合</strong>，需要<strong>排序时选择TreeMap,不需要排序时就选择HashMap,需要保证线程安全就选用ConcurrentHashMap</strong>.当我们<strong>只需要存放元素值时，就选择实现Collection接口的集合，需要保证元素唯一时选择实现Set接口的集合比如TreeSet或HashSet，不需要就选择实现List接口的比如ArrayList或LinkedList</strong>，然后再根据实现这些接口的集合的特点来选用。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>集合</tag>
        <tag>容器</tag>
      </tags>
  </entry>
  <entry>
    <title>JVM(上)</title>
    <url>/2020/05/19/JVM(%E4%B8%8A)/</url>
    <content><![CDATA[<h1 id="JVM-上"><a href="#JVM-上" class="headerlink" title="JVM(上)"></a>JVM(上)</h1><ol>
<li><h3 id="介绍下-Java-内存区域-运行时数据区"><a href="#介绍下-Java-内存区域-运行时数据区" class="headerlink" title="介绍下 Java 内存区域(运行时数据区)"></a>介绍下 Java 内存区域(运行时数据区)</h3><p>1.1. 程序计数器<br>1.2. Java 虚拟机栈<br>1.3. 本地方法栈<br>1.4. 堆<br>1.5. 方法区<br>1.5.1. 方法区和永久代的关系<br>1.5.2. 常用参数<br>1.5.3. 为什么要将永久代(PermGen)替换为元空间(MetaSpace)呢?<br>1.6. 运行时常量池<br>1.7. 直接内存</p>
</li>
<li><h3 id="说一下Java对象的创建过程"><a href="#说一下Java对象的创建过程" class="headerlink" title="说一下Java对象的创建过程"></a>说一下Java对象的创建过程</h3></li>
<li><h3 id="对象的访问定位有哪两种方式"><a href="#对象的访问定位有哪两种方式" class="headerlink" title="对象的访问定位有哪两种方式?"></a>对象的访问定位有哪两种方式?</h3></li>
<li><h3 id="说一下堆内存中对象的分配的基本策略"><a href="#说一下堆内存中对象的分配的基本策略" class="headerlink" title="说一下堆内存中对象的分配的基本策略"></a>说一下堆内存中对象的分配的基本策略</h3></li>
<li><h3 id="Minor-Gc和Full-GC-有什么不同呢？"><a href="#Minor-Gc和Full-GC-有什么不同呢？" class="headerlink" title="Minor Gc和Full GC 有什么不同呢？"></a>Minor Gc和Full GC 有什么不同呢？</h3></li>
<li><h3 id="如何判断对象是否死亡-两种方法"><a href="#如何判断对象是否死亡-两种方法" class="headerlink" title="如何判断对象是否死亡?(两种方法)"></a>如何判断对象是否死亡?(两种方法)</h3><p>6.1. 引用计数法</p>
<p>6.2. 可达性分析算法</p>
</li>
<li><h3 id="简单的介绍一下强引用-软引用-弱引用-虚引用"><a href="#简单的介绍一下强引用-软引用-弱引用-虚引用" class="headerlink" title="简单的介绍一下强引用,软引用,弱引用,虚引用"></a>简单的介绍一下强引用,软引用,弱引用,虚引用</h3><p>7.1. 强引用(StrongReference)<br>7.2. 软引用(SoftReference)<br>7.3. 弱引用(WeakReference)</p>
</li>
<li><h3 id="如何判断一个常量是废弃常量"><a href="#如何判断一个常量是废弃常量" class="headerlink" title="如何判断一个常量是废弃常量?"></a>如何判断一个常量是废弃常量?</h3></li>
<li><h3 id="如何判断一个类是无用的类"><a href="#如何判断一个类是无用的类" class="headerlink" title="如何判断一个类是无用的类?"></a>如何判断一个类是无用的类?</h3><ul>
<li><p>10 垃圾收集有哪些算法，各自的特点？</p>
</li>
<li><p>10.1 标记-清除算法<br>10.2 复制算法<br>10.3 标记-整理算法<br>10.4 分代收集算法</p>
</li>
<li><ol start="11">
<li>HotSpot为什么要分为新生代和老年代？</li>
<li>常见的垃圾回收器有那些?</li>
<li><ol>
<li>Serial收集器</li>
</ol>
</li>
<li><ol start="2">
<li>ParNew收集器</li>
</ol>
</li>
<li><ol start="3">
<li>Parallel Scavenge收集器</li>
</ol>
</li>
<li><ol start="4">
<li>Serial Old收集器</li>
</ol>
</li>
<li><ol start="5">
<li>Parallel Old收集器</li>
</ol>
</li>
<li><ol start="6">
<li>CMS收集器</li>
</ol>
</li>
<li><ol start="7">
<li>G1收集器</li>
</ol>
</li>
</ol>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>基础</tag>
        <tag>JVM</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发知识进阶(中)</title>
    <url>/2020/05/19/Java%20%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%AD%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Java-并发知识进阶-中"><a href="#Java-并发知识进阶-中" class="headerlink" title="Java 并发知识进阶(中)"></a>Java 并发知识进阶(中)</h1><ol>
<li><h4 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h4><p>1.1. 说一说自己对于 synchronized 关键字的了解<br>1.2. 说说自己是怎么使用 synchronized 关键字，在项目中用到了吗<br>1.3. 讲一下 synchronized 关键字的底层原理<br>1.4. 说说 JDK1.6 之后的synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗<br>1.5. 谈谈 synchronized和ReentrantLock 的区别</p>
</li>
<li><h4 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h4><p>2.1. 讲一下Java内存模型<br>2.2. 说说 synchronized 关键字和 volatile 关键字的区别</p>
</li>
<li><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><p>3.1. ThreadLocal简介<br>3.2. ThreadLocal示例<br>3.3. ThreadLocal原理<br>3.4. ThreadLocal 内存泄露问题</p>
</li>
</ol>
<a id="more"></a>

<h2 id="synchronized-关键字-1"><a href="#synchronized-关键字-1" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h2><p>1.1. 说一说自己对于 synchronized 关键字的了解</p>
<p>synchronized关键字<strong>解决</strong>的是<strong>多个线程之间访问资源的同步性</strong>，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p>
<p>另外，在 Java <strong>早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock</strong> 来实现的，Java 的线程是映射到操作系统的<strong>原生线程之上</strong>的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状<strong>态之间的转换</strong>需要<strong>相对比较长的时间，时间成本相对较高</strong>，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 <strong>Java 6</strong> 之后 <strong>Java 官方对从 JVM 层面对synchronized 较大优化</strong>，所以现在的 <strong>synchronized 锁效率也优化得很不错了</strong>。JDK1.6对锁的实现<strong>引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销</strong></p>
<h3 id="1-2-说说自己是怎么使用-synchronized-关键字，在项目中用到了吗"><a href="#1-2-说说自己是怎么使用-synchronized-关键字，在项目中用到了吗" class="headerlink" title="1.2. 说说自己是怎么使用 synchronized 关键字，在项目中用到了吗"></a>1.2. 说说自己是怎么使用 synchronized 关键字，在项目中用到了吗</h3><p><strong>synchronized关键字最主要的三种使用方式：</strong></p>
<ul>
<li><strong>修饰实例方法:</strong> 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</li>
<li><strong>修饰静态方法:</strong> :也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，<strong>因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁</strong>。</li>
<li><strong>修饰代码块:</strong> 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li>
</ul>
<p><strong>总结：</strong> synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！</p>
<p><strong>双重校验锁实现对象单例（线程安全）</strong></p>
<ul>
<li><strong>public</strong> <strong>class</strong> <strong>Singleton</strong> {</li>
<li></li>
<li>​    <strong>private</strong> <strong>volatile</strong> <strong>static</strong> Singleton uniqueInstance;</li>
<li></li>
<li>​    <strong>private</strong> <strong>Singleton</strong>() {</li>
<li>​    }</li>
<li></li>
<li>​    <strong>public</strong> <strong>static</strong> Singleton <strong>getUniqueInstance</strong>() {</li>
<li>​       <em>//先判断对象是否已经实例过，没有实例化过才进入加锁代码</em></li>
<li>​        <strong>if</strong> (uniqueInstance == <strong>null</strong>) {</li>
<li>​            <em>//类对象加锁</em></li>
<li>​            <strong>synchronized</strong> (Singleton.class) {</li>
<li>​                <strong>if</strong> (uniqueInstance == <strong>null</strong>) {</li>
<li>​                    uniqueInstance = <strong>new</strong> Singleton();</li>
<li>​                }</li>
<li>​            }</li>
<li>​        }</li>
<li>​        <strong>return</strong> uniqueInstance;</li>
<li>​    }</li>
<li>}</li>
</ul>
<p>另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。</p>
<p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：</p>
<ol>
<li>为 uniqueInstance 分配内存空间</li>
<li>初始化 uniqueInstance</li>
<li>将 uniqueInstance 指向分配的内存地址</li>
</ol>
<p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出先问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p>
<p>使用 <strong>volatile 可以禁止 JVM 的指令重排</strong>，保证在多线程环境下也能正常运行。</p>
<h3 id="1-3-讲一下-synchronized-关键字的底层原理"><a href="#1-3-讲一下-synchronized-关键字的底层原理" class="headerlink" title="1.3. 讲一下 synchronized 关键字的底层原理"></a>1.3. 讲一下 synchronized 关键字的底层原理</h3><p><strong>synchronized 关键字底层原理属于 JVM 层面。</strong></p>
<p><strong>① synchronized 同步语句块的情况</strong></p>
<ul>
<li><strong>public</strong> <strong>class</strong> <strong>SynchronizedDemo</strong> {</li>
<li>​    <strong>public</strong> <strong>void</strong> <strong>method</strong>() {</li>
<li>​        <strong>synchronized</strong> (<strong>this</strong>) {</li>
<li>​            System.out.println(“synchronized 代码块”);</li>
<li>​        }</li>
<li>​    }</li>
<li>}</li>
</ul>
<p>通过 JDK 自带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息：首先切换到类的对应目录执行 javac SynchronizedDemo.java 命令生成编译后的 .class 文件，然后执行javap -c -s -v -l SynchronizedDemo.class。</p>
<p><img src="E:%5CShellExt%5Cerer961115@163.com%5C7980bdb3d409483ea4a111231c23c3c7%5C0489278e1a5d.png" alt="img"></p>
<p>从上面我们可以看出：</p>
<p><strong>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</strong> 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p>
<p><strong>② synchronized 修饰方法的的情况</strong></p>
<ul>
<li><strong>public</strong> <strong>class</strong> <strong>SynchronizedDemo2</strong> {</li>
<li>​    <strong>public</strong> <strong>synchronized</strong> <strong>void</strong> <strong>method</strong>() {</li>
<li>​        System.out.println(“synchronized 方法”);</li>
<li>​    }</li>
<li>}</li>
</ul>
<p><img src="E:%5CShellExt%5Cerer961115@163.com%5C2d1c1d8ade924f21ab3da430fe3b680f%5Ced03d7f570b8.png" alt="img"></p>
<p>synchronized关键字原理</p>
<p>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p>
<p>1.4. 说说 JDK1.6 之后的synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗</p>
<p>JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。</p>
<p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p>
<p><strong>①偏向锁</strong></p>
<p><strong>引入偏向锁的目的和引入轻量级锁的目的很像，他们都是为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。但是不同是：轻量级锁在无竞争的情况下使用 CAS 操作去代替使用互斥量。而偏向锁在无竞争的情况下会把整个同步都消除掉</strong>。</p>
<p><strong>② 轻量级锁</strong></p>
<p>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)。<strong>轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。另外，轻量级锁的加锁和解锁都用到了CAS操作。</strong></p>
<p><strong>③ 自旋锁和自适应自旋</strong></p>
<p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。</p>
<p>互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态中完成（用户态转换到内核态会耗费时间）。</p>
<p><strong>一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。</strong> 所以，虚拟机的开发团队就这样去考虑：“我们能不能让后面来的请求获取锁的线程等待一会而不被挂起呢？看看持有锁的线程是否很快就会释放锁”。<strong>为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就叫做自旋</strong>。自旋次数的默认值是10次，用户可以修改<code>--XX:PreBlockSpin</code>来更改。<strong>在 JDK1.6 中引入了自适应的自旋锁。自适应的自旋锁带来的改进就是：自旋的时间不在固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定</strong></p>
<p><strong>④ 锁消除</strong></p>
<p>锁消除理解起来很简单，它指的就是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求锁的时间。</p>
<p><strong>⑤ 锁粗化</strong></p>
<p>原则上，我们再编写代码的时候，总是推荐将同步快的作用范围限制得尽量小——只在共享数据的实际作用域才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待线程也能尽快拿到锁。</p>
<h4 id="1-5-谈谈-synchronized和ReentrantLock-的区别"><a href="#1-5-谈谈-synchronized和ReentrantLock-的区别" class="headerlink" title="1.5. 谈谈 synchronized和ReentrantLock 的区别"></a>1.5. 谈谈 synchronized和ReentrantLock 的区别</h4><p><strong>① 两者都是可重入锁</strong></p>
<p>两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p>
<p><strong>② synchronized 依赖于 JVM 而 ReenTrantLock 依赖于 API</strong></p>
<p>synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReenTrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p>
<p><strong>③ ReenTrantLock 比 synchronized 增加了一些高级功能</strong></p>
<p>相比synchronized，ReenTrantLock增加了一些高级功能。主要来说主要有三点：<strong>①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）</strong></p>
<ul>
<li><strong>ReenTrantLock提供了一种能够中断等待锁的线程的机制</strong>，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li>
<li><strong>ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</strong> ReenTrantLock默认情况是非公平的，可以通过 ReenTrantLock类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li>
<li>synchronized关键字与wait()和notify/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），<strong>线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。</li>
</ul>
<p>如果你想使用上述功能，那么选择ReenTrantLock是一个不错的选择。</p>
<p><strong>④ 性能已不是选择标准</strong></p>
<p>在JDK1.6之前，synchronized 的性能是比 ReenTrantLock 差很多。具体表示为：synchronized 关键字吞吐量岁线程数的增加，下降得非常严重。而ReenTrantLock 基本保持一个比较稳定的水平。我觉得这也侧面反映了， synchronized 关键字还有非常大的优化余地。后续的技术发展也证明了这一点，我们上面也讲了在 JDK1.6 之后 JVM 团队对 synchronized 关键字做了很多优化。<strong>JDK1.6 之后，synchronized 和 ReenTrantLock 的性能基本是持平了。所以网上那些说因为性能才选择 ReenTrantLock 的文章都是错的！JDK1.6之后，性能已经不是选择synchronized和ReenTrantLock的影响因素了！而且虚拟机在未来的性能改进中会更偏向于原生的synchronized，所以还是提倡在synchronized能满足你的需求的情况下，优先考虑使用synchronized关键字来进行同步！优化后的synchronized和ReenTrantLock一样，在很多地方都是用到了CAS操作</strong>。</p>
<h3 id="2-volatile关键字"><a href="#2-volatile关键字" class="headerlink" title="2. volatile关键字"></a>2. volatile关键字</h3><h6 id="2-1-讲一下Java内存模型"><a href="#2-1-讲一下Java内存模型" class="headerlink" title="2.1. 讲一下Java内存模型"></a>2.1. 讲一下Java内存模型</h6><p>在 JDK1.2 之前，Java的内存模型实现总是从<strong>主存</strong>（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存<strong>本地内存</strong>比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成<strong>数据的不一致</strong>。</p>
<p><img src="E:%5CShellExt%5Cerer961115@163.com%5Cb58d03d6a8724825862e51db7a075934%5Cf1728707cd89.png" alt="img"></p>
<p>要解决这个问题，就需要把变量声明为<strong>volatile</strong>，这就指示 JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。</p>
<p>说白了， <strong>volatile</strong> 关键字的主要作用就是保证变量的可见性然后还有一个作用是防止指令重排序。</p>
<p><img src="E:%5CShellExt%5Cerer961115@163.com%5Cf014b61ab7004fbaa9a44e4e5c34c548%5Ce48528714ce5.png" alt="img"></p>
<h5 id="2-2-说说-synchronized-关键字和-volatile-关键字的区别"><a href="#2-2-说说-synchronized-关键字和-volatile-关键字的区别" class="headerlink" title="2.2. 说说 synchronized 关键字和 volatile 关键字的区别"></a>2.2. 说说 synchronized 关键字和 volatile 关键字的区别</h5><p>synchronized关键字和volatile关键字比较</p>
<ul>
<li><strong>volatile关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以<strong>volatile性能肯定比synchronized关键字要好</strong>。但是<strong>volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块</strong>。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，<strong>实际开发中使用 synchronized 关键字的场景还是更多一些</strong>。</li>
<li><strong>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞</strong></li>
<li><strong>volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。</strong></li>
<li><strong>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。</strong></li>
</ul>
<h6 id="3-ThreadLocal"><a href="#3-ThreadLocal" class="headerlink" title="3. ThreadLocal"></a>3. ThreadLocal</h6><p>3.1. ThreadLocal简介</p>
<p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong> JDK中提供的ThreadLocal类正是为了解决这样的问题。 <strong>ThreadLocal</strong>类主要解决的就是让每个线程绑定自己的值，可以将<strong>ThreadLocal</strong>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</p>
<p><strong>如果你创建了一个ThreadLocal</strong>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是<strong>ThreadLocal变量名的由来。他们可以使用</strong> <strong>get（）</strong> <strong>和</strong> <strong>set（）</strong> <strong>方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</strong></p>
<p>再举个简单的例子：</p>
<p>比如有两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么ThreadLocal就是用来这两个线程竞争的。</p>
<p>3.2. ThreadLocal示例</p>
<p>相信看了上面的解释，大家已经搞懂 ThreadLocal 类是个什么东西了。</p>
<ul>
<li><strong>import</strong> java.text.SimpleDateFormat;</li>
<li><strong>import</strong> java.util.Random;</li>
<li></li>
<li><strong>public</strong> <strong>class</strong> <strong>ThreadLocalExample</strong> <strong>implements</strong> <strong>Runnable</strong>{</li>
<li></li>
<li>​     <em>// SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本</em></li>
<li>​    <strong>private</strong> <strong>static</strong> <strong>final</strong> ThreadLocal<SimpleDateFormat> formatter = ThreadLocal.withInitial(() -&gt; <strong>new</strong> SimpleDateFormat(“yyyyMMdd HHmm”));</li>
<li></li>
<li>​    <strong>public</strong> <strong>static</strong> <strong>void</strong> <strong>main</strong>(String[] args) <strong>throws</strong> InterruptedException {</li>
<li>​        ThreadLocalExample obj = <strong>new</strong> ThreadLocalExample();</li>
<li>​        <strong>for</strong>(<strong>int</strong> i=0 ; i&lt;10; i++){</li>
<li>​            Thread t = <strong>new</strong> Thread(obj, “”+i);</li>
<li>​            Thread.sleep(<strong>new</strong> Random().nextInt(1000));</li>
<li>​            t.start();</li>
<li>​        }</li>
<li>​    }</li>
<li></li>
<li>​    <strong>@Override</strong></li>
<li>​    <strong>public</strong> <strong>void</strong> <strong>run</strong>() {</li>
<li>​        System.out.println(“Thread Name= “+Thread.currentThread().getName()+” default Formatter = “+formatter.get().toPattern());</li>
<li>​        <strong>try</strong> {</li>
<li>​            Thread.sleep(<strong>new</strong> Random().nextInt(1000));</li>
<li>​        } <strong>catch</strong> (InterruptedException e) {</li>
<li>​            e.printStackTrace();</li>
<li>​        }</li>
<li>​        <em>//formatter pattern is changed here by thread, but it won’t reflect to other threads</em></li>
<li>​        formatter.set(<strong>new</strong> SimpleDateFormat());</li>
<li></li>
<li>​        System.out.println(“Thread Name= “+Thread.currentThread().getName()+” formatter = “+formatter.get().toPattern());</li>
<li>​    }</li>
<li></li>
<li>}</li>
</ul>
<p>Output:</p>
<ul>
<li>Thread Name= 0 default Formatter = yyyyMMdd HHmm</li>
<li>Thread Name= 0 formatter = yy-M-d ah:mm</li>
<li>Thread Name= 1 default Formatter = yyyyMMdd HHmm</li>
<li>Thread Name= 2 default Formatter = yyyyMMdd HHmm</li>
<li>Thread Name= 1 formatter = yy-M-d ah:mm</li>
<li>Thread Name= 3 default Formatter = yyyyMMdd HHmm</li>
<li>Thread Name= 2 formatter = yy-M-d ah:mm</li>
<li>Thread Name= 4 default Formatter = yyyyMMdd HHmm</li>
<li>Thread Name= 3 formatter = yy-M-d ah:mm</li>
<li>Thread Name= 4 formatter = yy-M-d ah:mm</li>
<li>Thread Name= 5 default Formatter = yyyyMMdd HHmm</li>
<li>Thread Name= 5 formatter = yy-M-d ah:mm</li>
<li>Thread Name= 6 default Formatter = yyyyMMdd HHmm</li>
<li>Thread Name= 6 formatter = yy-M-d ah:mm</li>
<li>Thread Name= 7 default Formatter = yyyyMMdd HHmm</li>
<li>Thread Name= 7 formatter = yy-M-d ah:mm</li>
<li>Thread Name= 8 default Formatter = yyyyMMdd HHmm</li>
<li>Thread Name= 9 default Formatter = yyyyMMdd HHmm</li>
<li>Thread Name= 8 formatter = yy-M-d ah:mm</li>
<li>Thread Name= 9 formatter = yy-M-d ah:mm</li>
</ul>
<p>从输出中可以看出，Thread-0已经改变了formatter的值，但仍然是thread-2默认格式化程序与初始化值相同，其他线程也一样。</p>
<p>上面有一段代码用到了创建 ThreadLocal 变量的那段代码用到了 Java8 的知识，它等于下面这段代码，如果你写了下面这段代码的话，IDEA会提示你转换为Java8的格式(IDEA真的不错！)。因为ThreadLocal类在Java 8中扩展，使用一个新的方法withInitial()，将Supplier功能接口作为参数。</p>
<ul>
<li><strong>private</strong> <strong>static</strong> <strong>final</strong> ThreadLocal<SimpleDateFormat> formatter = <strong>new</strong> ThreadLocal<SimpleDateFormat>(){</li>
<li>​        <strong>@Override</strong></li>
<li>​        <strong>protected</strong> SimpleDateFormat <strong>initialValue</strong>()</li>
<li>​        {</li>
<li>​            <strong>return</strong> <strong>new</strong> SimpleDateFormat(“yyyyMMdd HHmm”);</li>
<li>​        }</li>
<li>​    };</li>
</ul>
<p>3.3. ThreadLocal原理</p>
<p>从 Thread类源代码入手。</p>
<ul>
<li><strong>public</strong> <strong>class</strong> <strong>Thread</strong> <strong>implements</strong> <strong>Runnable</strong> {</li>
<li>……</li>
<li><em>//与此线程有关的ThreadLocal值。由ThreadLocal类维护</em></li>
<li>ThreadLocal.ThreadLocalMap threadLocals = <strong>null</strong>;</li>
<li></li>
<li><em>//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</em></li>
<li>ThreadLocal.ThreadLocalMap inheritableThreadLocals = <strong>null</strong>;</li>
<li>……</li>
<li>}</li>
</ul>
<p>从上面Thread类 源代码可以看出Thread 类中有一个 threadLocals 和 一个 inheritableThreadLocals 变量，它们都是 ThreadLocalMap 类型的变量,我们可以把 ThreadLocalMap 理解为ThreadLocal 类实现的定制化的 HashMap。默认情况下这两个变量都是null，只有当前线程调用 ThreadLocal 类的 set或get方法时才创建它们，实际上调用这两个方法的时候，我们调用的是ThreadLocalMap类对应的 get()、set()方法。</p>
<p>ThreadLocal类的set()方法</p>
<ul>
<li>​    <strong>public</strong> <strong>void</strong> <strong>set</strong>(T value) {</li>
<li>​        Thread t = Thread.currentThread();</li>
<li>​        ThreadLocalMap map = getMap(t);</li>
<li>​        <strong>if</strong> (map != <strong>null</strong>)</li>
<li>​            map.set(<strong>this</strong>, value);</li>
<li>​        <strong>else</strong></li>
<li>​            createMap(t, value);</li>
<li>​    }</li>
<li>​    ThreadLocalMap <strong>getMap</strong>(Thread t) {</li>
<li>​        <strong>return</strong> t.threadLocals;</li>
<li>​    }</li>
</ul>
<p>通过上面这些内容，我们足以通过猜测得出结论：<strong>最终的变量是放在了当前线程的</strong> <strong>ThreadLocalMap</strong> <strong>中，并不是存在</strong> <strong>ThreadLocal</strong> <strong>上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。</strong></p>
<p><strong>每个Thread中都具备一个ThreadLocalMap</strong>，而<strong>ThreadLocalMap可以存储以ThreadLocal为key的键值对。这里解释了为什么每个线程访问同一个ThreadLocal</strong>，得到的确是不同的数值。另外，ThreadLocal <strong>是 map结构是为了让每个线程可以关联多个</strong> ThreadLoca变量。</p>
<p>ThreadLocalMap是ThreadLocal的静态内部类。</p>
<p><img src="E:%5CShellExt%5Cerer961115@163.com%5C5b73319094a746b0b30eaf269a40c11e%5Cb7b2ff794db.jpeg" alt="img"></p>
<p>ThreadLocal内部类</p>
<p>3.4. ThreadLocal 内存泄露问题</p>
<p>ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会 key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。使用完 ThreadLocal方法后 最好手动调用remove()方法</p>
<ul>
<li>​      <strong>static</strong> <strong>class</strong> <strong>Entry</strong> <strong>extends</strong> <strong>WeakReference</strong>&lt;<strong>ThreadLocal</strong>&lt;?&gt;&gt; {</li>
<li>​            <em>/** The value associated with this ThreadLocal. \</em>/*</li>
<li>​            Object value;</li>
<li></li>
<li>​            Entry(ThreadLocal&lt;?&gt; k, Object v) {</li>
<li>​                <strong>super</strong>(k);</li>
<li>​                value = v;</li>
<li>​            }</li>
<li>​        }</li>
</ul>
<p><strong>弱引用介绍：</strong></p>
<p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p>
<p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>
]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发知识进阶(下)</title>
    <url>/2020/05/19/Java%20%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%8B%EF%BC%89/</url>
    <content><![CDATA[<h1 id="Java-并发知识进阶-下"><a href="#Java-并发知识进阶-下" class="headerlink" title="Java 并发知识进阶(下)"></a>Java 并发知识进阶(下)</h1><ol>
<li><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>1.1. 为什么要用线程池？<br>1.2. 实现 Runnable 接口和 Callable 接口的区别<br>1.3. 执行 execute() 方法和 submit() 方法的区别是什么呢？<br>1.4. 如何创建线程池</p>
</li>
<li><h3 id="Atomic-原子类"><a href="#Atomic-原子类" class="headerlink" title="Atomic 原子类"></a>Atomic 原子类</h3><p>2.1. 介绍一下 Atomic 原子类<br>2.2. JUC 包中的原子类是哪 4 类?<br>2.3. 讲讲 AtomicInteger 的使用<br>2.4. 能不能给我简单介绍一下 AtomicInteger 类的原理</p>
</li>
<li><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>3.1. AQS 介绍<br>3.2. AQS 原理分析<br>3.2.1. AQS 原理概览<br>3.2.2. AQS 对资源的共享方式<br>3.2.3. AQS 底层使用了模板方法模式<br>3.3. AQS 组件总结</p>
</li>
</ol>
<a id="more"></a>

<ol>
<li><h3 id="线程池-1"><a href="#线程池-1" class="headerlink" title="线程池"></a>线程池</h3></li>
</ol>
<p>1.1. 为什么要用线程池？</p>
<p>线程池提供了一种限制和管理资源（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。</p>
<p>线程池的好处：</p>
<ul>
<li><strong>降低资源消耗。</strong> 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li>
<li><strong>提高响应速度。</strong> 当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li>
<li><strong>提高线程的可管理性。</strong> 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li>
</ul>
<h3 id="1-2-实现-Runnable-接口和-Callable-接口的区别"><a href="#1-2-实现-Runnable-接口和-Callable-接口的区别" class="headerlink" title="1.2. 实现 Runnable 接口和 Callable 接口的区别"></a>1.2. 实现 Runnable 接口和 Callable 接口的区别</h3><p>如果想让线程池执行任务的话需要实现的 Runnable 接口或 Callable 接口。 Runnable 接口或 Callable 接口实现类都可以被 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行。两者的区别在于 <strong>Runnable 接口不会返回结果但是 Callable 接口可以返回结果</strong>。</p>
<p><strong>备注：</strong> 工具类Executors可以实现Runnable对象和Callable对象之间的相互转换。（Executors.callable（Runnable task）或Executors.callable（Runnable task，Object resule））。</p>
<h3 id="1-3-执行-execute-方法和-submit-方法的区别是什么呢？"><a href="#1-3-执行-execute-方法和-submit-方法的区别是什么呢？" class="headerlink" title="1.3. 执行 execute() 方法和 submit() 方法的区别是什么呢？"></a>1.3. 执行 execute() 方法和 submit() 方法的区别是什么呢？</h3><p>1)<strong>execute()</strong> <strong>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></p>
<p>2)<strong>submit()</strong> <strong>方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功</strong>，并且可以通过 future 的 get() 方法来获取返回值，get() 方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p>
<h3 id="1-4-如何创建线程池"><a href="#1-4-如何创建线程池" class="headerlink" title="1.4. 如何创建线程池"></a>1.4. 如何创建线程池</h3><p>《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 T<strong>hreadPoolExecutor</strong> 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p>
<p>Executors 返回线程池对象的弊端如下：</p>
<ul>
<li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致 OOM。</li>
<li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</li>
</ul>
<p><strong>方式一：通过构造方法实现</strong></p>
<p><img src="E:%5CShellExt%5Cerer961115@163.com%5C2e2873ea261f488fba81a89fee309981%5Ccc50caa98adb.png" alt="img"></p>
<p>通过构造方法实现</p>
<p><strong>方式二：通过 Executor 框架的工具类 Executors 来实现</strong></p>
<p>我们可以创建三种类型的 ThreadPoolExecutor：</p>
<ul>
<li><strong>FixedThreadPool</strong> ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li>
<li><strong>SingleThreadExecutor：</strong> 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li>
<li><strong>CachedThreadPool：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li>
</ul>
<p>对应 Executors 工具类中的方法如图所示：</p>
<p><img src="E:%5CShellExt%5Cerer961115@163.com%5Ca417855e153e4222af3128d1280dd1d8%5C338e318ed4b7.png" alt="img"></p>
<p>通过 Executor 框架的工具类 Executors 来实现</p>
<ol start="2">
<li><h4 id="Atomic-原子类-1"><a href="#Atomic-原子类-1" class="headerlink" title="Atomic 原子类"></a>Atomic 原子类</h4></li>
</ol>
<p>2.1. 介绍一下 Atomic 原子类</p>
<p>Atomic 翻译成中文是原子的意思。在化学上，我们知道原子是构成一般物质的最小单位，在化学反应中是不可分割的。在我们这里 Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。</p>
<p>所以，所谓原子类说简单点就是具有原子/原子操作特征的类。</p>
<p>并发包 java.util.concurrent 的原子类都存放在java.util.concurrent.atomic下,如下图所示。</p>
<p><img src="E:%5CShellExt%5Cerer961115@163.com%5C39f5c2602f4a471c8b2ba39abf041ae3%5C323d2ca6e11b.png" alt="img"></p>
<p>2.2. JUC 包中的原子类是哪 4 类?</p>
<p><strong>基本类型</strong></p>
<p>使用原子的方式更新基本类型</p>
<ul>
<li>AtomicInteger：整形原子类</li>
<li>AtomicLong：长整型原子类</li>
<li>AtomicBoolean：布尔型原子类</li>
</ul>
<p><strong>数组类型</strong></p>
<p>使用原子的方式更新数组里的某个元素</p>
<ul>
<li>AtomicIntegerArray：整形数组原子类</li>
<li>AtomicLongArray：长整形数组原子类</li>
<li>AtomicReferenceArray：引用类型数组原子类</li>
</ul>
<p><strong>引用类型</strong></p>
<ul>
<li>AtomicReference：引用类型原子类</li>
<li>AtomicStampedRerence：原子更新引用类型里的字段原子类</li>
<li>AtomicMarkableReference ：原子更新带有标记位的引用类型</li>
</ul>
<p><strong>对象的属性修改类型</strong></p>
<ul>
<li>AtomicIntegerFieldUpdater：原子更新整形字段的更新器</li>
<li>AtomicLongFieldUpdater：原子更新长整形字段的更新器</li>
<li>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li>
</ul>
<p>2.3. 讲讲 AtomicInteger 的使用</p>
<p><strong>AtomicInteger 类常用方法</strong></p>
<ul>
<li><strong>public</strong> <strong>final</strong> <strong>int</strong> <strong>get</strong>() <em>//获取当前的值</em></li>
<li><strong>public</strong> <strong>final</strong> <strong>int</strong> <strong>getAndSet</strong>(<strong>int</strong> newValue)<em>//获取当前的值，并设置新的值</em></li>
<li><strong>public</strong> <strong>final</strong> <strong>int</strong> <strong>getAndIncrement</strong>()<em>//获取当前的值，并自增</em></li>
<li><strong>public</strong> <strong>final</strong> <strong>int</strong> <strong>getAndDecrement</strong>() <em>//获取当前的值，并自减</em></li>
<li><strong>public</strong> <strong>final</strong> <strong>int</strong> <strong>getAndAdd</strong>(<strong>int</strong> delta) <em>//获取当前的值，并加上预期的值</em></li>
<li><strong>boolean</strong> <strong>compareAndSet</strong>(<strong>int</strong> expect, <strong>int</strong> update) <em>//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</em></li>
<li><strong>public</strong> <strong>final</strong> <strong>void</strong> <strong>lazySet</strong>(<strong>int</strong> newValue)<em>//最终设置为 newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</em></li>
</ul>
<p><strong>AtomicInteger 类的使用示例</strong></p>
<p>使用 AtomicInteger 之后，不用对 increment() 方法加锁也可以保证线程安全。</p>
<ul>
<li><strong>class</strong> <strong>AtomicIntegerTest</strong> {</li>
<li>​        <strong>private</strong> AtomicInteger count = <strong>new</strong> AtomicInteger();</li>
<li>​      <em>//使用 AtomicInteger 之后，不需要对该方法加锁，也可以实现线程安全。</em></li>
<li>​        <strong>public</strong> <strong>void</strong> <strong>increment</strong>() {</li>
<li>​                  count.incrementAndGet();</li>
<li>​        }</li>
<li></li>
<li>​       <strong>public</strong> <strong>int</strong> <strong>getCount</strong>() {</li>
<li>​                <strong>return</strong> count.get();</li>
<li>​        }</li>
</ul>
<p>2.4. 能不能给我简单介绍一下 AtomicInteger 类的原理</p>
<p>AtomicInteger 线程安全原理简单分析</p>
<p>AtomicInteger 类的部分源码：</p>
<ul>
<li>​    <em>// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）</em></li>
<li>​    <strong>private</strong> <strong>static</strong> <strong>final</strong> Unsafe unsafe = Unsafe.getUnsafe();</li>
<li>​    <strong>private</strong> <strong>static</strong> <strong>final</strong> <strong>long</strong> valueOffset;</li>
<li></li>
<li>​    <strong>static</strong> {</li>
<li>​        <strong>try</strong> {</li>
<li>​            valueOffset = unsafe.objectFieldOffset</li>
<li>​                (AtomicInteger.class.getDeclaredField(“value”));</li>
<li>​        } <strong>catch</strong> (Exception ex) { <strong>throw</strong> <strong>new</strong> Error(ex); }</li>
<li>​    }</li>
<li></li>
<li>​    <strong>private</strong> <strong>volatile</strong> <strong>int</strong> value;</li>
</ul>
<p>AtomicInteger 类主要利用 <strong>CAS (compare and swap) + volatile 和 native 方法来保证原子操</strong>作，从而避免 synchronized 的高开销，执行效率大为提升。</p>
<p>CAS 的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个 volatile 变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p>
<ol start="3">
<li><h3 id="AQS-1"><a href="#AQS-1" class="headerlink" title="AQS"></a>AQS</h3></li>
</ol>
<p>3.1. AQS 介绍</p>
<p>AQS 的全称为（AbstractQueuedSynchronizer），这个类在 java.util.concurrent.locks 包下面。</p>
<p><img src="E:%5CShellExt%5Cerer961115@163.com%5C5fe53d79aaa14509a9ec108e7271d106%5Cc5d80325e1d1.png" alt="img"></p>
<p>AQS</p>
<p>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。</p>
<p>3.2.1. AQS 原理概览</p>
<p><strong>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p>
<p>CLH(Craig,Landin,and Hagersten) 队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p>
<p>看个 AQS(AbstractQueuedSynchronizer) 原理图：</p>
<p><img src="E:%5CShellExt%5Cerer961115@163.com%5C2e207fbd972c4b4f87234880e3b4dfd7%5Cf7be5ccce6c1.png" alt="img"></p>
<p>AQS原理图</p>
<p>AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。</p>
<ul>
<li><strong>private</strong> <strong>volatile</strong> <strong>int</strong> state;<em>//共享变量，使用 volatile 修饰保证线程可见性</em></li>
</ul>
<p>状态信息通过 protected 类型的 getState，setState，compareAndSetState 进行操作</p>
<ul>
<li><em>//返回同步状态的当前值</em></li>
<li><strong>protected</strong> <strong>final</strong> <strong>int</strong> <strong>getState</strong>() {  </li>
<li>​        <strong>return</strong> state;</li>
<li>}</li>
<li><em>// 设置同步状态的值</em></li>
<li><strong>protected</strong> <strong>final</strong> <strong>void</strong> <strong>setState</strong>(<strong>int</strong> newState) { </li>
<li>​        state = newState;</li>
<li>}</li>
<li><em>//原子地（CAS 操作）将同步状态值设置为给定值 update 如果当前同步状态的值等于 expect（期望值）</em></li>
<li><strong>protected</strong> <strong>final</strong> <strong>boolean</strong> <strong>compareAndSetState</strong>(<strong>int</strong> expect, <strong>int</strong> update) {</li>
<li>​        <strong>return</strong> unsafe.compareAndSwapInt(<strong>this</strong>, stateOffset, expect, update);</li>
<li>}</li>
</ul>
<p>3.2.2. AQS 对资源的共享方式</p>
<p><strong>AQS 定义两种资源共享方式</strong></p>
<ul>
<li><p><strong>Exclusive</strong>（独占）：只有一个线程能执行，如 ReentrantLock。又可分为公平锁和非公平锁：</p>
</li>
<li><ul>
<li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li>
<li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li>
</ul>
</li>
<li><p><strong>Share</strong>（共享）：多个线程可同时执行，如 Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</p>
</li>
</ul>
<p>ReentrantReadWriteLock 可以看成是组合式，因为 ReentrantReadWriteLock 也就是读写锁允许多个线程同时对某一资源进行读。</p>
<p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在顶层实现好了。</p>
<p>3.2.3. AQS 底层使用了模板方法模式</p>
<p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p>
<ol>
<li>使用者继承 AbstractQueuedSynchronizer 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放）</li>
<li>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li>
</ol>
<p>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。</p>
<p><strong>AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的模板方法：</strong></p>
<ul>
<li>isHeldExclusively()<em>//该线程是否正在独占资源。只有用到 condition 才需要去实现它。</em></li>
<li>tryAcquire(<strong>int</strong>)<em>//独占方式。尝试获取资源，成功则返回 true，失败则返回 false。</em></li>
<li>tryRelease(<strong>int</strong>)<em>//独占方式。尝试释放资源，成功则返回 true，失败则返回 false。</em></li>
<li>tryAcquireShared(<strong>int</strong>)<em>//共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</em></li>
<li>tryReleaseShared(<strong>int</strong>)<em>//共享方式。尝试释放资源，成功则返回 true，失败则返回 false。</em></li>
</ul>
<p>默认情况下，每个方法都抛出 UnsupportedOperationException。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS 类中的其他方法都是 final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。</p>
<p>以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程 lock() 时，会调用 tryAcquire() 独占该锁并将 state+1。此后，其他线程再 tryAcquire() 时就会失败，直到 A 线程 unlock() 到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。</p>
<p>再以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown() 一次，state 会 CAS(Compare and Swap) 减 1。等到所有子线程都执行完后 (即 state=0)，会 unpark() 主调用线程，然后主调用线程就会从 await() 函数返回，继续后余动作。</p>
<p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。     </p>
<p>3.3. AQS 组件总结</p>
<ul>
<li><strong>Semaphore(信号量)-允许多个线程同时访问：</strong> synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量) 可以指定多个线程同时访问某个资源。</li>
<li><strong>CountDownLatch （倒计时器）：</strong> CountDownLatch 是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</li>
<li><strong>CyclicBarrier(循环栅栏)：</strong> CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier 默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用 await() 方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</li>
</ul>
]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>基础</tag>
      </tags>
  </entry>
  <entry>
    <title>Java 并发基础知识 （上）</title>
    <url>/2020/05/19/Java%20%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%8A%EF%BC%89/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="Java-并发基础知识"><a href="#Java-并发基础知识" class="headerlink" title="Java 并发基础知识"></a>Java 并发基础知识</h2><h3 id="什么是线程和进程"><a href="#什么是线程和进程" class="headerlink" title="什么是线程和进程?"></a>什么是线程和进程?</h3><h3 id="何为进程"><a href="#何为进程" class="headerlink" title="何为进程?"></a>何为进程?</h3><h3 id="何为线程"><a href="#何为线程" class="headerlink" title="何为线程?"></a>何为线程?</h3><h3 id="请简要描述线程与进程的关系-区别及优缺点？"><a href="#请简要描述线程与进程的关系-区别及优缺点？" class="headerlink" title="请简要描述线程与进程的关系,区别及优缺点？"></a>请简要描述线程与进程的关系,区别及优缺点？</h3><h3 id="图解进程和线程的关系"><a href="#图解进程和线程的关系" class="headerlink" title="图解进程和线程的关系"></a>图解进程和线程的关系</h3><h3 id="程序计数器为什么是私有的"><a href="#程序计数器为什么是私有的" class="headerlink" title="程序计数器为什么是私有的?"></a>程序计数器为什么是私有的?</h3><h3 id="虚拟机栈和本地方法栈为什么是私有的"><a href="#虚拟机栈和本地方法栈为什么是私有的" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的?"></a>虚拟机栈和本地方法栈为什么是私有的?</h3><h3 id="一句话简单了解堆和方法区"><a href="#一句话简单了解堆和方法区" class="headerlink" title="一句话简单了解堆和方法区"></a>一句话简单了解堆和方法区</h3><h3 id="说说并发与并行的区别"><a href="#说说并发与并行的区别" class="headerlink" title="说说并发与并行的区别?"></a>说说并发与并行的区别?</h3><h3 id="为什么要使用多线程呢"><a href="#为什么要使用多线程呢" class="headerlink" title="为什么要使用多线程呢?"></a>为什么要使用多线程呢?</h3><h3 id="使用多线程可能带来什么问题"><a href="#使用多线程可能带来什么问题" class="headerlink" title="使用多线程可能带来什么问题?"></a>使用多线程可能带来什么问题?</h3><h3 id="说说线程的生命周期和状态"><a href="#说说线程的生命周期和状态" class="headerlink" title="说说线程的生命周期和状态?"></a>说说线程的生命周期和状态?</h3><h3 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换?"></a>什么是上下文切换?</h3><h3 id="什么是线程死锁-如何避免死锁"><a href="#什么是线程死锁-如何避免死锁" class="headerlink" title="什么是线程死锁?如何避免死锁?"></a>什么是线程死锁?如何避免死锁?</h3><h3 id="认识线程死锁"><a href="#认识线程死锁" class="headerlink" title="认识线程死锁"></a>认识线程死锁</h3><h3 id="如何避免线程死锁"><a href="#如何避免线程死锁" class="headerlink" title="如何避免线程死锁?"></a>如何避免线程死锁?</h3><h3 id="说说sleep-方法和wait-方法区别和共同点"><a href="#说说sleep-方法和wait-方法区别和共同点" class="headerlink" title="说说sleep()方法和wait()方法区别和共同点?"></a>说说sleep()方法和wait()方法区别和共同点?</h3><h3 id="为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？"><a href="#为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？" class="headerlink" title="为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？"></a>为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？</h3><a id="more"></a>



<h1 id="什么是线程和进程-1"><a href="#什么是线程和进程-1" class="headerlink" title="什么是线程和进程?"></a>什么是线程和进程?</h1><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><ul>
<li><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p>
</li>
<li><p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p>
</li>
</ul>
<h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><ul>
<li>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</li>
</ul>
<h6 id="Java-程序天生就是多线程程序，我们可以通过-JMX-来看一下一个普通的-Java-程序有哪些线程，代码如下。"><a href="#Java-程序天生就是多线程程序，我们可以通过-JMX-来看一下一个普通的-Java-程序有哪些线程，代码如下。" class="headerlink" title="Java 程序天生就是多线程程序，我们可以通过 JMX 来看一下一个普通的 Java 程序有哪些线程，代码如下。"></a>Java 程序天生就是多线程程序，我们可以通过 JMX 来看一下一个普通的 Java 程序有哪些线程，代码如下。</h6><ul>
<li><strong>public</strong> <strong>class</strong> <strong>MultiThread</strong> {</li>
<li>​    <strong>public</strong> <strong>static</strong> <strong>void</strong> <strong>main</strong>(String[] args) {</li>
<li>​        <em>// 获取 Java 线程管理 MXBean</em></li>
<li>​    ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();</li>
<li>​        <em>// 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息</em></li>
<li>​        ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(<strong>false</strong>, <strong>false</strong>);</li>
<li>​        <em>// 遍历线程信息，仅打印线程 ID 和线程名称信息</em></li>
<li>​        <strong>for</strong> (ThreadInfo threadInfo : threadInfos) {</li>
<li>​            System.out.println(“[“ + threadInfo.getThreadId() + “] “ + threadInfo.getThreadName());</li>
<li>​        }</li>
<li>​    }</li>
<li>}</li>
</ul>
<ul>
<li>[<strong>5</strong>] Attach Listener <em>//添加事件</em></li>
<li>[<strong>4</strong>] Signal Dispatcher <em>// 分发处理给 JVM 信号的线程</em></li>
<li>[<strong>3</strong>] Finalizer <em>//调用对象 finalize 方法的线程</em></li>
<li>[<strong>2</strong>] Reference Handler <em>//清除 reference 线程</em></li>
<li>[<strong>1</strong>] main <em>//main 线程,程序入口</em></li>
</ul>
<p>从上面的输出内容可以看出：<strong>一个 Java 程序的运行是 main 线程和多个其他线程同时运行</strong>。</p>
<h1 id="简单说一下线程与进程的关系-区别及优缺点？"><a href="#简单说一下线程与进程的关系-区别及优缺点？" class="headerlink" title="简单说一下线程与进程的关系,区别及优缺点？"></a>简单说一下线程与进程的关系,区别及优缺点？</h1><p><strong>从 JVM 角度说进程和线程之间的关系</strong></p>
<p>图解进程和线程的关系</p>
<p>下图是 Java 内存区域，通过下图我们从 JVM 的角度来说一下线程和进程之间的关系。如果你对 Java 内存区域 (运行时数据区) 这部分知识不太了解的话可以阅读一下这篇文章：<a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java内存区域" target="_blank" rel="noopener">《可能是把 Java 内存区域讲的最清楚的一篇文章》</a></p>
<p><img src="E:%5CShellExt%5Cerer961115@163.com%5Cbde32dcf987842b6936354f532916aa7%5Cc84dcedf503a.png" alt="img"></p>
<p>从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)</strong>资源，但是每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong> 和 <strong>本地方法栈</strong>。</p>
<p><strong>总结：</strong> <strong>线程 是 进程</strong> 划分成的<strong>更小的运行单位</strong>。线程和进程最大的<strong>不同在于基本上各进程是独立的</strong>，而各<strong>线程则不一定</strong>，因为<strong>同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反</strong></p>
<p>下面是该知识点的扩展内容！</p>
<p>下面来思考这样一个问题：为什么<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>是线程私有的呢？为什么堆和方法区是线程共享的呢？</p>
<h6 id="程序计数器为什么是私有的-1"><a href="#程序计数器为什么是私有的-1" class="headerlink" title="程序计数器为什么是私有的?"></a>程序计数器为什么是私有的?</h6><p><strong>程序计数器主要有下面两个作用：</strong></p>
<ol>
<li><strong>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理</strong>。</li>
<li><strong>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</strong></li>
</ol>
<p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p>
<p>所以，<strong>程序计数器私有主要是</strong>为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p>
<h5 id="虚拟机栈和本地方法栈为什么是私有的-1"><a href="#虚拟机栈和本地方法栈为什么是私有的-1" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的?"></a>虚拟机栈和本地方法栈为什么是私有的?</h5><ul>
<li><strong>虚拟机栈：</strong>每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li>
<li><strong>本地方法栈：</strong>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li>
</ul>
<p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p>
<h5 id="一句话简单了解堆和方法区-1"><a href="#一句话简单了解堆和方法区-1" class="headerlink" title="一句话简单了解堆和方法区"></a>一句话简单了解堆和方法区</h5><p><strong>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</strong></p>
<p>说说并发与并行的区别?</p>
<ul>
<li><strong>并发：</strong> 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)；</li>
<li><strong>并行：</strong>单位时间内，多个任务同时执行。</li>
</ul>
<p>为什么要使用多线程呢?</p>
<p>先从总体上来说：</p>
<ul>
<li><strong>从计算机底层来说：</strong>线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li>
<li><strong>从当代互联网发展趋势来说：</strong>现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li>
</ul>
<p>再深入到计算机底层来探讨：</p>
<ul>
<li><strong>单核时代：</strong> 在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100%了。</li>
<li><strong>多核时代:</strong> 多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。</li>
</ul>
<h5 id="使用多线程可能带来什么问题-1"><a href="#使用多线程可能带来什么问题-1" class="headerlink" title="使用多线程可能带来什么问题?"></a>使用多线程可能带来什么问题?</h5><p>并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、上下文切换、死锁还有受限于硬件和软件的资源闲置问题。</p>
<p>说说线程的生命周期和状态?</p>
<p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4 节）。</p>
<p><img src="E:%5CShellExt%5Cerer961115@163.com%5Cabe4fc03b3d9430880c2d6b23036ac14%5C23a7ed9a59df.png" alt="img"></p>
<p>Java 线程的状态</p>
<p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）：</p>
<p><img src="E:%5CShellExt%5Cerer961115@163.com%5Cc096732d8bc641e38fe10bb3f46fe6f0%5C27b9455a3777.png" alt="img"></p>
<p>Java 线程状态变迁</p>
<p>由上图可以看出：线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 start() 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p>
<p>操作系统隐藏 Java 虚拟机（JVM）中的 RUNNABLE 和 RUNNING 状态，它只能看到 RUNNABLE 状态（图源：<a href="https://howtodoinjava.com/" target="_blank" rel="noopener">HowToDoInJava</a>：<a href="https://howtodoinjava.com/java/multi-threading/java-thread-life-cycle-and-thread-states/" target="_blank" rel="noopener">Java Thread Life Cycle and Thread States</a>），所以 Java 系统一般将这两个状态统称为 <strong>RUNNABLE（运行中）</strong> 状态 。</p>
<p><img src="E:%5CShellExt%5Cerer961115@163.com%5C5b77df2b2a85430b821d528c246c5f7b%5C7c2a945b7661.png" alt="img"></p>
<p>RUNNABLE-VS-RUNNING</p>
<p>当线程执行 wait()方法之后，线程进入 <strong>WAITING（等待）</strong>状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIME_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 sleep（long millis）方法或 wait（long millis）方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行 Runnable 的run()方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p>
<p>什么是上下文切换?</p>
<p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。</p>
<p>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换会这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p>
<p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p>
<p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p>
<p>什么是线程死锁?如何避免死锁?</p>
<p>认识线程死锁</p>
<p>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p>
<p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p>
<p><img src="E:%5CShellExt%5Cerer961115@163.com%5Cc213dd5ca1dd41e8a23fba3cad69c506%5Ca389c1b661cc.png" alt="img"></p>
<p>线程死锁示意图</p>
<p>下面通过一个例子来说明线程死锁,代码模拟了上图的死锁的情况 (代码来源于《并发编程之美》)：</p>
<ul>
<li><strong>public</strong> <strong>class</strong> <strong>DeadLockDemo</strong> {</li>
<li>​    <strong>private</strong> <strong>static</strong> Object resource1 = <strong>new</strong> Object();<em>//资源 1</em></li>
<li>​    <strong>private</strong> <strong>static</strong> Object resource2 = <strong>new</strong> Object();<em>//资源 2</em></li>
<li></li>
<li>​    <strong>public</strong> <strong>static</strong> <strong>void</strong> <strong>main</strong>(String[] args) {</li>
<li>​        <strong>new</strong> Thread(() -&gt; {</li>
<li>​            <strong>synchronized</strong> (resource1) {</li>
<li>​                System.out.println(Thread.currentThread() + “get resource1”);</li>
<li>​                <strong>try</strong> {</li>
<li>​                    Thread.sleep(1000);</li>
<li>​                } <strong>catch</strong> (InterruptedException e) {</li>
<li>​                    e.printStackTrace();</li>
<li>​                }</li>
<li>​                System.out.println(Thread.currentThread() + “waiting get resource2”);</li>
<li>​                <strong>synchronized</strong> (resource2) {</li>
<li>​                    System.out.println(Thread.currentThread() + “get resource2”);</li>
<li>​                }</li>
<li>​            }</li>
<li>​        }, “线程 1”).start();</li>
<li></li>
<li>​        <strong>new</strong> Thread(() -&gt; {</li>
<li>​            <strong>synchronized</strong> (resource2) {</li>
<li>​                System.out.println(Thread.currentThread() + “get resource2”);</li>
<li>​                <strong>try</strong> {</li>
<li>​                    Thread.sleep(1000);</li>
<li>​                } <strong>catch</strong> (InterruptedException e) {</li>
<li>​                    e.printStackTrace();</li>
<li>​                }</li>
<li>​                System.out.println(Thread.currentThread() + “waiting get resource1”);</li>
<li>​                <strong>synchronized</strong> (resource1) {</li>
<li>​                    System.out.println(Thread.currentThread() + “get resource1”);</li>
<li>​                }</li>
<li>​            }</li>
<li>​        }, “线程 2”).start();</li>
<li>​    }</li>
<li>}</li>
</ul>
<p>Output</p>
<ul>
<li><strong>Thread</strong>[线程 1,5,main]<strong>get</strong> resource1</li>
<li><strong>Thread</strong>[线程 2,5,main]<strong>get</strong> resource2</li>
<li><strong>Thread</strong>[线程 1,5,main]waiting <strong>get</strong> resource2</li>
<li><strong>Thread</strong>[线程 2,5,main]waiting <strong>get</strong> resource1</li>
</ul>
<p>线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过Thread.sleep(1000);让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。上面的例子符合产生死锁的四个必要条件。</p>
<p>产生死锁必须具备以下四个条件：</p>
<ol>
<li><strong>互斥条件</strong>：该资源任意一个时刻只由一个线程占用。</li>
<li><strong>请求与保持条件</strong>：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li><strong>不剥夺条件</strong>:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li>
<li><strong>循环等待条件</strong>:若干线程之间形成一种头尾相接的循环等待资源关系。</li>
</ol>
<p>如何避免线程死锁?</p>
<p>我们只要破坏产生死锁的四个条件中的其中一个就可以了。</p>
<p><strong>破坏互斥条件</strong></p>
<p>这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</p>
<p><strong>破坏请求与保持条件</strong></p>
<p>一次性申请所有的资源。</p>
<p><strong>破坏不剥夺条件</strong></p>
<p>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p>
<p><strong>破坏循环等待条件</strong></p>
<p>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p>
<p>我们对线程 2 的代码修改成下面这样就不会产生死锁了。</p>
<ul>
<li>​        <strong>new</strong> Thread(() -&gt; {</li>
<li>​            <strong>synchronized</strong> (resource1) {</li>
<li>​                System.out.println(Thread.currentThread() + “get resource1”);</li>
<li>​                <strong>try</strong> {</li>
<li>​                    Thread.sleep(1000);</li>
<li>​                } <strong>catch</strong> (InterruptedException e) {</li>
<li>​                    e.printStackTrace();</li>
<li>​                }</li>
<li>​                System.out.println(Thread.currentThread() + “waiting get resource2”);</li>
<li>​                <strong>synchronized</strong> (resource2) {</li>
<li>​                    System.out.println(Thread.currentThread() + “get resource2”);</li>
<li>​                }</li>
<li>​            }</li>
<li>​        }, “线程 2”).start();</li>
</ul>
<p>Output</p>
<ul>
<li><strong>Thread</strong>[线程 1,5,main]<strong>get</strong> resource1</li>
<li><strong>Thread</strong>[线程 1,5,main]waiting <strong>get</strong> resource2</li>
<li><strong>Thread</strong>[线程 1,5,main]<strong>get</strong> resource2</li>
<li><strong>Thread</strong>[线程 2,5,main]<strong>get</strong> resource1</li>
<li><strong>Thread</strong>[线程 2,5,main]waiting <strong>get</strong> resource2</li>
<li><strong>Thread</strong>[线程 2,5,main]<strong>get</strong> resource2</li>
<li></li>
<li><strong>Process</strong> finished with exit code 0</li>
</ul>
<p>我们分析一下上面的代码为什么避免了死锁的发生?</p>
<p>线程 1 首先获得到 resource1 的监视器锁,这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。</p>
<p><strong>说说sleep()方法和wait()方法区别和共同点?</strong></p>
<ul>
<li>两者最主要的区别在于：<strong>sleep方法没有释放锁，而wait方法释放了锁</strong> 。</li>
<li>两者都可以暂停线程的执行。</li>
<li>Wait通常被用于线程间交互/通信，sleep通常被用于暂停执行。</li>
<li>wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。</li>
</ul>
<p>为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？</p>
<p>这是另一个非常经典的java多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！</p>
<p>new一个Thread，线程进入了新建状态;调用start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start()会执行线程的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程工作。 而直接执行run()方法，会把run方法当成一个main线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p>
<p><strong>总结： 调用start方法方可启动线程并使线程进入就绪状态，而run方法只是thread的一个普通方法调用，还是在主线程里执行。</strong></p>
]]></content>
      <categories>
        <category>Java 基础</category>
      </categories>
      <tags>
        <tag>并发</tag>
        <tag>基础</tag>
      </tags>
  </entry>
</search>
