<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>hexo+github搭建免费博客</title>
    <url>/2020/05/19/diyici/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用github pages服务搭建博客的好处有：</p>
<ul>
<li><p>全是静态文件，访问速度快；</p>
</li>
<li><p>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</p>
</li>
<li><p>可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</p>
</li>
<li><p>数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</p>
</li>
<li><p>博客内容可以轻松打包、转移、发布到其它平台；</p>
</li>
<li><p>等等；</p>
</li>
</ul>
<a id="more"></a>

<h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul>
<li>有一个github账号，没有的话去注册一个；</li>
<li>安装了node.js、npm，并了解相关基础知识；</li>
<li>安装了git for windows（或者其它git客户端）</li>
</ul>
<h1 id="搭建github博客"><a href="#搭建github博客" class="headerlink" title="搭建github博客"></a>搭建github博客</h1><ul>
<li><p>创建仓库<br>新建一个名为  你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效）</p>
</li>
<li><p>配置SSH key</p>
<p>  $ cd ~/. ssh #检查本机已存在的ssh密钥</p>
<p>  $ ssh-keygen -t rsa -C “邮件地址”</p>
</li>
<li><p>然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\id_rsa.pub文件</p>
<pre><code>复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：</code></pre></li>
</ul>
<h1 id="配置："><a href="#配置：" class="headerlink" title="配置："></a>配置：</h1><ul>
<li>$ git config –global user.name “liuxianan”// 你的github用户名，非昵称</li>
<li>$ git config –global user.email  “<a href="mailto:xxx@qq.com">xxx@qq.com</a>“// 填写你的github注册邮箱</li>
</ul>
<h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><ul>
<li><p>$ npm install -g hexo</p>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>在电脑的某个地方新建一个名为hexo的文件夹由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放注意一定要是空文件夹。</p>
</li>
<li><p>$ cd /f/Workspaces/hexo/</p>
</li>
<li><p>$ hexo init</p>
</li>
</ul>
<h1 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h1><ul>
<li>$ hexo g # 生成</li>
<li>$ hexo s # 启动服务</li>
</ul>
<h1 id="主题替换"><a href="#主题替换" class="headerlink" title="主题替换"></a>主题替换</h1><ul>
<li>git clone <a href="https://github.com/litten/hexo-theme-yilia.git" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia.git</a> themes/yilia</li>
</ul>
<h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><p>*修改_config.yml中的theme: landscape改为theme: yilia，然后重新执行hexo g来重新生成。</p>
<p>如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布</p>
<ul>
<li>deploy:<ul>
<li>type: git</li>
<li>repository: <a href="mailto:git@github.com">git@github.com</a>:liuxianan/liuxianan.github.io.git</li>
<li>branch: master</li>
</ul>
</li>
</ul>
<p>执行npm install hexo-deployer-git –save</p>
<h1 id="常用hexo命令"><a href="#常用hexo命令" class="headerlink" title="常用hexo命令"></a>常用hexo命令</h1><p>hexo new “postName” #新建文章</p>
<p>hexo new page “pageName” #新建页面</p>
<p>hexo generate #生成静态页面至public目录</p>
<p>hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）</p>
<p>hexo deploy #部署到GitHub</p>
<p>hexo help  # 查看帮助</p>
<p>hexo version  #查看Hexo的版本</p>
<p>hexo s -g #生成并本地预览</p>
<p>hexo d -g #生成并上传</p>
<h1 id="写博客工具"><a href="#写博客工具" class="headerlink" title="写博客工具"></a>写博客工具</h1><p>推荐 Visual Studio Code</p>
<h1 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h1><p>liushijiexy.github.io</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://blog.haoji.me/build-blog-website-by-hexo-github.html?from=xa" target="_blank" rel="noopener">http://blog.haoji.me/build-blog-website-by-hexo-github.html?from=xa</a></p>
]]></content>
      <categories>
        <category>默认分类</category>
      </categories>
      <tags>
        <tag>博客</tag>
      </tags>
  </entry>
  <entry>
    <title>git基本</title>
    <url>/2020/05/19/git/</url>
    <content><![CDATA[<h1 id="前言-git"><a href="#前言-git" class="headerlink" title="前言 git"></a>前言 git</h1><ul>
<li><p>认识 Git</p>
</li>
<li><p>Git 与其他版本管理系统的主要区别</p>
</li>
<li><p>Git 的三种状态</p>
</li>
<li><p>基本的 Git 工作流程</p>
</li>
<li><p>基本命令</p>
<a id="more"></a>

</li>
</ul>
<h2 id="认识-Git"><a href="#认识-Git" class="headerlink" title="认识 Git"></a>认识 Git</h2><p>​        Linux 内核项目组当时使用分布式版本控制系统 BitKeeper 来管理和维护代码。但是，后来开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统，而且对新的版本控制系统做了很多改进。</p>
<h3 id="Git-与其他版本管理系统的主要区别"><a href="#Git-与其他版本管理系统的主要区别" class="headerlink" title="Git 与其他版本管理系统的主要区别"></a>Git 与其他版本管理系统的主要区别</h3><p>主要差别：<strong>对待数据的方式</strong>。</p>
<p><strong>Git采用的是直接记录快照的方式，而非差异比较。我后面会详细介绍这两种方式的差别。</strong></p>
<p>大部分版本控制系统（CVS、Subversion、Perforce、Bazaar 等等）都是以文件变更列表的方式存储信息，这类系统<strong>将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。</strong></p>
<p><img src="C:%5CUsers%5Cx%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200519074004392.png" alt="image-20200519074004392"></p>
<p><strong>我们怎样才能得到一个文件的最终版本呢？</strong></p>
<p>很简单，高中数学的基本知识，我们只需要将这些原文件和这些增加进行相加就行了。</p>
<p><strong>这种方式有什么问题呢？</strong></p>
<p>比如我们的增量特别特别多的话，如果我们要得到最终的文件是不是会耗费时间和性能。</p>
<p>Git 不按照以上方式对待或保存数据。 反之，Git 更像是把数据看作是对小型文件系统的一组快照。 每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 <strong>快照流</strong>。下图来源于Git官网。</p>
<p><img src="C:%5CUsers%5Cx%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200519074105838.png" alt="image-20200519074105838"></p>
<h3 id="Git-的三种状态"><a href="#Git-的三种状态" class="headerlink" title="Git 的三种状态"></a>Git 的三种状态</h3><p>Git 有三种状态，你的文件可能处于其中之一：</p>
<p>•<strong>已提交（committed）</strong>：数据已经安全的保存在本地数据库中。•<strong>已修改（modified）</strong>：已修改表示修改了文件，但还没保存到数据库中。•<strong>已暂存（staged）</strong>：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</p>
<p>由此引入 Git 项目的三个工作区域的概念：<strong>Git 仓库(.git directoty) 、**</strong>工作目录(Working Directory)** 以及 <strong>暂存区域(Staging Area)</strong> 。</p>
<p><img src="C:%5CUsers%5Cx%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200519074139658.png" alt="image-20200519074139658"></p>
<p><strong>基本的 Git 工作流程如下：</strong></p>
<p>•在工作目录中修改文件。•暂存文件，将文件的快照放入暂存区域。•提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。</p>
<h3 id="获取-Git-仓库"><a href="#获取-Git-仓库" class="headerlink" title="获取 Git 仓库"></a>获取 Git 仓库</h3><p>有两种取得 Git 项目仓库的方法。</p>
<p>•在现有目录中初始化仓库: 进入项目目录运行 <code>git init</code> 命令,该命令将创建一个名为 <code>.git</code> 的子目录。•从一个服务器克隆一个现有的 Git 仓库: <code>git clone [url]</code> 自定义本地仓库的名字: <code>git clone [url]</code> directoryname</p>
<h3 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h3><p>•<strong>检测当前文件状态</strong> : <code>git status</code>•<strong>提出更改（把它们添加到暂存区</strong>）：<code>git add filename</code> (针对特定文件)、<code>git add *</code>(所有文件)、<code>git add *.txt</code>（支持通配符，所有 .txt 文件）•<strong>忽略文件</strong>：<code>.gitignore</code> 文件•<strong>提交更新:</strong> <code>git commit -m &quot;代码提交信息&quot;</code> （每次准备提交前，先用 <code>git status</code> 看下，是不是都已暂存起来了， 然后再运行提交命令 <code>git commit</code>）•<strong>跳过使用暂存区域更新的方式</strong> : <code>git commit -a -m &quot;代码提交信息&quot;</code>。 <code>git commit</code> 加上 <code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤。•<strong>移除文件</strong> ：<code>git rm filename</code> （从暂存区域移除，然后提交。）•<strong>对文件重命名</strong> ：<code>git mv README.md README</code>(这个命令相当于<code>mv README.md README</code>、<code>git rm README.md</code>、<code>git add README</code> 这三条命令的集合)</p>
<h3 id="推送改动到远程仓库"><a href="#推送改动到远程仓库" class="headerlink" title="推送改动到远程仓库"></a>推送改动到远程仓库</h3><ul>
<li>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：·<code>git remote add origin</code> ,比如我们要让本地的一个仓库和 Github 上创建的一个仓库关联可以这样<code>git remote add origin https://github.com/Snailclimb/test.git</code>将</li>
<li>将这些改动提交到远端仓库：<code>git push origin master</code> (可以把 <strong>master</strong> 换成你想要推送的任何分支)</li>
</ul>
<h3 id="远程仓库的移除与重命名"><a href="#远程仓库的移除与重命名" class="headerlink" title="远程仓库的移除与重命名"></a>远程仓库的移除与重命名</h3><p>•将 test 重命名位 test1：<code>git remote rename test test1</code>•移除远程仓库 test1:<code>git remote rm test1</code></p>
<h3 id="远程仓库的移除与重命名-1"><a href="#远程仓库的移除与重命名-1" class="headerlink" title="远程仓库的移除与重命名"></a>远程仓库的移除与重命名</h3><p>•将 test 重命名位 test1：<code>git remote rename test test1</code>•移除远程仓库 test1:<code>git remote rm test1</code></p>
<p><strong>可以添加一些参数来查看自己希望看到的内容：</strong></p>
<ul>
<li>只看某个人的提交记录：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git log --author&#x3D;xxx可以添加一些参数来查看自己希望看到的内容：</span><br></pre></td></tr></table></figure>

<h3 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h3><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 <code>--amend</code> 选项的提交命令尝试重新提交：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>

<p>取消暂存的文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset filename</span><br></pre></td></tr></table></figure>

<p>撤消对文件的修改:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -- filename</span><br></pre></td></tr></table></figure>

<p>假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git fetch origingit reset --hard origin&#x2F;master</span><br></pre></td></tr></table></figure>

<h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，<strong>master</strong> 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。</p>
<p>我们通常在开发新功能、修复一个紧急 bug 等等时候会选择创建分支。单分支开发好还是多分支开发好，还是要看具体场景来说。</p>
<p>创建一个名字叫做 test 的分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch test</span><br></pre></td></tr></table></figure>

<p>切换当前分支到 test（当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout test</span><br></pre></td></tr></table></figure>

<p>你也可以直接这样创建分支并切换过去(上面两条命令的合写)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -b feature_x</span><br></pre></td></tr></table></figure>

<p>切换到主分支</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure>

<p>合并分支(可能会有冲突)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git merge test</span><br></pre></td></tr></table></figure>

<p>把新建的分支删掉</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git branch -d feature_x</span><br></pre></td></tr></table></figure>

<p>将分支推送到远端仓库（推送成功后其他人可见）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>基本命令</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>java基础常识</title>
    <url>/2020/05/19/JavaBash/</url>
    <content><![CDATA[<h1 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h1><ul>
<li><p>Java 简介</p>
</li>
<li><p>JDK  和  JRE JVM 三者的关系区别 ！；</p>
</li>
<li><p>免费方务；</p>
</li>
<li><p>可以随</p>
</li>
<li><p>数据绝</p>
</li>
</ul>
<a id="more"></a>



<h1 id="Java-简介"><a href="#Java-简介" class="headerlink" title="Java 简介"></a>Java 简介</h1><h1 id="JDK-和-JRE-JVM-三者的关系区别-！"><a href="#JDK-和-JRE-JVM-三者的关系区别-！" class="headerlink" title="JDK  和  JRE JVM 三者的关系区别 ！"></a>JDK  和  JRE JVM 三者的关系区别 ！</h1><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><pre><code>Java虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</code></pre><h2 id="JDK-和-JRE"><a href="#JDK-和-JRE" class="headerlink" title="JDK 和 JRE"></a>JDK 和 JRE</h2><pre><code>JDK是Java Development Kit，它是功能齐全的Java SDK。它拥有JRE所拥有的一切，还有编译器（javac）和工具（如javadoc和jdb）。它能够创建和编译程序。 
JRE 是 Java运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java虚拟机（JVM），Java类库，java命令和其他的一些基础构件。但是，它不能用于创建新程序。</code></pre><p>如果你只是为了<strong>运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了</strong>。如果你需要进行一些 <strong>Java 编程方面的工作，那么你就需要安装JDK了</strong>。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何Java开发，仍然需要安装JDK。例如，如果**要使用JSP部署Web应用程序，那么从技术上讲，您只是在应用程序服务器中运行Java程序。那你为什么需要JDK呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。</p>
<h1 id="Java和C-的区别"><a href="#Java和C-的区别" class="headerlink" title="Java和C++的区别?"></a>Java和C++的区别?</h1><ol>
<li>都是<strong>面向对象</strong>的语言，都支持<strong>封装、继承和多态</strong>；</li>
<li>Java 不提供指针来直接访问<strong>内存</strong>，程序内存更加安全；</li>
<li>Java 的<strong>类是单继承</strong>的，<strong>C++ 支持多重继承</strong>；虽然 Java 的类不可以多继承，但是<strong>接口可以多继承</strong>；</li>
<li><strong>Java 有自动内存管理机制</strong>，不需要程序员手动释放无用内存。</li>
</ol>
<h1 id="重载和重写的区别-构造器-Constructor-是否可被-override"><a href="#重载和重写的区别-构造器-Constructor-是否可被-override" class="headerlink" title="重载和重写的区别?构造器 Constructor 是否可被 override?"></a>重载和重写的区别?构造器 Constructor 是否可被 override?</h1><ul>
<li>重载： 发生在同一个类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同，发生在编译时。 　　</li>
<li>重写： 发生在父子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类；如果父类方法访问修饰符为 private 则子类就不能重写该方法。<br>在讲继承的时候我们就知道父类的私有属性和构造方法并不能被继承，所以 <strong>Constructor 也就不能被 override（重写）</strong>,但是<strong>可以 overload（重载）</strong>,所以你可以看到一个类中有多个构造函数的情况。</li>
</ul>
<h1 id="谈谈Java-面向对象编程三大特性-封装-继承-多态"><a href="#谈谈Java-面向对象编程三大特性-封装-继承-多态" class="headerlink" title="谈谈Java 面向对象编程三大特性: 封装 继承 多态"></a>谈谈Java 面向对象编程三大特性: 封装 继承 多态</h1><ol>
<li><h2 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h2><p> 封装把一个对象的<strong>属性私有化，同时提供一些可以被外界访问的属性的方法</strong>，如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。</p>
</li>
<li><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p> <strong>继承是使用已存在的类的定义作为基础建立新类的技术</strong>，新类的定义可以<strong>增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类</strong>。通过使用继承我们能够非常方便地<strong>复用</strong>以前的代码。</p>
</li>
<li><h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p> 所谓多态就是指<strong>程序中定义的引用变量所指向的具体类型</strong>和<strong>通过该引用变量发出的方法调用在编程时并不确定</strong>，而是在<strong>程序运行期间才确定</strong>，即<strong>一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定</strong>。<br>在Java中有<strong>两种形式</strong>可以实现多态：**继承（多个子类对同一方法的重写）和接口（实现接口并覆盖接口中同一方法）。</p>
</li>
</ol>
<p>关于继承如下 3 点请记住：<br>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的<strong>私有属性和方法子类</strong>是无法访问，<strong>只是拥有</strong>。<br>子类可以<strong>拥有自己属性和方法，即子类可以对父类进行扩展</strong>。<br>子类可以用自己的方式实现父类的方法。（以后介绍）。</p>
<h1 id="String-str-“-abcd-“-与-String-str1-new-String-“acbd”-一样吗？-str-和-str1-相等吗？"><a href="#String-str-“-abcd-“-与-String-str1-new-String-“acbd”-一样吗？-str-和-str1-相等吗？" class="headerlink" title="String  str = “ abcd “  与  String str1=new String(“acbd”) 一样吗？ str 和 str1 相等吗？"></a>String  str = “ abcd “  与  String str1=new String(“acbd”) 一样吗？ str 和 str1 相等吗？</h1><p>这两种不同的创建方法是有差别的。</p>
<ul>
<li><p>第一种方式先检查字符串<strong>常量池</strong>中有没有”abcd”，如果字符串常量池中<strong>没有，则创建一个</strong>，然后<strong>str指向</strong>字符串常量池中的对象，如<strong>果有</strong>，则<strong>直</strong>接将<strong>str指向字符串常量池</strong>中的”abcd””；</p>
</li>
<li><p>第<strong>二种方式是直接在堆内存空间创建一个新的对象</strong>。</p>
</li>
<li><p><strong>推荐使用第一种方式创建字符串</strong>。</p>
<p><strong>str和str1不相等，因为一个是堆内存中的String对象一个是常量池中的String对象</strong>。</p>
</li>
</ul>
<h1 id="String-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的"><a href="#String-StringBuffer-和-StringBuilder-的区别是什么-String-为什么是不可变的" class="headerlink" title="String StringBuffer 和 StringBuilder 的区别是什么?String 为什么是不可变的?"></a>String StringBuffer 和 StringBuilder 的区别是什么?String 为什么是不可变的?</h1><h2 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h2><ul>
<li>简单的来说：String 类中使用 <strong>final</strong> 关键字修饰字符数组来保存字符串，<code>private　final　char　value[]</code>，所以 String 对象是不可变的。而StringBuilder 与 StringBuffer 都继承自 <strong>AbstractStringBuilder 类</strong>，在 AbstractStringBuilder 中<strong>也是使用字符数组保存字符串char[]value 但是没有用 final 关键字修饰</strong>，所以这两种对象都是可变的。</li>
<li>StringBuilder 与 StringBuffer 的构造方法都是<strong>调用父类构造方法</strong>也就是 <strong>AbstractStringBuilder 实现</strong>的</li>
</ul>
<h2 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a><strong>线程安全性</strong></h2><ul>
<li><p>String 中的对象是不可变的，也就可以理解为常量，线程安全。</p>
</li>
<li><p>AbstractStringBuilder 是 StringBuilder 与 StringBuffer 的公共父类，定义了一些字符串的基本操作，如 expandCapacity、append、insert、indexOf 等公共方法。</p>
</li>
<li><p><strong>StringBuffer 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的</strong>。<strong>StringBuilder 并没有对方法进行加同步锁，所以是非线程安全的。</strong></p>
</li>
</ul>
<h2 id="性能"><a href="#性能" class="headerlink" title="性能"></a><strong>性能</strong></h2><p>每次对 <strong>String 类型</strong>进行<strong>改变</strong>的时候，都会<strong>生成一个新的 String 对象</strong>，然后将<strong>指针指向新的</strong> String 对象。<strong>StringBuffer 每次都会对 StringBuffer 对象本身进行操作，</strong>而不是生成新的对象并改变对象引用。相同情况下使用 <strong>StringBuilder</strong> 相比使用 <strong>StringBuffer</strong> 仅能获得 10%~15% 左右的<strong>性能提升</strong>，但却要冒多线程不安全的风险。</p>
<h2 id="对于三者使用的总结："><a href="#对于三者使用的总结：" class="headerlink" title="对于三者使用的总结："></a><strong>对于三者使用的总结：</strong></h2><ol>
<li>操作<strong>少量的数据</strong>: 适用<strong>String</strong></li>
<li><strong>单线程操作字符串缓冲区下操作大量数据</strong>: 适用<strong>StringBuilder</strong></li>
<li><strong>多线程操作字符串缓冲区下操作大量数据</strong>: 适用<strong>StringBuffer</strong></li>
</ol>
<h1 id="接口和抽象类的区别是什么？"><a href="#接口和抽象类的区别是什么？" class="headerlink" title="接口和抽象类的区别是什么？"></a>接口和抽象类的区别是什么？</h1><ol>
<li>接口的方法默认是 public，所有方法在接口中不能有实现(Java 8 开始接口方法可以有默认实现），而抽象类可以有非抽象的方法。</li>
<li>接口中的实例变量默认是 final 类型的，而抽象类中则不一定。</li>
<li>一个类可以实现多个接口，但最多只能实现一个抽象类。</li>
<li>一个类实现接口的话要实现接口的所有方法，而抽象类不一定。</li>
<li>接口不能用 new 实例化，但可以声明，但是必须引用一个实现该接口的对象。从设计层面来说，抽象是对类的抽象，是一种模板设计，而接口是对行为的抽象，是一种行为的规范。</li>
</ol>
<p>备注:在JDK8中，接口也可以定义静态方法，可以直接用接口名调用。实现类和实现是不可以调用的。如果同时实现两个接口，接口中定义了一样的默认方法，则必须重写，不然会报错。</p>
<h1 id="抽象类必须要有抽象方法吗？"><a href="#抽象类必须要有抽象方法吗？" class="headerlink" title="抽象类必须要有抽象方法吗？"></a><strong>抽象类必须要有抽象方法吗？</strong></h1><p>抽象类中不一定包含抽象方法，但是包含抽象方法的类一定要被声明为抽象类。</p>
<h1 id="抽象类能使用-final-修饰吗？"><a href="#抽象类能使用-final-修饰吗？" class="headerlink" title="抽象类能使用 final 修饰吗？"></a><strong>抽象类能使用 final 修饰吗？</strong></h1><p>抽象类不能用final来修饰。当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式地指定为final方法，这明显违背了抽象类存在的意义了。</p>
<h1 id="与-equals-1"><a href="#与-equals-1" class="headerlink" title="== 与 equals(1)"></a>== 与 equals(1)</h1><p><strong>==</strong> : 它的作用是<strong>判断</strong>两个对象的<strong>地址</strong>是不是相等。即，判断两<strong>个对象</strong>是不是同一<strong>个对</strong>象(<strong>基本数据类型</strong>==比较的是<strong>值</strong>，<strong>引用数据类型</strong>==比较的是<strong>内存地</strong>址)。</p>
<p><strong>equals()</strong> : 它的作用也是判断两个对象是否相等。但它一般有两种使用情况：</p>
<ul>
<li>情况1：类没有覆盖 equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。</li>
<li>情况2：类覆盖了 equals() 方法。一般，我们都覆盖 equals() 方法来两个对象的内容相等；若它们的内容相等，则返回 true (即，认为这两个对象相等)。</li>
</ul>
<hr>
<h1 id="hashCode-与-equals-重要"><a href="#hashCode-与-equals-重要" class="headerlink" title="hashCode 与 equals (重要)"></a>hashCode 与 equals (重要)</h1><p>面试官可能会问你：“你重写过 hashcode 和 equals 么，为什么重写equals时必须重写hashCode方法？”</p>
<h2 id="hashCode（）介绍"><a href="#hashCode（）介绍" class="headerlink" title="hashCode（）介绍"></a>hashCode（）介绍</h2><p><strong>hashCode() 的作用是获取哈希码</strong>，也称为散列码；<strong>它实际上是返回一个int整数</strong>。<strong>这个哈希码的作用是确定该对象在哈希表中的索引位置</strong>。<strong>hashCode() 定义在JDK的Object**</strong>.java<strong>中，这就意味着Java中的</strong>任何类<strong>都</strong>包含有hashCode() 函数**。</p>
<p>散列表存储的是键值对(key-value)，它的特点是：能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）</p>
<p>为什么要有 hashCode</p>
<p><strong>我们先以“HashSet 如何检查重复”为例子来说明为什么要有 hashCode：</strong> 当你把对象加入 HashSet 时，<strong>HashSet 会先计算对象的 hashcode 值来判断对象加入的位置</strong>，<strong>同时</strong>也会与其他<strong>已经加入</strong>的对象的 hashcode <strong>值作比较</strong>，如果<strong>没有相符</strong>的hashcode，HashSet<strong>会假设对象没有重复出现</strong>。但是如果发现<strong>有相同</strong> hashcode <strong>值</strong>的对象，这时会<strong>调用 equals（</strong>）方法来检查 hashcode 相等的对象<strong>是否真的</strong>相同。如果<strong>两者相同</strong>，<strong>HashSet</strong> 就<strong>不会让其加入</strong>操作成功。如果<strong>不同</strong>的话，就会<strong>重新散列到其他位</strong>置。（摘自我的Java启蒙书《Head first java》第二版）。这样我们就大大减少了 equals 的次数，相应就大大提高了执行速度。</p>
<p>通过我们可以看出：<strong>hashCode() 的作用就是获取哈希码，也称为散列码；它实际上是返回一个int整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。</strong>hashCode()在散列表中才有用，在其它情况下没用。在散列表中hashCode() 的作用是获取对象的散列码，进而确定该对象在散列表中的位置。</p>
<h2 id="hashCode（）与equals（）的相关规定"><a href="#hashCode（）与equals（）的相关规定" class="headerlink" title="hashCode（）与equals（）的相关规定"></a>hashCode（）与equals（）的相关规定</h2><ol>
<li>如果两个对象相等，则hashcode一定也是相同的;</li>
<li>两个对象相等,对两个对象分别调用equals方法都返回true;</li>
<li>两个对象有相同的hashcode值，它们也不一定是相等的（不同的对象也可能产生相同的hashcode，概率性问题）;</li>
<li><strong>因此，equals 方法被覆盖过，则 hashCode 方法也必须被覆盖</strong></li>
<li>hashCode() 的默认行为是对堆上的对象产生独特值。如果没有重写 hashCode()，则该 class 的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li>
</ol>
<h1 id="什么是反射机制？反射机制的应用场景有哪些？"><a href="#什么是反射机制？反射机制的应用场景有哪些？" class="headerlink" title="什么是反射机制？反射机制的应用场景有哪些？"></a>什么是反射机制？反射机制的应用场景有哪些？</h1><h2 id="反射机制介绍"><a href="#反射机制介绍" class="headerlink" title="反射机制介绍"></a>反射机制介绍</h2><p>JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p>
<p>静态编译和动态编译</p>
<ul>
<li><strong>静态编译：</strong>在编译时确定类型，绑定对象</li>
<li><strong>动态编译：</strong>运行时确定类型，绑定对象</li>
</ul>
<p>反射机制优缺点</p>
<ul>
<li><strong>优点：</strong> 运行期类型的判断，动态加载类，提高代码灵活度。</li>
<li><strong>缺点：</strong> 性能瓶颈：反射相当于一系列解释操作，通知 JVM 要做的事情，性能比直接的java代码要慢很多。</li>
</ul>
<h2 id="反射的应用场景"><a href="#反射的应用场景" class="headerlink" title="反射的应用场景"></a>反射的应用场景</h2><h3 id="反射是框架设计的灵魂。"><a href="#反射是框架设计的灵魂。" class="headerlink" title="反射是框架设计的灵魂。"></a>反射是框架设计的灵魂。</h3><p>在我们平时的项目开发过程中，基本上很少会直接使用到反射机制，但这不能说明反射机制没有用，实际上有很多设计、开发都与反射机制有关，例如模块化的开发，通过反射去调用对应的字节码；动态代理设计模式也采用了反射机制，还有我们日常使用的 Spring／Hibernate 等框架也大量使用到了反射机制。</p>
<p>举例：①我们在使用JDBC连接数据库时使用Class.forName()通过反射加载数据库的驱动程序；②Spring框架也用到很多反射机制，最经典的就是xml的配置模式。Spring 通过 XML 配置模式装载 Bean 的过程：1) 将程序内所有 XML 或 Properties 配置文件加载入内存中;</p>
<p>2)Java类里面解析xml或properties里面的内容，得到对应实体类的字节码字符串以及相关的属性信息; 3)使用反射机制，根据这个字符串获得某个类的Class实例; 4)动态配置实例的属性</p>
<h1 id="为什么-Java-中只有值传递？"><a href="#为什么-Java-中只有值传递？" class="headerlink" title="为什么 Java 中只有值传递？"></a>为什么 Java 中只有值传递？</h1><p><strong>按值调用(call by value)表示方法接收的是调用者提供的值，而按引用调用（call by reference)表示方法接收的是调用者提供的变量地址。一个方法可以修改传递引用所对应的变量值，而不能修改传递值调用所对应的变量值。</strong> 它用来描述各种程序设计语言（不只是Java)中方法参数传递方式。</p>
<p><strong>Java程序设计语言总是采用按值调用。也就是说，方法得到的是所有参数值的一个拷贝，也就是说，方法不能修改传递给它的任何参数变量的内容。</strong></p>
<ul>
<li><strong>public</strong> <strong>static</strong> <strong>void</strong> <strong>main</strong>(String[] args) {</li>
<li>​    <strong>int</strong> num1 = 10;</li>
<li>​    <strong>int</strong> num2 = 20;</li>
<li></li>
<li>​    swap(num1, num2);</li>
<li></li>
<li>​    System.out.println(“num1 = “ + num1);</li>
<li>​    System.out.println(“num2 = “ + num2);</li>
<li>}</li>
<li></li>
<li><strong>public</strong> <strong>static</strong> <strong>void</strong> <strong>swap</strong>(<strong>int</strong> a, <strong>int</strong> b) {</li>
<li>​    <strong>int</strong> temp = a;</li>
<li>​    a = b;</li>
<li>​    b = temp;</li>
<li></li>
<li>​    System.out.println(“a = “ + a);</li>
<li>​    System.out.println(“b = “ + b);</li>
<li>}</li>
</ul>
<p><strong>结果：</strong></p>
<ul>
<li>a = 20</li>
<li>b = 10</li>
<li>num1 = 10</li>
<li>num2 = 20</li>
</ul>
<p>在swap方法中，a、b的值进行交换，并不会影响到 num1、num2。因为，a、b中的值，只是从 num1、num2 的复制过来的。也就是说，a、b相当于num1、num2 的副本，副本的内容无论怎么修改，都不会影响到原件本身。</p>
<p><strong>通过上面例子，我们已经知道了一个方法不能修改一个基本数据类型的参数，而对象引用作为参数就不一样</strong></p>
<ul>
<li>​        <strong>int</strong>[] arr = { 1, 2, 3, 4, 5 };</li>
<li>​        System.out.println(arr[0]);</li>
<li>​        change(arr);</li>
<li>​        System.out.println(arr[0]);</li>
<li>​    }</li>
<li></li>
<li>​    <strong>public</strong> <strong>static</strong> <strong>void</strong> <strong>change</strong>(<strong>int</strong>[] array) {</li>
<li>​        <em>// 将数组的第一个元素变为0</em></li>
<li>​        array[0] = 0;</li>
<li>​    }</li>
</ul>
<p><strong>结果：</strong></p>
<ul>
<li>1</li>
<li>0</li>
</ul>
<p><strong>解析：</strong></p>
<p>array 被初始化 arr 的拷贝也就是一个对象的引用，也就是说 array 和 arr 指向的时同一个数组对象。 因此，外部对引用对象的改变会反映到所对应的对象上。</p>
<p> <strong>我们已经看到，实现一个改变对象参数状态的方法并不是一件难事。理由很简单，方法得到的是对象引用的拷贝，对象引用及其他的拷贝同时引用同一个对象。</strong></p>
<ul>
<li><strong>public</strong> <strong>class</strong> <strong>Test</strong> {</li>
<li></li>
<li>​    <strong>public</strong> <strong>static</strong> <strong>void</strong> <strong>main</strong>(String[] args) {</li>
<li>​        <em>// TODO Auto-generated method stub</em></li>
<li>​        Student s1 = <strong>new</strong> Student(“小张”);</li>
<li>​        Student s2 = <strong>new</strong> Student(“小李”);</li>
<li>​        Test.swap(s1, s2);</li>
<li>​        System.out.println(“s1:” + s1.getName());</li>
<li>​        System.out.println(“s2:” + s2.getName());</li>
<li>​    }</li>
<li></li>
<li>​    <strong>public</strong> <strong>static</strong> <strong>void</strong> <strong>swap</strong>(Student x, Student y) {</li>
<li>​        Student temp = x;</li>
<li>​        x = y;</li>
<li>​        y = temp;</li>
<li>​        System.out.println(“x:” + x.getName());</li>
<li>​        System.out.println(“y:” + y.getName());</li>
<li>​    }</li>
<li>}</li>
</ul>
<p><strong>结果：</strong></p>
<ul>
<li><strong>x:小李</strong></li>
<li><strong>y:小张</strong></li>
<li><strong>s1:小张</strong></li>
<li><strong>s2:小李</strong></li>
</ul>
<p><strong>解析：</strong></p>
<p> <strong>方法并没有改变存储在变量 s1 和 s2 中的对象引用。swap方法的参数x和y被初始化为两个对象引用的拷贝，这个方法交换的是这两个拷贝</strong></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>Java程序设计语言对对象采用的不是引用调用，实际上，对象引用是按值传递的。</p>
<h2 id="下面再总结一下Java中方法参数的使用情况："><a href="#下面再总结一下Java中方法参数的使用情况：" class="headerlink" title="下面再总结一下Java中方法参数的使用情况："></a>下面再总结一下Java中方法参数的使用情况：</h2><ul>
<li>一个方法不能修改一个基本数据类型的参数（即数值型或布尔型）。</li>
<li>一个方法可以改变一个对象参数的状态。</li>
<li>一个方法不能让对象参数引用一个新的对象。</li>
</ul>
<p>参考：《Java核心技术卷Ⅰ》基础知识第十版第四章4.5小节</p>
<h1 id="Java-中-IO-流分为几种？BIO-NIO-AIO-有什么区别？"><a href="#Java-中-IO-流分为几种？BIO-NIO-AIO-有什么区别？" class="headerlink" title="Java 中 IO 流分为几种？BIO,NIO,AIO 有什么区别？"></a>Java 中 IO 流分为几种？BIO,NIO,AIO 有什么区别？</h1><h2 id="java-中-IO-流分为几种？"><a href="#java-中-IO-流分为几种？" class="headerlink" title="java 中 IO 流分为几种？"></a>java 中 IO 流分为几种？</h2><ul>
<li>按照流的<strong>流向</strong>分，可以分为<strong>输入流</strong>和<strong>输出流</strong>；</li>
<li>按照操作<strong>单元</strong>划分，可以划分为<strong>字节流</strong>和<strong>字符流</strong>；</li>
<li>按照流的<strong>角色</strong>划分为<strong>节点流</strong>和<strong>处理流</strong>。</li>
</ul>
<p>Java Io流共涉及40多个类，这些类看上去很杂乱，但实际上很有规则，而且彼此之间存在非常紧密的联系， Java I0流的40多个类都是从如下4个抽象类基类中派生出来的。</p>
<ul>
<li>InputStream/Reader: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li>
<li>OutputStream/Writer: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li>
</ul>
<h2 id="BIO-NIO-AIO-有什么区别？"><a href="#BIO-NIO-AIO-有什么区别？" class="headerlink" title="BIO,NIO,AIO 有什么区别？"></a>BIO,NIO,AIO 有什么区别？</h2><ul>
<li><strong>BIO (Blocking I/O):</strong> <strong>同步阻塞I/O模式</strong>，<strong>数据的读取写入必须阻塞在一个线程内等待其完成。</strong>在活动连接数不是特别高（小于单机1000）的情况下，这种模型是比较不错的，可以让每一个连接专注于自己的 I/O 并且编程模型简单，也不用过多考虑系统的过载、限流等问题。线程池本身就是一个天然的漏斗，可以缓冲一些系统处理不了的连接或请求。但是，当面对十万甚至百万级连接的时候，传统的 BIO 模型是无能为力的。因此，我们需要一种更高效的 I/O 处理模型来应对更高的并发量。</li>
<li><strong>NIO (New I/O):</strong> <strong>NIO是一种同步非阻塞的I/O模型</strong>，在Java 1.4 中引入了NIO框架，对应 java.nio 包，提供了 Channel , Selector，Buffer等抽象。NIO中的N可以理解为Non-blocking，不单纯是New。<strong>它支持面向缓冲的，基于通道的I/O操作方法</strong>。 NIO提供了与传统BIO模型中的 Socket 和 ServerSocket 相对应的 SocketChannel 和 ServerSocketChannel 两种不同的套接字通道实现,两种通道都支持阻塞和非阻塞两种模式。阻塞模式使用就像传统中的支持一样，<strong>比较简单，但是性能和可靠性都不好；非阻塞模式正好与之相反。对于低负载、低并发的应用程序，可以使用同步阻塞I/O来提升开发速率和更好的维护性；对于高负载、高并发的（网络）应用，应使用 NIO 的非阻塞模式来开发</strong></li>
<li><strong>AIO (Asynchronous I/O):</strong> AIO 也就是 NIO 2。在 Java 7 中引入了 NIO 的改进版 NIO 2,<strong>它是异步非阻塞的IO模型</strong>。<strong>异步 IO 是基于事件和回调机制实现的</strong>，<strong>也就是应用操作之后会直接返回，不会堵塞在那里，当后台处理完成，操作系统会通知相应的线程进行后续的操作</strong>。AIO 是异步IO的缩写，虽然 NIO 在网络操作中，提供了非阻塞的方法，但是 NIO 的 IO 行为还是同步的。对于 NIO 来说，我们的业务线程是在 IO 操作准备好时，得到通知，接着就由这个线程自行进行 IO 操作，IO操作本身是同步的。查阅网上相关资料，我发现就目前来说 AIO 的应用还不是很广泛，Netty 之前也尝试使用过 AIO，不过又放弃了。</li>
</ul>
<p>​                                                    </p>
<p>​                                                            <u><strong>谢谢观看，记得巩固哦</strong></u></p>
]]></content>
      <categories>
        <category>java 基础</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo+github搭建免费博客</title>
    <url>/2020/05/19/Java%E9%9B%86%E5%90%88/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>集合：</p>
<ul>
<li>list；</li>
<li>set；</li>
<li>map</li>
</ul>
<a id="more"></a>

<h1 id="说说List-Set-Map三者的区别？"><a href="#说说List-Set-Map三者的区别？" class="headerlink" title="说说List,Set,Map三者的区别？"></a>说说List,Set,Map三者的区别？</h1><ul>
<li><strong>List(对付顺序的好帮手)：</strong> List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象</li>
<li><strong>Set(注重独一无二的性质):</strong> 不允许重复的集合。不会有多个元素引用相同的对象。</li>
<li><strong>Map(用Key来搜索的专家):</strong> 使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。</li>
</ul>
<h1 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别?"></a>Arraylist 与 LinkedList 区别?</h1><ul>
<li><strong>1. 是否保证线程安全：</strong> ArrayList 和 LinkedList 都是不同步的，也就是<strong>不保证线程安全</strong>；</li>
<li><strong>2. 底层数据结构：</strong> Arraylist 底层使用的是<strong>Object数组</strong>；LinkedList 底层使用的是<strong>双向链表数据结构</strong>（JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li>
<li><strong>3. 插入和删除是否受元素位置的影响：</strong> ① <strong>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② <strong>LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O（1）而数组为近似 O（n）。</strong></li>
<li><strong>4. 是否支持快速随机访问：</strong> <strong>LinkedList 不支持高效的随机元素访问</strong>，而 <strong>ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。</strong></li>
<li><strong>5. 内存空间占用：</strong> ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。</li>
</ul>
<h1 id="ArrayList-与-Vector-区别呢-为什么要用Arraylist取代Vector呢？"><a href="#ArrayList-与-Vector-区别呢-为什么要用Arraylist取代Vector呢？" class="headerlink" title="ArrayList 与 Vector 区别呢?为什么要用Arraylist取代Vector呢？"></a>ArrayList 与 Vector 区别呢?为什么要用Arraylist取代Vector呢？</h1><p>Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。</p>
<p>Arraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。</p>
<h1 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h1><ol>
<li><strong>线程是否安全：</strong> HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过synchronized 修饰。（如果你要保证线程安全的话就使用 <strong>ConcurrentHashMap</strong> 吧！）；</li>
<li><strong>效率：</strong> 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li>
<li><strong>对Null key 和Null value的支持：</strong> HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。</li>
<li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小（HashMap 中的tableSizeFor()方法保证，下面给出了源代码）。也就是说 HashMap 总是使用2的幂作为哈希表的大小,后面会介绍到为什么是2的幂次方。</li>
<li><strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li>
</ol>
<h1 id="HashMap-和-HashSet区别"><a href="#HashMap-和-HashSet区别" class="headerlink" title="HashMap 和 HashSet区别"></a>HashMap 和 HashSet区别</h1><p>HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 clone()、writeObject()、readObject()是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。</p>
<h1 id="HashSet如何检查重复"><a href="#HashSet如何检查重复" class="headerlink" title="HashSet如何检查重复"></a>HashSet如何检查重复</h1><p>当你把对象加入HashSet时，HashSet会先计算对象的hashcode值来判断对象加入的位置，同时也会与其他加入的对象的hashcode值作比较，如果没有相符的hashcode，HashSet会假设对象没有重复出现。但是如果发现有相同hashcode值的对象，这时会调用equals（）方法来检查hashcode相等的对象是否真的相同。如果两者相同，HashSet就不会让加入操作成功。</p>
<h1 id="hashCode（）与equals（）的相关规定："><a href="#hashCode（）与equals（）的相关规定：" class="headerlink" title="hashCode（）与equals（）的相关规定："></a><strong>hashCode（）与equals（）的相关规定：</strong></h1><ol>
<li>如果两个对象相等，则hashcode一定也是相同的</li>
<li>两个对象相等,对两个equals方法返回true</li>
<li>两个对象有相同的hashcode值，它们也不一定是相等的</li>
<li>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</li>
<li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li>
</ol>
<h1 id="与equals的区别"><a href="#与equals的区别" class="headerlink" title="==与equals的区别"></a><strong>==与equals的区别</strong></h1><ol>
<li>==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同</li>
<li>==是指对内存地址进行比较 equals()是对字符串的内容进行比较</li>
<li>==指引用是否相同 equals()指的是值是否相同</li>
</ol>
<h1 id="HashMap的底层实现"><a href="#HashMap的底层实现" class="headerlink" title="HashMap的底层实现"></a>HashMap的底层实现</h1><p>JDK1.8之前</p>
<p>JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。<strong>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p>
<p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p>
<p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p>
<h1 id="HashMap-的长度为什么是2的幂次方"><a href="#HashMap-的长度为什么是2的幂次方" class="headerlink" title="HashMap 的长度为什么是2的幂次方"></a>HashMap 的长度为什么是2的幂次方</h1><p>为了能让 HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀。我们上面也讲到了过了，Hash 值的范围值-2147483648到2147483647，前后加起来大概40亿的映射空间，只要哈希函数映射得比较均匀松散，一般应用是很难出现碰撞的。但问题是一个40亿长度的数组，内存是放不下的。所以这个散列值是不能直接拿来用的。用之前还要先做对数组的长度取模运算，得到的余数才能用来要存放的位置也就是对应的数组下标。这个数组下标的计算方法是“ (n - 1) &amp; hash”。（n代表数组长度）。这也就解释了 HashMap 的长度为什么是2的幂次方。</p>
<p><strong>这个算法应该如何设计呢？</strong></p>
<p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：<strong>“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方；）。”</strong> 并且 <strong>采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</strong></p>
<h1 id="HashMap-多线程操作导致死循环问题"><a href="#HashMap-多线程操作导致死循环问题" class="headerlink" title="HashMap 多线程操作导致死循环问题"></a>HashMap 多线程操作导致死循环问题</h1><p>主要原因在于 并发下的Rehash 会造成元素之间会形成一个循环链表。不过，jdk 1.8 后解决了这个问题，但是还是不建议在多线程下使用 HashMap,因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失。并发环境下推荐使用 ConcurrentHashMap 。</p>
<p>详情请查看：<a href="https://coolshell.cn/articles/9606.html6" target="_blank" rel="noopener">https://coolshell.cn/articles/9606.html6</a></p>
<h1 id="ConcurrentHashMap-和-Hashtable-的区别"><a href="#ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别"></a>ConcurrentHashMap 和 Hashtable 的区别</h1><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在实现线程安全的方式上不同。</p>
<ul>
<li><strong>底层数据结构：</strong> JDK1.7的 ConcurrentHashMap 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的；</li>
<li><strong>实现线程安全的方式（重要）：</strong> ① <strong>在JDK1.7的时候，ConcurrentHashMap（分段锁）</strong> 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong>Hashtable(同一把锁)</strong> :使用 synchronized 来保证线程安全，效率非常低下。当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</li>
</ul>
<h1 id="ConcurrentHashMap线程安全的具体实现方式-底层具体实现"><a href="#ConcurrentHashMap线程安全的具体实现方式-底层具体实现" class="headerlink" title="ConcurrentHashMap线程安全的具体实现方式/底层具体实现"></a>ConcurrentHashMap线程安全的具体实现方式/底层具体实现</h1><p>JDK1.7</p>
<p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p>
<p><strong>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成</strong>。</p>
<p>Segment 实现了 ReentrantLock,所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。</p>
<ul>
<li><strong>static</strong> <strong>class</strong> <strong>Segment</strong>&lt;<strong>K</strong>,<strong>V</strong>&gt; <strong>extends</strong> <strong>ReentrantLock</strong> <strong>implements</strong> <strong>Serializable</strong> {</li>
<li>}</li>
</ul>
<p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</p>
<p>JDK1.8 </p>
<p>ConcurrentHashMap取消了Segment分段锁，采用CAS和synchronized来保证并发安全。数据结构跟HashMap1.8的结构类似，数组+链表/红黑二叉树。Java 8在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为O(N)）转换为红黑树（寻址时间复杂度为O(long(N))）</p>
<p>synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</p>
<h2 id="comparable-和-Comparator的区别"><a href="#comparable-和-Comparator的区别" class="headerlink" title="comparable 和 Comparator的区别"></a>comparable 和 Comparator的区别</h2><ul>
<li>comparable接口实际上是出自java.lang包 它有一个 compareTo(Object obj)方法用来排序</li>
<li>comparator接口实际上是出自 java.util 包它有一个compare(Object obj1, Object obj2)方法用来排序</li>
</ul>
<p>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo()方法或compare()方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo()方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 Collections.sort().</p>
<h2 id="Comparator定制排序"><a href="#Comparator定制排序" class="headerlink" title="Comparator定制排序"></a>Comparator定制排序</h2><ul>
<li>​        ArrayList<Integer> arrayList = <strong>new</strong> ArrayList<Integer>();</li>
<li>​        arrayList.add(-1);</li>
<li>​        arrayList.add(3);</li>
<li>​        arrayList.add(3);</li>
<li>​        arrayList.add(-5);</li>
<li>​        arrayList.add(7);</li>
<li>​        arrayList.add(4);</li>
<li>​        arrayList.add(-9);</li>
<li>​        arrayList.add(-7);</li>
<li>​        System.out.println(“原始数组:”);</li>
<li>​        System.out.println(arrayList);</li>
<li>​        <em>// void reverse(List list)：反转</em></li>
<li>​        Collections.reverse(arrayList);</li>
<li>​        System.out.println(“Collections.reverse(arrayList):”);</li>
<li>​        System.out.println(arrayList);</li>
<li></li>
<li>​        <em>// void sort(List list),按自然排序的升序排序</em></li>
<li>​        Collections.sort(arrayList);</li>
<li>​        System.out.println(“Collections.sort(arrayList):”);</li>
<li>​        System.out.println(arrayList);</li>
<li>​        <em>// 定制排序的用法</em></li>
<li>​        Collections.sort(arrayList, <strong>new</strong> Comparator<Integer>() {</li>
<li></li>
<li>​            <strong>@Override</strong></li>
<li>​            <strong>public</strong> <strong>int</strong> <strong>compare</strong>(Integer o1, Integer o2) {</li>
<li>​                <strong>return</strong> o2.compareTo(o1);</li>
<li>​            }</li>
<li>​        });</li>
<li>​        System.out.println(“定制排序后：”);</li>
<li>​        System.out.println(arrayList);</li>
</ul>
<p>Output:</p>
<ul>
<li>原始数组:</li>
<li>[-1, 3, 3, -5, 7, 4, -9, -7]</li>
<li><strong>Collections</strong>.reverse(<strong>arrayList</strong>):</li>
<li>[-7, -9, 4, 7, -5, 3, 3, -1]</li>
<li><strong>Collections</strong>.sort(<strong>arrayList</strong>):</li>
<li>[-9, -7, -5, -1, 3, 3, 4, 7]</li>
<li>定制排序后：</li>
<li>[7, 4, 3, 3, -1, -5, -7, -9]</li>
</ul>
<h2 id="重写compareTo方法实现按年龄来排序"><a href="#重写compareTo方法实现按年龄来排序" class="headerlink" title="重写compareTo方法实现按年龄来排序"></a>重写compareTo方法实现按年龄来排序</h2><ul>
<li><p><em>// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列</em></p>
</li>
<li><p><em>// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他</em></p>
</li>
<li><p><em>// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了</em></p>
</li>
<li></li>
<li><p><strong>public</strong>  <strong>class</strong> <strong>Person</strong> <strong>implements</strong> <strong>Comparable</strong>&lt;<strong>Person</strong>&gt; {</p>
</li>
<li><p>​    <strong>private</strong> String name;</p>
</li>
<li><p>​    <strong>private</strong> <strong>int</strong> age;</p>
</li>
<li></li>
<li><p>​    <strong>public</strong> <strong>Person</strong>(String name, <strong>int</strong> age) {</p>
</li>
<li><p>​        <strong>super</strong>();</p>
</li>
<li><p>​        <strong>this</strong>.name = name;</p>
</li>
<li><p>​        <strong>this</strong>.age = age;</p>
</li>
<li><p>​    }</p>
</li>
<li></li>
<li><p>​    <strong>public</strong> String <strong>getName</strong>() {</p>
</li>
<li><p>​        <strong>return</strong> name;</p>
</li>
<li><p>​    }</p>
</li>
<li></li>
<li><p>​    <strong>public</strong> <strong>void</strong> <strong>setName</strong>(String name) {</p>
</li>
<li><p>​        <strong>this</strong>.name = name;</p>
</li>
<li><p>​    }</p>
</li>
<li></li>
<li><p>​    <strong>public</strong> <strong>int</strong> <strong>getAge</strong>() {</p>
</li>
<li><p>​        <strong>return</strong> age;</p>
</li>
<li><p>​    }</p>
</li>
<li></li>
<li><p>​    <strong>public</strong> <strong>void</strong> <strong>setAge</strong>(<strong>int</strong> age) {</p>
</li>
<li><p>​        <strong>this</strong>.age = age;</p>
</li>
<li><p>​    }</p>
</li>
<li></li>
<li><p>​    <em>/**</em></p>
</li>
<li><p>​     <em>* TODO重写compareTo方法实现按年龄来排序</em></p>
</li>
<li><p>​     <em>*/</em></p>
</li>
<li><p>​    <strong>@Override</strong></p>
</li>
<li><p>​    <strong>public</strong> <strong>int</strong> <strong>compareTo</strong>(Person o) {</p>
</li>
<li><p>​        <em>// TODO Auto-generated method stub</em></p>
</li>
<li><p>​        <strong>if</strong> (<strong>this</strong>.age &gt; o.getAge()) {</p>
</li>
<li><p>​            <strong>return</strong> 1;</p>
</li>
<li><p>​        } <strong>else</strong> <strong>if</strong> (<strong>this</strong>.age &lt; o.getAge()) {</p>
</li>
<li><p>​            <strong>return</strong> -1;</p>
</li>
<li><p>​        }</p>
</li>
<li><p>​        <strong>return</strong> age;</p>
</li>
<li><p>​    }</p>
</li>
<li><p>}</p>
</li>
<li><p>​    <strong>public</strong> <strong>static</strong> <strong>void</strong> <strong>main</strong>(String[] args) {</p>
</li>
<li><p>​        TreeMap&lt;Person, String&gt; pdata = <strong>new</strong> TreeMap&lt;Person, String&gt;();</p>
</li>
<li><p>​        pdata.put(<strong>new</strong> Person(“张三”, 30), “zhangsan”);</p>
</li>
<li><p>​        pdata.put(<strong>new</strong> Person(“李四”, 20), “lisi”);</p>
</li>
<li><p>​        pdata.put(<strong>new</strong> Person(“王五”, 10), “wangwu”);</p>
</li>
<li><p>​        pdata.put(<strong>new</strong> Person(“小红”, 5), “xiaohong”);</p>
</li>
<li><p>​        <em>// 得到key的值的同时得到key所对应的值</em></p>
</li>
<li><p>​        Set<Person> keys = pdata.keySet();</p>
</li>
<li><p>​        <strong>for</strong> (Person key : keys) {</p>
</li>
<li><p>​            System.out.println(key.getAge() + “-“ + key.getName());</p>
</li>
<li></li>
<li><p>​        }</p>
</li>
<li><p>​    }</p>
</li>
</ul>
<p>Output：</p>
<ul>
<li>5-小红</li>
<li>10-王五</li>
<li>20-李四</li>
<li>30-张三</li>
</ul>
<h1 id="集合框架底层数据结构总结"><a href="#集合框架底层数据结构总结" class="headerlink" title="集合框架底层数据结构总结"></a>集合框架底层数据结构总结</h1><p>Collection</p>
<p>\1. List</p>
<ul>
<li><strong>Arraylist：</strong> Object数组</li>
<li><strong>Vector：</strong> Object数组</li>
<li><strong>LinkedList：</strong> 双向链表(JDK1.6之前为循环链表，JDK1.7取消了循环) 详细可阅读<a href="https://www.cnblogs.com/xingele0917/p/3696593.html" target="_blank" rel="noopener">JDK1.7-LinkedList循环链表优化</a></li>
</ul>
<p>\2. Set</p>
<ul>
<li><strong>HashSet（无序，唯一）:</strong> 基于 HashMap 实现的，底层采用 HashMap 来保存元素</li>
<li><strong>LinkedHashSet：</strong> LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。</li>
<li><strong>TreeSet（有序，唯一）：</strong> 红黑树(自平衡的排序二叉树。)</li>
</ul>
<p>Map</p>
<ul>
<li><strong>HashMap：</strong> JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间</li>
<li><strong>LinkedHashMap：</strong> LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<a href="https://www.imooc.com/article/22931" target="_blank" rel="noopener">《LinkedHashMap 源码详细分析（JDK1.8）》</a></li>
<li><strong>Hashtable：</strong> 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li>
<li><strong>TreeMap：</strong> 红黑树（自平衡的排序二叉树）</li>
</ul>
<p>如何选用集合?</p>
<p>集合的选用</p>
<p>主要根据集合的特点来选用，比如我们需要根据键值获取到元素值时就选用Map接口下的集合，需要排序时选择TreeMap,不需要排序时就选择HashMap,需要保证线程安全就选用ConcurrentHashMap.当我们只需要存放元素值时，就选择实现Collection接口的集合，需要保证元素唯一时选择实现Set接口的集合比如TreeSet或HashSet，不需要就选择实现List接口的比如ArrayList或LinkedList，然后再根据实现这些接口的集合的特点来选用。</p>
]]></content>
      <categories>
        <category>Java基础</category>
      </categories>
      <tags>
        <tag>集合</tag>
      </tags>
  </entry>
</search>
