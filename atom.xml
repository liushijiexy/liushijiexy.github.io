<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>小站博客</title>
  
  <subtitle>谢谢你们这么好看，还来光顾我的小站</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-20T09:23:50.915Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>liushijiexy</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>数据库常见问题</title>
    <link href="http://yoursite.com/2020/05/20/MySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/05/20/MySQL%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2020-05-20T07:47:43.931Z</published>
    <updated>2020-05-20T09:23:50.915Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用git：</p><ul><li>概述；</li><li>事务；</li><li>可以随</li><li>数据绝</li></ul><a id="more"></a><h1 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h1><p>MySQL 是一种关系型数据库，在Java企业级开发中非常常用，因为 MySQL 是开源免费的，并且方便扩展。阿里巴巴数据库系统也大量用到了 MySQL，因此它的稳定性是有保障的。MySQL是开放源代码的，因此任何人都可以在 GPL(General Public License) 的许可下下载并根据个性化的需要对其进行修改。MySQL的默认端口号是<strong>3306</strong>。</p><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><h2 id="什么是事务"><a href="#什么是事务" class="headerlink" title="什么是事务?"></a>什么是事务?</h2><p><strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p><p>事务最经典也经常被拿出来说例子就是转账了。假如小里要给小明转账1000元，这个转账会涉及到两个关键操作就是：将小里的余额减少1000元，将小明的余额增加1000元。万一在这两个操作之间突然出现错误比如银行系统崩溃，导致小里余额减少而小明的余额没有增加，这样就不对了。事务就是保证这两个关键操作要么都成功，要么都要失败。</p><p>事物的四大特性(ACID)介绍一下?</p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5Cc40f0199927248b690b1990d0a35f4f3%5C1bcac4797d79.png" alt="img"></p><p>事物的特性</p><ol><li><strong>原子性：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li><strong>一致性：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li><li><strong>隔离性：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li><strong>持久性：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ol><p>并发事务带来哪些问题?</p><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对统一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p><ul><li><strong>脏读（Dirty read）:</strong> 当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。a是修改数据没提交到数据库b要使用这条数据但是是没有修改的数据  脏数据</li><li><strong>丢失修改（Lost to modify）:</strong> 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。 例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。a修改  b也修改但是b把a的修改覆盖了 a数据丢失</li><li><strong>不可重复读（Unrepeatableread）:</strong> 指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。 a重复读数据但是b吧数据更改了这时候a两次不一样 不可从复读</li><li><strong>幻读（Phantom read）:</strong> 幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。a读 b插入了一些数据 这时候a查到了原本不存在的数据</li></ul><p><strong>不可重复度和幻读区别：</strong></p><p>不可重复读的重点是修改，幻读的重点在于新增或者删除。</p><p>例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复读。</p><p>例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。</p><h1 id="事务隔离级别，MySQL的默认隔离级别。"><a href="#事务隔离级别，MySQL的默认隔离级别。" class="headerlink" title="事务隔离级别，MySQL的默认隔离级别。"></a>事务隔离级别，MySQL的默认隔离级别。</h1><p><strong>SQL 标准定义了四个隔离级别：</strong></p><ul><li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li><li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li><li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li><li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li></ul><p><strong>不可重复度和幻读区别：</strong></p><p>不可重复读的重点是修改，幻读的重点在于新增或者删除。</p><p>例1（同样的条件, 你读取过的数据, 再次读取出来发现值不一样了 ）：事务1中的A先生读取自己的工资为 1000的操作还没完成，事务2中的B先生就修改了A的工资为2000，导 致A再读自己的工资时工资变为 2000；这就是不可重复读。</p><p>例2（同样的条件, 第1次和第2次读出来的记录数不一样 ）：假某工资单表中工资大于3000的有4人，事务1读取了所有工资大于3000的人，共查到4条记录，这时事务2 又插入了一条工资大于3000的记录，事务1再次读取时查到的记录就变为了5条，这样就导致了幻读。</p><p>事务隔离级别有哪些?MySQL的默认隔离级别是?</p><p><strong>SQL 标准定义了四个隔离级别：</strong></p><ul><li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li><li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li><li><strong>REPEATABLE-READ(可重复读)：</strong> 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li><li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li></ul><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻影读</th></tr></thead><tbody><tr><td>READ-UNCOMMITTED</td><td>√</td><td>√</td><td>√</td></tr><tr><td>READ-COMMITTED</td><td>×</td><td>√</td><td>√</td></tr><tr><td>REPEATABLE-READ</td><td>×</td><td>×</td><td>√</td></tr><tr><td>SERIALIZABLE</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong>。我们可以通过SELECT @@tx_isolation;命令来查看</p><ul><li>mysql&gt; <strong>SELECT</strong> @@tx_isolation;</li><li>+<em>—————–+</em></li><li>| @@tx_isolation  |</li><li>+<em>—————–+</em></li><li>| REPEATABLE-READ |</li><li>+<em>—————–+</em></li></ul><p>这里需要注意的是：与 SQL 标准不同的地方在于InnoDB 存储引擎在 <strong>REPEATABLE-READ（可重读）</strong>事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 <strong>REPEATABLE-READ（可重读）</strong> 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的<strong>SERIALIZABLE(可串行化)</strong>隔离级别。</p><p>因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是<strong>READ-COMMITTED(读取提交内容):</strong>，但是你要知道的是InnoDB 存储引擎默认使用 <strong>REPEATABLE-READ（可重读）</strong>并不会有任何性能损失。</p><p>InnoDB 存储引擎在 <strong>分布式事务</strong> 的情况下一般会用到<strong>SERIALIZABLE(可串行化)</strong>隔离级别。</p>]]></content>
    
    <summary type="html">
    
      数据常见问题
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="问题" scheme="http://yoursite.com/tags/%E9%97%AE%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>JVM（下）</title>
    <link href="http://yoursite.com/2020/05/20/jvm%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://yoursite.com/2020/05/20/jvm%EF%BC%88%E4%B8%8B%EF%BC%89/</id>
    <published>2020-05-19T22:16:58.000Z</published>
    <updated>2020-05-20T06:31:13.023Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM-下"><a href="#JVM-下" class="headerlink" title="JVM(下)"></a>JVM(下)</h1><ul><li>类文件结构；</li><li>类加载的过程；</li><li>类加载器；</li><li>双亲委派模型；</li><li>双亲委派模型实现源码分析；</li><li>双亲委派模型带来了什么好处；</li><li>如果我们不想用双亲委派模型怎么办?</li><li>如何自定义类加载器；</li></ul><a id="more"></a><p>根据 Java 虚拟机规范，类文件由单个 ClassFile 结构组成：</p><ul><li>ClassFile {</li><li>​    u4             magic; <em>//Class 文件的标志</em></li><li>​    u2             minor_version;<em>//Class 的小版本号</em></li><li>​    u2             major_version;<em>//Class 的大版本号</em></li><li>​    u2             constant_pool_count;<em>//常量池的数量</em></li><li>​    cp_info        constant_pool[constant_pool_count-1];<em>//常量池</em></li><li>​    u2             access_flags;<em>//Class 的访问标记</em></li><li>​    u2             this_class;<em>//当前类</em></li><li>​    u2             super_class;<em>//父类</em></li><li>​    u2             interfaces_count;<em>//接口</em></li><li>​    u2             interfaces[interfaces_count];<em>//一个类可以实现多个接口</em></li><li>​    u2             fields_count;<em>//Class 文件的字段属性</em></li><li>​    field_info     fields[fields_count];<em>//一个类会可以有个字段</em></li><li>​    u2             methods_count;<em>//Class 文件的方法数量</em></li><li>​    method_info    methods[methods_count];<em>//一个类可以有个多个方法</em></li><li>​    u2             attributes_count;<em>//此类的属性表中的属性数</em></li><li>​    attribute_info attributes[attributes_count];<em>//属性表集合</em></li><li>}</li></ul><h4 id="Class文件字节码结构组织示意图"><a href="#Class文件字节码结构组织示意图" class="headerlink" title="Class文件字节码结构组织示意图"></a><strong>Class文件字节码结构组织示意图</strong></h4><p><img src="E:%5CShellExt%5Cerer961115@163.com%5C2c054e4d0d2d4720a9cd25ab81e3e49e%5Cc663eaa42d8f.png" alt="img"></p><p>按照上图结构按顺序详细介绍一下 Class 文件结构涉及到的一些组件。</p><ol><li><p><strong>魔数:</strong> 确定这个文件是否为一个能被虚拟机接收的 Class 文件。</p></li><li><p><strong>Class 文件版本</strong> ：Class 文件的版本号，保证编译正常执行。</p></li><li><p><strong>常量池</strong> ：常量池主要存放两大常量：字面量和符号引用。</p></li><li><p><strong>访问标志</strong> ：标志用于识别一些类或者接口层次的访问信息，包括：这个 Class 是类还是接口，是否为 public 或者 abstract 类型，如果是类的话是否声明为 final 等等。</p></li><li><p><strong>当前类索引,父类索引</strong> ：类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，由于 Java 语言的单继承，所以父类索引只有一个，除了 java.lang.Object 之外，所有的 java 类都有父类，因此除了 java.lang.Object 外，所有 Java 类的父类索引都不为 0。</p></li><li><p><strong>接口索引集合</strong> ：接口索引集合用来描述这个类实现了那些接口，这些被实现的接口将按implents(如果这个类本身是接口的话则是extends) 后的接口顺序从左到右排列在接口索引集合中。</p></li><li><p><strong>字段表集合</strong> ：描述接口或类中声明的变量。字段包括类级变量以及实例变量，但不包括在方法内部声明的局部变量。</p></li><li><p><strong>方法表集合</strong> ：类中的方法。</p></li><li><p><strong>属性表集合</strong> ： 在 Class 文件，字段表，方法表中都可以携带自己的属性表集合。</p><h2 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h2></li></ol><ul><li>类加载过程：<strong>加载-&gt;连接-&gt;初始化</strong>。连接过程又可分为三步:<strong>验证-&gt;准备-&gt;解析</strong>。</li></ul><p>加载阶段和连接阶段的部分内容是交叉进行的，加载阶段尚未结束，连接阶段可能就已经开始了。</p><ul><li>类加载过程的第一步，主要完成下面3件事情：</li></ul><ol><li><p>通过全类名获取定义此类的二进制字节流.. ( 比较常见的就是从 ZIP 包中读取（日后出现的JAR、EAR、WAR格式的基础）、其他文件生成（典型应用就是JSP）等等。</p><p><strong>一个非数组类的加载阶段（加载阶段获取类的二进制字节流的动作）是可控性最强的阶段，这一步我们可以去完成还可以自定义类加载器去控制字节流的获取方式（重写一个类加载器的</strong> <strong>loadClass()</strong> <strong>方法）。数组类型不通过类加载器创建，它由 Java 虚拟机直接创建。</strong></p></li><li><p>将字节流所代表的静态存储结构转换为方法区的运行时数据结构</p></li><li><p>在内存中生成一个代表该类的 Class 对象,作为方法区这些数据的访问入口</p></li></ol><h2 id="有哪些类加载器"><a href="#有哪些类加载器" class="headerlink" title="有哪些类加载器"></a>有哪些类加载器</h2><p>JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自java.lang.ClassLoader：</p><ol><li><strong>BootstrapClassLoader(启动类加载器)</strong> ：最顶层的加载类，由C++实现，负责加载 %JAVA_HOME%/lib目录下的jar包和类或者或被 -Xbootclasspath参数指定的路径中的所有类。</li><li><strong>ExtensionClassLoader(扩展类加载器)</strong> ：主要负责加载目录 %JRE_HOME%/lib/ext 目录下的jar包和类，或被 java.ext.dirs 系统变量所指定的路径下的jar包。</li><li><strong>AppClassLoader(应用程序类加载器)</strong> :面向我们用户的加载器，负责加载当前应用classpath下的所有jar包和类。</li></ol><h1 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h1><p>每一个类都有一个对应它的类加载器。系统中的 ClassLoder 在协同工作的时候会默认使用 <strong>双亲委派模型</strong> 。即在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。<strong>加载的时候，首先会把该请求委派该父类加载器的</strong> <strong>loadClass()</strong> <strong>处理，因此所有的请求最终都应该传送到顶层的启动类加载器</strong> <strong>BootstrapClassLoader</strong> <strong>中。当父类加载器无法处理时，才由自己来处理。</strong>当父类加载器为null时，会使用启动类加载器 BootstrapClassLoader 作为父类加载器。</p><img src="E:%5CShellExt%5Cerer961115@163.com%5C9d087a127cfb418fba40530e0d66d194%5C4411c166c03d.png" alt="img" style="zoom:75%;" /><h5 id="每个类加载都有一个父类加载器，我们通过下面的程序来验证。"><a href="#每个类加载都有一个父类加载器，我们通过下面的程序来验证。" class="headerlink" title="每个类加载都有一个父类加载器，我们通过下面的程序来验证。"></a>每个类加载都有一个父类加载器，我们通过下面的程序来验证。</h5><ul><li><strong>public</strong> <strong>class</strong> <strong>ClassLoaderDemo</strong> {</li><li>​    <strong>public</strong> <strong>static</strong> <strong>void</strong> <strong>main</strong>(String[] args) {</li><li>​        System.out.println(“ClassLodarDemo’s ClassLoader is “ + ClassLoaderDemo.class.getClassLoader());</li><li>​        System.out.println(“The Parent of ClassLodarDemo’s ClassLoader is “ + ClassLoaderDemo.class.getClassLoader().getParent());</li><li>​        System.out.println(“The GrandParent of ClassLodarDemo’s ClassLoader is “ + ClassLoaderDemo.class.getClassLoader().getParent().getParent());</li><li>​    }</li><li>}</li></ul><p>Output</p><ul><li>ClassLodarDemo’s ClassLoader is sun.misc.Launcher$AppClassLoader@18b4aac2</li><li>The Parent of ClassLodarDemo’s ClassLoader <strong>is</strong> sun.misc.Launcher$ExtClassLoader@1b6d3586</li><li>The GrandParent <strong>of</strong> ClassLodarDemo’s ClassLoader is null</li></ul><p>AppClassLoader的父类加载器为ExtClassLoader</p><p>ExtClassLoader的父类加载器为null，<strong>null并不代表**</strong>ExtClassLoader<strong>**没有父类加载器，而是</strong> <strong>Bootstrap ClassLoader</strong> 。</p><p>其实这个双亲翻译的容易让别人误解，我们一般理解的双亲都是父母，这里的双亲更多地表达的是“父母这一辈”的人而已，并不是说真的有一个 Mather ClassLoader 和一个 Father ClassLoader 。另外，类加载器之间的“父子”关系也不是通过继承来体现的，是由“优先级”来决定。官方API文档对这部分的描述如下:</p><p>The Java platform uses a delegation model for loading classes. <strong>The basic idea is that every class loader has a “parent” class loader.</strong> When loading a class, a class loader first “delegates” the search for the class to its parent class loader before attempting to find the class itself.</p><h1 id="双亲委派模型实现源码分析"><a href="#双亲委派模型实现源码分析" class="headerlink" title="双亲委派模型实现源码分析"></a>双亲委派模型实现源码分析</h1><p>双亲委派模型的实现代码非常简单，逻辑非常清晰，都集中在 java.lang.ClassLoader 的 loadClass() 中，相关代码如下所示。</p><ul><li><strong>private</strong> <strong>final</strong> ClassLoader parent; </li><li><strong>protected</strong> Class&lt;?&gt; loadClass(String name, <strong>boolean</strong> resolve)</li><li>​        <strong>throws</strong> ClassNotFoundException</li><li>​    {</li><li>​        <strong>synchronized</strong> (getClassLoadingLock(name)) {</li><li>​            <em>// 首先，检查请求的类是否已经被加载过</em></li><li>​            Class&lt;?&gt; c = findLoadedClass(name);</li><li>​            <strong>if</strong> (c == <strong>null</strong>) {</li><li>​                <strong>long</strong> t0 = System.nanoTime();</li><li>​                <strong>try</strong> {</li><li>​                    <strong>if</strong> (parent != <strong>null</strong>) {<em>//父加载器不为空，调用父加载器loadClass()方法处理</em></li><li>​                        c = parent.loadClass(name, <strong>false</strong>);</li><li>​                    } <strong>else</strong> {<em>//父加载器为空，使用启动类加载器 BootstrapClassLoader 加载</em></li><li>​                        c = findBootstrapClassOrNull(name);</li><li>​                    }</li><li>​                } <strong>catch</strong> (ClassNotFoundException e) {</li><li>​                   <em>//抛出异常说明父类加载器无法完成加载请求</em></li><li>​                }</li><li></li><li>​                <strong>if</strong> (c == <strong>null</strong>) {</li><li>​                    <strong>long</strong> t1 = System.nanoTime();</li><li>​                    <em>//自己尝试加载</em></li><li>​                    c = findClass(name);</li><li></li><li>​                    <em>// this is the defining class loader; record the stats</em></li><li>​                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</li><li>​                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</li><li>​                    sun.misc.PerfCounter.getFindClasses().increment();</li><li>​                }</li><li>​            }</li><li>​            <strong>if</strong> (resolve) {</li><li>​                resolveClass(c);</li><li>​            }</li><li>​            <strong>return</strong> c;</li><li>​        }</li><li>​    }</li></ul><h1 id="双亲委派模型带来了什么好处呢？"><a href="#双亲委派模型带来了什么好处呢？" class="headerlink" title="双亲委派模型带来了什么好处呢？"></a>双亲委派模型带来了什么好处呢？</h1><p>双亲委派模型保证了Java程序的稳定运行，可以<strong>避免类的重复加载</strong>（JVM 区分不同类的方式<strong>不仅仅根据类名</strong>，相同的<strong>类文件被不同的类加载器加载产生的是两个不同的类</strong>），也保证了 Java 的核心 API 不被篡改。如果不用没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 java.lang.Object 类的话，那么程序运行的时候，系统就会出现多个不同的 Object 类。</p><h1 id="如果我们不想用双亲委派模型怎么办？"><a href="#如果我们不想用双亲委派模型怎么办？" class="headerlink" title="如果我们不想用双亲委派模型怎么办？"></a>如果我们不想用双亲委派模型怎么办？</h1><p>为了避免双亲委托机制，我们可以<strong>自己定义一个类加载器</strong>，然后<strong>重载 loadClass(</strong>) 即可。</p><h1 id="如何自定义类加载器"><a href="#如何自定义类加载器" class="headerlink" title="如何自定义类加载器?"></a>如何自定义类加载器?</h1><p>除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自java.lang.ClassLoader。如果我们要自定义<strong>自己的类加载器，很明显需要继承 ClassLoader。</strong></p>]]></content>
    
    <summary type="html">
    
      JVM(下)
    
    </summary>
    
    
      <category term="Java 基础" scheme="http://yoursite.com/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="虚拟机" scheme="http://yoursite.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>JVM(上)</title>
    <link href="http://yoursite.com/2020/05/19/JVM(%E4%B8%8A)/"/>
    <id>http://yoursite.com/2020/05/19/JVM(%E4%B8%8A)/</id>
    <published>2020-05-19T14:16:58.000Z</published>
    <updated>2020-05-19T15:10:26.039Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM-上"><a href="#JVM-上" class="headerlink" title="JVM(上)"></a>JVM(上)</h1><ol><li><h3 id="介绍下-Java-内存区域-运行时数据区"><a href="#介绍下-Java-内存区域-运行时数据区" class="headerlink" title="介绍下 Java 内存区域(运行时数据区)"></a>介绍下 Java 内存区域(运行时数据区)</h3></li><li><h3 id="说一下Java对象的创建过程"><a href="#说一下Java对象的创建过程" class="headerlink" title="说一下Java对象的创建过程"></a>说一下Java对象的创建过程</h3></li><li><h3 id="对象的访问定位有哪两种方式"><a href="#对象的访问定位有哪两种方式" class="headerlink" title="对象的访问定位有哪两种方式?"></a>对象的访问定位有哪两种方式?</h3></li><li><h3 id="说一下堆内存中对象的分配的基本策略"><a href="#说一下堆内存中对象的分配的基本策略" class="headerlink" title="说一下堆内存中对象的分配的基本策略"></a>说一下堆内存中对象的分配的基本策略</h3></li><li><h3 id="Minor-Gc和Full-GC-有什么不同呢？"><a href="#Minor-Gc和Full-GC-有什么不同呢？" class="headerlink" title="Minor Gc和Full GC 有什么不同呢？"></a>Minor Gc和Full GC 有什么不同呢？</h3></li></ol><a id="more"></a><h2 id="介绍下-Java-内存区域-运行时数据区-1"><a href="#介绍下-Java-内存区域-运行时数据区-1" class="headerlink" title="介绍下 Java 内存区域(运行时数据区)"></a>介绍下 Java 内存区域(运行时数据区)</h2><p>Java 虚拟机在执行 Java 程序的过程中会把它管理的内存划分成若干个不同的数据区域。JDK. 1.8 和之前的版本略有不同，</p><p><strong>线程私有的：</strong></p><ul><li>程序计数器</li><li>虚拟机栈</li><li>本地方法栈</li></ul><p><strong>线程共享的：</strong></p><ul><li>堆</li><li>方法区</li><li>直接内存(非运行时数据区的一部分)</li></ul><h3 id="1-1-程序计数器"><a href="#1-1-程序计数器" class="headerlink" title="1.1. 程序计数器"></a>1.1. 程序计数器</h3><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完。</strong></p><p>另外，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</strong></p><p><strong>从上面的介绍中我们知道程序计数器主要有两个作用：</strong></p><ol><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ol><p><strong>注意：程序计数器是唯一一个不会出现 OutOfMemoryError 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡。</strong></p><h3 id="1-2-Java-虚拟机栈"><a href="#1-2-Java-虚拟机栈" class="headerlink" title="1.2. Java 虚拟机栈"></a>1.2. Java 虚拟机栈</h3><p><strong>与程序计数器一样，Java虚拟机栈也是线程私有的，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。</strong></p><p><strong>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存(Stack),其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</strong> （实际上，Java虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）</p><p><strong>局部变量表主要存放了编译器可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p><p><strong>Java 虚拟机栈会出现两种异常：StackOverFlowError 和 OutOfMemoryError。</strong></p><ul><li><strong>StackOverFlowError：</strong> 若Java虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前Java虚拟机栈的最大深度的时候，就抛出StackOverFlowError异常。</li><li><strong>OutOfMemoryError：</strong> 若 Java 虚拟机栈的内存大小允许动态扩展，且当线程请求栈时内存用完了，无法再动态扩展了，此时抛出OutOfMemoryError异常。</li></ul><p>Java 虚拟机栈也是线程私有的，每个线程都有各自的Java虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p><p><strong>扩展：那么方法/函数如何调用？</strong></p><p>Java 栈可用类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入Java栈，每一个函数调用结束后，都会有一个栈帧被弹出。</p><p>Java方法有两种返回方式：</p><ol><li>return 语句。</li><li>抛出异常。</li></ol><p>不管哪种返回方式都会导致栈帧被弹出。</p><h3 id="1-3-本地方"><a href="#1-3-本地方" class="headerlink" title="1.3. 本地方"></a>1.3. 本地方</h3><h3 id="法栈"><a href="#法栈" class="headerlink" title="法栈"></a>法栈</h3><p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p><p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p><p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 StackOverFlowError 和 OutOfMemoryError 两种异常。</p><h3 id="1-4-堆"><a href="#1-4-堆" class="headerlink" title="1.4. 堆"></a>1.4. 堆</h3><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以Java堆还可以细分为：新生代和老年代：再细致一点有：Eden空间、From Survivor、To Survivor空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5Cbe3068102e8b466ca9179822e3aa91db%5C%EF%BF%BD%E6%9E%84.png" alt="img"></p><p>上图所示的 eden区、s0区、s1区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden区-&gt;Survivor 区后对象的初始年龄变为1)，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。</p><h3 id="1-5-方法区"><a href="#1-5-方法区" class="headerlink" title="1.5. 方法区"></a>1.5. 方法区</h3><p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做 <strong>Non-Heap（非堆）</strong>，目的应该是与 Java 堆区分开来。</p><p>方法区也被称为永久代。很多人都会分不清方法区和永久代的关系，为此我也查阅了文献。</p><h4 id="1-5-1-方法区和永久代的关系"><a href="#1-5-1-方法区和永久代的关系" class="headerlink" title="1.5.1. 方法区和永久代的关系"></a>1.5.1. 方法区和永久代的关系</h4><p>《Java虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 <strong>方法区和永久代的关系很像Java中接口和类的关系，类实现了接口，而永久代就是HotSpot虚拟机对虚拟机规范中方法区的一种实现方式。</strong> 也就是说，永久代是HotSpot的概念，方法区是Java虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久带这一说法。</p><p>1.5.2. 常用参数</p><p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小</p><ul><li>-XX:PermSize=N <em>//方法区(永久代)初始大小</em></li><li>-XX:MaxPermSize=N <em>//方法区(永久代)最大大小,超过这个值将会抛出OutOfMemoryError异常:java.lang.OutOfMemoryError: PermGen</em></li></ul><p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。**</p><p>JDK 1.8 的时候，方法区（HotSpot的永久代）被彻底移除了（JDK1.7就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p><p>下面是一些常用参数：</p><ul><li>-XX:MetaspaceSize=N <em>//设置Metaspace的初始（和最小大小）</em></li><li>-XX:MaxMetaspaceSize=N <em>//设置Metaspace的最大大小</em></li></ul><p>与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</p><h3 id="1-5-3-为什么要将永久代-PermGen-替换为元空间-MetaSpace-呢"><a href="#1-5-3-为什么要将永久代-PermGen-替换为元空间-MetaSpace-呢" class="headerlink" title="1.5.3. 为什么要将永久代(PermGen)替换为元空间(MetaSpace)呢?"></a>1.5.3. 为什么要将永久代(PermGen)替换为元空间(MetaSpace)呢?</h3><p>整个永久代有一个 JVM 本身设置固定大小上线，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，并且永远不会得到java.lang.OutOfMemoryError。你可以使用 -XX：MaxMetaspaceSize 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。-XX：MetaspaceSize 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</p><p>当然这只是其中一个原因，还有很多底层的原因，这里就不提了。</p><h2 id="1-6-运行时常量池"><a href="#1-6-运行时常量池" class="headerlink" title="1.6. 运行时常量池"></a>1.6. 运行时常量池</h2><p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）</p><p>既然运行时常量池时方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 异常。</p><p><strong>JDK1.7及之后版本的 JVM 已经将运行时常量池从方法区中移了出来，在 Java 堆（Heap）中开辟了一块区域存放运行时常量池。</strong></p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5C2b4e74c84e664cb5b8cea81e9ed69559%5Caf2668940c9.jpeg" alt="img"></p><p>1.7. 直接内存</p><p><strong>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 异常出现。</strong></p><p>JDK1.4 中新加入的 <strong>NIO(New Input/Output) 类</strong>，引入了一种基于<strong>通道（Channel）</strong> 与<strong>缓存区（Buffer）</strong> 的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为<strong>避免了在 Java 堆和 Native 堆之间来回复制数据</strong>。</p><p>本机直接内存的分配不会收到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p><ol start="2"><li><h2 id="说一下Java对象的创建过程-1"><a href="#说一下Java对象的创建过程-1" class="headerlink" title="说一下Java对象的创建过程"></a>说一下Java对象的创建过程</h2></li></ol><p>下图便是 Java 对象的创建过程，能默写出来，并且要掌握每一步在做什么。</p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5C7cddb02da1d94425bb432e91cbdda939%5C4398e97981a2.png" alt="img"></p><p><strong>①类加载检查：</strong> 虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p><p><strong>②分配内存：</strong> 在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择那种分配方式由 Java 堆是否规整决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p><p><strong>内存分配的两种方式：（补充内容，需要掌握）</strong></p><p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”（也称作”标记-压缩”），值得注意的是，复制算法内存也是规整的</p><p><img src="https://images.xiaozhuanlan.com/photo/2019/3af6db384fba7d42e2f9a07fb57b72d8." alt="img"></p><p><strong>内存分配并发问题（补充内容，需要掌握）</strong></p><p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p><ul><li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li><li><strong>TLAB：</strong> 为每一个线程预先在Eden区分配一块儿内存，JVM在给线程中的对象分配内存时，首先在TLAB分配，当对象大于TLAB中的剩余内存或TLAB的内存已用尽时，再采用上述的CAS进行内存分配</li></ul><p><strong>③初始化零值：</strong> 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p><p><strong>④设置对象头：</strong> 初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是那个类的实例、如何才能找到类的元数据信息、对象的哈希吗、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><p><strong>⑤执行 init 方法：</strong> 在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<init> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <init> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p><h1 id="对象的访问定位有哪两种方式-1"><a href="#对象的访问定位有哪两种方式-1" class="headerlink" title="对象的访问定位有哪两种方式?"></a>对象的访问定位有哪两种方式?</h1><p>建立对象就是为了使用对象，我们的Java程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式有虚拟机实现而定，目前主流的访问方式有<strong>①使用句柄</strong>和<strong>②直接指针</strong>两种：</p><ol><li><strong>句柄：</strong> 如果使用句柄的话，那么Java堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</li></ol><p><img src="E:%5CShellExt%5Cerer961115@163.com%5Ce713448bd51e4b2095b0de0348dc3f19%5C43d409f620d7.png" alt="img"></p><p>使用句柄</p><ol><li><strong>直接指针：</strong> 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而reference 中存储的直接就是对象的地址。</li></ol><p><img src="E:%5CShellExt%5Cerer961115@163.com%5Cf96527506f10480dbc1041afa9f36c19%5Cbdeea7311ac5.png" alt="img"></p><p>使用直接指针</p><p><strong>这两种对象访问方式各有优势。使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</strong></p><h2 id="说一下堆内存中对象的分配的基本策略-1"><a href="#说一下堆内存中对象的分配的基本策略-1" class="headerlink" title="说一下堆内存中对象的分配的基本策略"></a>说一下堆内存中对象的分配的基本策略</h2><p><strong>堆空间的基本结构：</strong></p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5Cbe3068102e8b466ca9179822e3aa91db%5C%EF%BF%BD%E6%9E%84.png" alt="img"></p><p>上图所示的 eden区、s0区、s1区都属于新生代，tentired 区属于老年代。大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden区-&gt;Survivor 区后对象的初始年龄变为1)，当它的年龄增加到一定程度（默认为15岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 -XX:MaxTenuringThreshold 来设置。</p><p>另外，大对象和长期存活的对象会直接进入老年代。</p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5C57189882e1e04b44b231aae456b14727%5C1f92d493b8d.jpeg" alt="img"></p><p>堆内存常见分配策略</p><h2 id="Minor-Gc和Full-GC-有什么不同呢？-1"><a href="#Minor-Gc和Full-GC-有什么不同呢？-1" class="headerlink" title="Minor Gc和Full GC 有什么不同呢？"></a>Minor Gc和Full GC 有什么不同呢？</h2><p>大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p><ul><li><strong>新生代GC（Minor GC）</strong>:指发生新生代的的垃圾收集动作，Minor GC非常频繁，回收速度一般也比较快。</li><li><strong>老年代GC（Major GC/Full GC）</strong>:指发生在老年代的GC，出现了Major GC经常会伴随至少一次的Minor GC（并非绝对），Major GC的速度一般会比Minor GC的慢10倍以上。</li></ul><h2 id="如何判断对象是否死亡-两种方法"><a href="#如何判断对象是否死亡-两种方法" class="headerlink" title="如何判断对象是否死亡?(两种方法)"></a>如何判断对象是否死亡?(两种方法)</h2><p>堆中几乎放着所有的对象实例，对<strong>堆垃圾回收前的第一步就是要判断那些对象</strong>已经死亡<strong>（即不能再被任何途径使用的对象）</strong>。</p><p>6.1. <strong>引用计数法</strong></p><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。</p><p>6.2. 可达性分析算法</p><p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5C2dcb569d76504857b28aa02e1ff0d983%5C7538256a5a1.jpeg" alt="img"></p><p>可达性分析算法</p><h3 id="简单的介绍一下强引用-软引用-弱引用-虚引用"><a href="#简单的介绍一下强引用-软引用-弱引用-虚引用" class="headerlink" title="简单的介绍一下强引用,软引用,弱引用,虚引用"></a>简单的介绍一下强引用,软引用,弱引用,虚引用</h3><p><strong>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关</strong>。</p><p>JDK1.2之前，Java中引用的定义很传统：如果reference类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</p><p>JDK1.2以后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p><p>7.1. <strong>强引用(</strong>StrongReference)</p><p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p><p>7.2. 软引用(SoftReference)</p><p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><p>7.3. 弱引用(WeakReference)</p><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><p><strong>4．虚引用（PhantomReference）</strong></p><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> <strong>虚引用必须和引用队列（ReferenceQueue）联合使用</strong>。当垃 圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>特别注意，在程序设计中一般很少使用弱引用与虚引用，<strong>使用软引用的情况较多</strong>，这是因为<strong>软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p><p>\6. 如何判断对象是否死亡?(两种方法)</p><p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断那些对象已经死亡（即不能再被任何途径使用的对象）。</p><p>6.1. 引用计数法</p><p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加1；当引用失效，计数器就减1；任何时候计数器为0的对象就是不可能再被使用的。</p><p>6.2. 可达性分析算法</p><p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5C2dcb569d76504857b28aa02e1ff0d983%5C7538256a5a1.jpeg" alt="img"></p><p>可达性分析算法</p><p>\7. 简单的介绍一下强引用,软引用,弱引用,虚引用</p><p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</p><p>JDK1.2之前，Java中引用的定义很传统：如果reference类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</p><p>JDK1.2以后，Java对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p><p>7.1. 强引用(StrongReference)</p><p>以前我们使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，那就类似于<strong>必不可少的生活用品</strong>，垃圾回收器绝不会回收它。当内存空 间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不会靠随意回收具有强引用的对象来解决内存不足问题。</p><p>7.2. 软引用(SoftReference)</p><p>如果一个对象只具有软引用，那就类似于<strong>可有可无的生活用品</strong>。如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><p>软引用可以和一个引用队列（ReferenceQueue）联合使用，如果软引用所引用的对象被垃圾回收，JAVA虚拟机就会把这个软引用加入到与之关联的引用队列中。</p><p>7.3. 弱引用(WeakReference)</p><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p><p><strong>4．虚引用（PhantomReference）</strong></p><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。当垃 圾回收器准备回收一个对象时，如果发现它还有虚引用，就会在回收对象的内存之前，把这个虚引用加入到与之关联的引用队列中。程序可以通过判断引用队列中是 否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。程序如果发现某个虚引用已经被加入到引用队列，那么就可以在所引用的对象的内存被回收之前采取必要的行动。</p><p>特别注意，在程序设计中一般很少使用弱引用与虚引用，使用软引用的情况较多，这是因为<strong>软引用可以加速JVM对垃圾内存的回收速度，可以维护系统的运行安全，防止内存溢出（OutOfMemory）等问题的产生</strong>。</p><h2 id="如何判断一个类是无用的类"><a href="#如何判断一个类是无用的类" class="headerlink" title="如何判断一个类是无用的类?"></a>如何判断一个类是无用的类?</h2><p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p><p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面3个条件才能算是 <strong>“无用的类”</strong> ：</p><ul><li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>加载该类的 ClassLoader 已经被回收。</li><li>该类对应的 java.lang.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><p>虚拟机可以对满足上述3个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p><h2 id="垃圾收集有哪些算法，各自的特点？"><a href="#垃圾收集有哪些算法，各自的特点？" class="headerlink" title="垃圾收集有哪些算法，各自的特点？"></a>垃圾收集有哪些算法，各自的特点？</h2><p><img src="E:%5CShellExt%5Cerer961115@163.com%5C6151934979524574b218ecaf3644e885%5C59463b05491.jpeg" alt="img"></p><h1 id="垃圾收集算法分类"><a href="#垃圾收集算法分类" class="headerlink" title="垃圾收集算法分类"></a>垃圾收集算法分类</h1><h3 id="10-1-标记-清除算法"><a href="#10-1-标记-清除算法" class="headerlink" title="10.1 标记-清除算法"></a>10.1 标记-清除算法</h3><p><strong>算法分为“标记”和“清除”阶段</strong>：首先标记出所有需要回收的对象，在标记完成后<strong>统一回收所有被标记的对象</strong>。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p><ol><li><strong>效率问题</strong></li><li><strong>空间问题（标记清除后会产生大量不连续的碎片）</strong></li></ol><p><img src="E:%5CShellExt%5Cerer961115@163.com%5C7e752b21ff61414d88c7429c1acca7ad%5C63707281.jpeg" alt="img"></p><p>10.2 <strong>复制算法</strong></p><p>为了解决效率问题，“复制”收集算法出现了。它可以将内存分为大小相同的两块，<strong>每次使用其中的一块</strong>。当这一块的内存<strong>使用完后</strong>，就<strong>将还存活的对象复制到另一块</strong>去，然后再把使用的空间一次清理掉。这样就使每<strong>次的内存回收都是对内存区间的一半进行回收</strong>。</p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5C10e80a93c0e745b48fe4c770788b5730%5C90984624.jpeg" alt="img"></p><h3 id="10-3-标记-整理算法"><a href="#10-3-标记-整理算法" class="headerlink" title="10.3 标记-整理算法"></a>10.3 标记-整理算法</h3><p>根据老年代的特点特出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是<strong>让所有存活的对象向一端移动</strong>，然后<strong>直接清理掉端边界以外的内存</strong>。</p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5Cfa50600f14c34156ab9364ccf2ef2d95%5Cfc477867180.jpeg" alt="img"></p><p>标记-整理算法</p><h3 id="10-4-分代收集算法"><a href="#10-4-分代收集算法" class="headerlink" title="10.4 分代收集算法"></a>10.4 分代收集算法</h3><p><strong>当前虚拟机的垃圾收集都采用分代收集算法</strong>，这种算法没有什么新的思想，只是<strong>根据对象存活周期的不同将内存分为几块。一般将java堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法</strong>。</p><p><strong>比如在新生代中，每次收集都会有大量对象死去，所以可以选择复制算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong></p><h2 id="HotSpot为什么要分为新生代和老年代？"><a href="#HotSpot为什么要分为新生代和老年代？" class="headerlink" title="HotSpot为什么要分为新生代和老年代？"></a>HotSpot为什么要分为新生代和老年代？</h2><p>主要是为了提升GC效率。上面提到的分代收集算法已经很好的解释了这个问题。</p><p>\12. 常见的垃圾回收器有那些?</p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5C6151934979524574b218ecaf3644e885%5C59463b05491.jpeg" alt="img"></p><p>垃圾收集器分类</p><p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p><p>虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为知道现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，<strong>我们能做的就是根据具体应用场景选择适合自己的垃圾收集器</strong>。试想一下：如果有一种四海之内、任何场景下都适用的完美收集器存在，那么我们的HotSpot虚拟机就不会实现那么多不同的垃圾收集器了。</p><p>12.1. <strong>Serial收集器</strong></p><p>Serial（<strong>串行）收集器收集器是最基本、历史最悠久的垃圾收集器了</strong>。大家看名字就知道这个收集器是一个单线程收集器了。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。</p><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5C562c02c6b9f144c8a81d1c30cb4a0384%5C7ae3e0fc877.jpeg" alt="img"></p><p>Serial收集器</p><p>虚拟机的设计者们当然知道Stop The World带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p><p>但是Serial收集器有没有优于其他垃圾收集器的地方呢？当然有，它<strong>简单而高效（与其他收集器的单线程相比）</strong>。Serial收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial收集器对于运行在Client模式下的虚拟机来说是个不错的选择。</p><p>12.2. ParNew收集器</p><p><strong>ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和Serial收集器完全一样。</strong></p><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5Ca02b06ea805d46869163302f082333fd%5Cf6cfec4931c.jpeg" alt="img"></p><p>ParNew收集器</p><p>它是许多运行在Server模式下的虚拟机的首要选择，除了Serial收集器外，只有它能与CMS收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p><p><strong>并行和并发概念补充：</strong></p><ul><li><strong>并行（Parallel）</strong> ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li><li><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个CPU上。</li></ul><p>12.3. Parallel Scavenge收集器</p><p>Parallel Scavenge 收集器类似于ParNew 收集器。 <strong>那么它有什么特别之处呢？</strong></p><ul><li><strong>-XX</strong>:+UseParallelGC </li><li></li><li>​    使用<strong>Parallel</strong>收集器+ 老年代串行</li><li></li><li><strong>-XX</strong>:+UseParallelOldGC</li><li></li><li>​    使用<strong>Parallel</strong>收集器+ 老年代并行</li></ul><p><strong>Parallel Scavenge收集器关注点是吞吐量（高效率的利用CPU）。CMS等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是CPU中用于运行用户代码的时间与CPU总消耗时间的比值。</strong> Parallel Scavenge收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解的话，手工优化存在的话可以选择把内存管理优化交给虚拟机去完成也是一个不错的选择。</p><p><strong>新生代采用复制算法，老年代采用标记-整理算法。</strong></p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5Ca02b06ea805d46869163302f082333fd%5Cf6cfec4931c.jpeg" alt="img"></p><p>ParNew收集器</p><p>12.4. Serial Old收集器</p><p><strong>Serial收集器的老年代版本</strong>，它同样是一个单线程收集器。它主要有两大用途：一种用途是在JDK1.5以及以前的版本中与Parallel Scavenge收集器搭配使用，另一种用途是作为CMS收集器的后备方案。</p><p>12.5. Parallel Old收集器</p><p><strong>Parallel Scavenge收集器的老年代版本</strong>。使用多线程和“标记-整理”算法。在注重吞吐量以及CPU资源的场合，都可以优先考虑 Parallel Scavenge收集器和Parallel Old收集器。</p><p>12.6. CMS收集器</p><p><strong>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。它而非常符合在注重用户体验的应用上使用。</strong></p><p><strong>CMS（Concurrent Mark Sweep）收集器是HotSpot虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p><p>从名字中的<strong>Mark Sweep</strong>这两个词可以看出，CMS收集器是一种 <strong>“标记-清除”算法</strong>实现的，它的运作过程相比于前面几种垃圾收集器来说更加复杂一些。整个过程分为四个步骤：</p><ul><li><strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与root相连的对象，速度很快 ；</li><li><strong>并发标记：</strong> 同时开启GC和用户线程，用一个闭包结构去记录可达对象。但在这个阶段结束，这个闭包结构并不能保证包含当前所有的可达对象。因为用户线程可能会不断的更新引用域，所以GC线程无法保证可达性分析的实时性。所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li><strong>重新标记：</strong> 重新标记阶段就是为了修正并发标记期间因为用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段的时间稍长，远远比并发标记阶段时间短</li><li><strong>并发清除：</strong> 开启用户线程，同时GC线程开始对为标记的区域做清扫。</li></ul><p><img src="E:%5CShellExt%5Cerer961115@163.com%5Cc5c9d4c26d1f42e4af5ee3b218b0f6b6%5C5abeea41877.jpeg" alt="img"></p><p>CMS垃圾收集器</p><p>从它的名字就可以看出它是一款优秀的垃圾收集器，主要优点：<strong>并发收集、低停顿</strong>。但是它有下面三个明显的缺点：</p><ul><li><strong>对CPU资源敏感；</strong></li><li><strong>无法处理浮动垃圾；</strong></li><li><strong>它使用的回收算法-“标记-清除”算法会导致收集结束时会有大量空间碎片产生。</strong></li></ul><p>12.7. G1收集器</p><p><strong>G1 (Garbage-First)是一款面向服务器的垃圾收集器,主要针对配备多颗处理器及大容量内存的机器. 以极高概率满足GC停顿时间要求的同时,还具备高吞吐量性能特征.</strong></p><p>被视为JDK1.7中HotSpot虚拟机的一个重要进化特征。它具备一下特点：</p><ul><li><strong>并行与并发</strong>：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短Stop-The-World停顿时间。部分其他收集器原本需要停顿Java线程执行的GC动作，G1收集器仍然可以通过并发的方式让java程序继续执行。</li><li><strong>分代收集</strong>：虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但是还是保留了分代的概念。</li><li><strong>空间整合</strong>：与CMS的“标记–清理”算法不同，G1从整体来看是基于“标记整理”算法实现的收集器；从局部上来看是基于“复制”算法实现的。</li><li><strong>可预测的停顿</strong>：这是G1相对于CMS的另一个大优势，降低停顿时间是G1 和 CMS 共同的关注点，但G1 除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内。</li></ul><p>G1收集器的运作大致分为以下几个步骤：</p><ul><li><strong>初始标记</strong></li><li><strong>并发标记</strong></li><li><strong>最终标记</strong></li><li><strong>筛选回收</strong></li></ul><p><strong>G1收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region(这也就是它的名字Garbage-First的由来)</strong>。这种使用Region划分内存空间以及有优先级的区域回收方式，保证了GF收集器在有限时间内可以尽可能高的收集效率（把内存化整为零）。</p>]]></content>
    
    <summary type="html">
    
      JVM(上)
    
    </summary>
    
    
      <category term="Java 基础" scheme="http://yoursite.com/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="JVM" scheme="http://yoursite.com/tags/JVM/"/>
    
      <category term="虚拟机" scheme="http://yoursite.com/tags/%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发知识进阶(下)</title>
    <link href="http://yoursite.com/2020/05/19/Java%20%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%8B%EF%BC%89/"/>
    <id>http://yoursite.com/2020/05/19/Java%20%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%8B%EF%BC%89/</id>
    <published>2020-05-19T11:46:58.000Z</published>
    <updated>2020-05-19T14:16:59.054Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-并发知识进阶-下"><a href="#Java-并发知识进阶-下" class="headerlink" title="Java 并发知识进阶(下)"></a>Java 并发知识进阶(下)</h1><ol><li><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><p>1.1. 为什么要用线程池？<br>1.2. 实现 Runnable 接口和 Callable 接口的区别<br>1.3. 执行 execute() 方法和 submit() 方法的区别是什么呢？<br>1.4. 如何创建线程池</p></li><li><h3 id="Atomic-原子类"><a href="#Atomic-原子类" class="headerlink" title="Atomic 原子类"></a>Atomic 原子类</h3><p>2.1. 介绍一下 Atomic 原子类<br>2.2. JUC 包中的原子类是哪 4 类?<br>2.3. 讲讲 AtomicInteger 的使用<br>2.4. 能不能给我简单介绍一下 AtomicInteger 类的原理</p></li><li><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>3.1. AQS 介绍<br>3.2. AQS 原理分析<br>3.2.1. AQS 原理概览<br>3.2.2. AQS 对资源的共享方式<br>3.2.3. AQS 底层使用了模板方法模式<br>3.3. AQS 组件总结</p></li></ol><a id="more"></a><ol><li><h3 id="线程池-1"><a href="#线程池-1" class="headerlink" title="线程池"></a>线程池</h3></li></ol><p>1.1. 为什么要用线程池？</p><p>线程池提供了一种限制和管理资源（包括执行一个任务）。 每个线程池还维护一些基本统计信息，例如已完成任务的数量。</p><p>线程池的好处：</p><ul><li><strong>降低资源消耗。</strong> 通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li><strong>提高响应速度。</strong> 当任务到达时，任务可以不需要的等到线程创建就能立即执行。</li><li><strong>提高线程的可管理性。</strong> 线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h3 id="1-2-实现-Runnable-接口和-Callable-接口的区别"><a href="#1-2-实现-Runnable-接口和-Callable-接口的区别" class="headerlink" title="1.2. 实现 Runnable 接口和 Callable 接口的区别"></a>1.2. 实现 Runnable 接口和 Callable 接口的区别</h3><p>如果想让线程池执行任务的话需要实现的 Runnable 接口或 Callable 接口。 Runnable 接口或 Callable 接口实现类都可以被 ThreadPoolExecutor 或 ScheduledThreadPoolExecutor 执行。两者的区别在于 <strong>Runnable 接口不会返回结果但是 Callable 接口可以返回结果</strong>。</p><p><strong>备注：</strong> 工具类Executors可以实现Runnable对象和Callable对象之间的相互转换。（Executors.callable（Runnable task）或Executors.callable（Runnable task，Object resule））。</p><h3 id="1-3-执行-execute-方法和-submit-方法的区别是什么呢？"><a href="#1-3-执行-execute-方法和-submit-方法的区别是什么呢？" class="headerlink" title="1.3. 执行 execute() 方法和 submit() 方法的区别是什么呢？"></a>1.3. 执行 execute() 方法和 submit() 方法的区别是什么呢？</h3><p>1)<strong>execute()</strong> <strong>方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</strong></p><p>2)<strong>submit()</strong> <strong>方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功</strong>，并且可以通过 future 的 get() 方法来获取返回值，get() 方法会阻塞当前线程直到任务完成，而使用 get（long timeout，TimeUnit unit）方法则会阻塞当前线程一段时间后立即返回，这时候有可能任务没有执行完。</p><h3 id="1-4-如何创建线程池"><a href="#1-4-如何创建线程池" class="headerlink" title="1.4. 如何创建线程池"></a>1.4. 如何创建线程池</h3><p>《阿里巴巴 Java 开发手册》中强制线程池不允许使用 Executors 去创建，而是通过 T<strong>hreadPoolExecutor</strong> 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险</p><p>Executors 返回线程池对象的弊端如下：</p><ul><li><strong>FixedThreadPool 和 SingleThreadExecutor</strong> ： 允许请求的队列长度为 Integer.MAX_VALUE ，可能堆积大量的请求，从而导致 OOM。</li><li><strong>CachedThreadPool 和 ScheduledThreadPool</strong> ： 允许创建的线程数量为 Integer.MAX_VALUE ，可能会创建大量线程，从而导致 OOM。</li></ul><p><strong>方式一：通过构造方法实现</strong></p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5C2e2873ea261f488fba81a89fee309981%5Ccc50caa98adb.png" alt="img"></p><p>通过构造方法实现</p><p><strong>方式二：通过 Executor 框架的工具类 Executors 来实现</strong></p><p>我们可以创建三种类型的 ThreadPoolExecutor：</p><ul><li><strong>FixedThreadPool</strong> ： 该方法返回一个固定线程数量的线程池。该线程池中的线程数量始终不变。当有一个新的任务提交时，线程池中若有空闲线程，则立即执行。若没有，则新的任务会被暂存在一个任务队列中，待有线程空闲时，便处理在任务队列中的任务。</li><li><strong>SingleThreadExecutor：</strong> 方法返回一个只有一个线程的线程池。若多余一个任务被提交到该线程池，任务会被保存在一个任务队列中，待线程空闲，按先入先出的顺序执行队列中的任务。</li><li><strong>CachedThreadPool：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。线程池的线程数量不确定，但若有空闲线程可以复用，则会优先使用可复用的线程。若所有线程均在工作，又有新的任务提交，则会创建新的线程处理任务。所有线程在当前任务执行完毕后，将返回线程池进行复用。</li></ul><p>对应 Executors 工具类中的方法如图所示：</p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5Ca417855e153e4222af3128d1280dd1d8%5C338e318ed4b7.png" alt="img"></p><p>通过 Executor 框架的工具类 Executors 来实现</p><ol start="2"><li><h4 id="Atomic-原子类-1"><a href="#Atomic-原子类-1" class="headerlink" title="Atomic 原子类"></a>Atomic 原子类</h4></li></ol><p>2.1. 介绍一下 Atomic 原子类</p><p>Atomic 翻译成中文是原子的意思。在化学上，我们知道原子是构成一般物质的最小单位，在化学反应中是不可分割的。在我们这里 Atomic 是指一个操作是不可中断的。即使是在多个线程一起执行的时候，一个操作一旦开始，就不会被其他线程干扰。</p><p>所以，所谓原子类说简单点就是具有原子/原子操作特征的类。</p><p>并发包 java.util.concurrent 的原子类都存放在java.util.concurrent.atomic下,如下图所示。</p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5C39f5c2602f4a471c8b2ba39abf041ae3%5C323d2ca6e11b.png" alt="img"></p><p>2.2. JUC 包中的原子类是哪 4 类?</p><p><strong>基本类型</strong></p><p>使用原子的方式更新基本类型</p><ul><li>AtomicInteger：整形原子类</li><li>AtomicLong：长整型原子类</li><li>AtomicBoolean：布尔型原子类</li></ul><p><strong>数组类型</strong></p><p>使用原子的方式更新数组里的某个元素</p><ul><li>AtomicIntegerArray：整形数组原子类</li><li>AtomicLongArray：长整形数组原子类</li><li>AtomicReferenceArray：引用类型数组原子类</li></ul><p><strong>引用类型</strong></p><ul><li>AtomicReference：引用类型原子类</li><li>AtomicStampedRerence：原子更新引用类型里的字段原子类</li><li>AtomicMarkableReference ：原子更新带有标记位的引用类型</li></ul><p><strong>对象的属性修改类型</strong></p><ul><li>AtomicIntegerFieldUpdater：原子更新整形字段的更新器</li><li>AtomicLongFieldUpdater：原子更新长整形字段的更新器</li><li>AtomicStampedReference：原子更新带有版本号的引用类型。该类将整数值与引用关联起来，可用于解决原子的更新数据和数据的版本号，可以解决使用 CAS 进行原子更新时可能出现的 ABA 问题。</li></ul><p>2.3. 讲讲 AtomicInteger 的使用</p><p><strong>AtomicInteger 类常用方法</strong></p><ul><li><strong>public</strong> <strong>final</strong> <strong>int</strong> <strong>get</strong>() <em>//获取当前的值</em></li><li><strong>public</strong> <strong>final</strong> <strong>int</strong> <strong>getAndSet</strong>(<strong>int</strong> newValue)<em>//获取当前的值，并设置新的值</em></li><li><strong>public</strong> <strong>final</strong> <strong>int</strong> <strong>getAndIncrement</strong>()<em>//获取当前的值，并自增</em></li><li><strong>public</strong> <strong>final</strong> <strong>int</strong> <strong>getAndDecrement</strong>() <em>//获取当前的值，并自减</em></li><li><strong>public</strong> <strong>final</strong> <strong>int</strong> <strong>getAndAdd</strong>(<strong>int</strong> delta) <em>//获取当前的值，并加上预期的值</em></li><li><strong>boolean</strong> <strong>compareAndSet</strong>(<strong>int</strong> expect, <strong>int</strong> update) <em>//如果输入的数值等于预期值，则以原子方式将该值设置为输入值（update）</em></li><li><strong>public</strong> <strong>final</strong> <strong>void</strong> <strong>lazySet</strong>(<strong>int</strong> newValue)<em>//最终设置为 newValue,使用 lazySet 设置之后可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</em></li></ul><p><strong>AtomicInteger 类的使用示例</strong></p><p>使用 AtomicInteger 之后，不用对 increment() 方法加锁也可以保证线程安全。</p><ul><li><strong>class</strong> <strong>AtomicIntegerTest</strong> {</li><li>​        <strong>private</strong> AtomicInteger count = <strong>new</strong> AtomicInteger();</li><li>​      <em>//使用 AtomicInteger 之后，不需要对该方法加锁，也可以实现线程安全。</em></li><li>​        <strong>public</strong> <strong>void</strong> <strong>increment</strong>() {</li><li>​                  count.incrementAndGet();</li><li>​        }</li><li></li><li>​       <strong>public</strong> <strong>int</strong> <strong>getCount</strong>() {</li><li>​                <strong>return</strong> count.get();</li><li>​        }</li></ul><p>2.4. 能不能给我简单介绍一下 AtomicInteger 类的原理</p><p>AtomicInteger 线程安全原理简单分析</p><p>AtomicInteger 类的部分源码：</p><ul><li>​    <em>// setup to use Unsafe.compareAndSwapInt for updates（更新操作时提供“比较并替换”的作用）</em></li><li>​    <strong>private</strong> <strong>static</strong> <strong>final</strong> Unsafe unsafe = Unsafe.getUnsafe();</li><li>​    <strong>private</strong> <strong>static</strong> <strong>final</strong> <strong>long</strong> valueOffset;</li><li></li><li>​    <strong>static</strong> {</li><li>​        <strong>try</strong> {</li><li>​            valueOffset = unsafe.objectFieldOffset</li><li>​                (AtomicInteger.class.getDeclaredField(“value”));</li><li>​        } <strong>catch</strong> (Exception ex) { <strong>throw</strong> <strong>new</strong> Error(ex); }</li><li>​    }</li><li></li><li>​    <strong>private</strong> <strong>volatile</strong> <strong>int</strong> value;</li></ul><p>AtomicInteger 类主要利用 <strong>CAS (compare and swap) + volatile 和 native 方法来保证原子操</strong>作，从而避免 synchronized 的高开销，执行效率大为提升。</p><p>CAS 的原理是拿期望的值和原本的一个值作比较，如果相同则更新成新的值。UnSafe 类的 objectFieldOffset() 方法是一个本地方法，这个方法是用来拿到“原来的值”的内存地址，返回值是 valueOffset。另外 value 是一个 volatile 变量，在内存中可见，因此 JVM 可以保证任何时刻任何线程总能拿到该变量的最新值。</p><ol start="3"><li><h3 id="AQS-1"><a href="#AQS-1" class="headerlink" title="AQS"></a>AQS</h3></li></ol><p>3.1. AQS 介绍</p><p>AQS 的全称为（AbstractQueuedSynchronizer），这个类在 java.util.concurrent.locks 包下面。</p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5C5fe53d79aaa14509a9ec108e7271d106%5Cc5d80325e1d1.png" alt="img"></p><p>AQS</p><p>AQS 是一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的大量的同步器，比如我们提到的 ReentrantLock，Semaphore，其他的诸如 ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于 AQS 的。当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器。</p><p>3.2.1. AQS 原理概览</p><p><strong>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 CLH 队列锁实现的，即将暂时获取不到锁的线程加入到队列中。</strong></p><p>CLH(Craig,Landin,and Hagersten) 队列是一个虚拟的双向队列（虚拟的双向队列即不存在队列实例，仅存在结点之间的关联关系）。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p><p>看个 AQS(AbstractQueuedSynchronizer) 原理图：</p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5C2e207fbd972c4b4f87234880e3b4dfd7%5Cf7be5ccce6c1.png" alt="img"></p><p>AQS原理图</p><p>AQS 使用一个 int 成员变量来表示同步状态，通过内置的 FIFO 队列来完成获取资源线程的排队工作。AQS 使用 CAS 对该同步状态进行原子操作实现对其值的修改。</p><ul><li><strong>private</strong> <strong>volatile</strong> <strong>int</strong> state;<em>//共享变量，使用 volatile 修饰保证线程可见性</em></li></ul><p>状态信息通过 protected 类型的 getState，setState，compareAndSetState 进行操作</p><ul><li><em>//返回同步状态的当前值</em></li><li><strong>protected</strong> <strong>final</strong> <strong>int</strong> <strong>getState</strong>() {  </li><li>​        <strong>return</strong> state;</li><li>}</li><li><em>// 设置同步状态的值</em></li><li><strong>protected</strong> <strong>final</strong> <strong>void</strong> <strong>setState</strong>(<strong>int</strong> newState) { </li><li>​        state = newState;</li><li>}</li><li><em>//原子地（CAS 操作）将同步状态值设置为给定值 update 如果当前同步状态的值等于 expect（期望值）</em></li><li><strong>protected</strong> <strong>final</strong> <strong>boolean</strong> <strong>compareAndSetState</strong>(<strong>int</strong> expect, <strong>int</strong> update) {</li><li>​        <strong>return</strong> unsafe.compareAndSwapInt(<strong>this</strong>, stateOffset, expect, update);</li><li>}</li></ul><p>3.2.2. AQS 对资源的共享方式</p><p><strong>AQS 定义两种资源共享方式</strong></p><ul><li><p><strong>Exclusive</strong>（独占）：只有一个线程能执行，如 ReentrantLock。又可分为公平锁和非公平锁：</p></li><li><ul><li>公平锁：按照线程在队列中的排队顺序，先到者先拿到锁</li><li>非公平锁：当线程要获取锁时，无视队列顺序直接去抢锁，谁抢到就是谁的</li></ul></li><li><p><strong>Share</strong>（共享）：多个线程可同时执行，如 Semaphore/CountDownLatch。Semaphore、CountDownLatch、 CyclicBarrier、ReadWriteLock 我们都会在后面讲到。</p></li></ul><p>ReentrantReadWriteLock 可以看成是组合式，因为 ReentrantReadWriteLock 也就是读写锁允许多个线程同时对某一资源进行读。</p><p>不同的自定义同步器争用共享资源的方式也不同。自定义同步器在实现时只需要实现共享资源 state 的获取与释放方式即可，至于具体线程等待队列的维护（如获取资源失败入队/唤醒出队等），AQS 已经在顶层实现好了。</p><p>3.2.3. AQS 底层使用了模板方法模式</p><p>同步器的设计是基于模板方法模式的，如果需要自定义同步器一般的方式是这样（模板方法模式很经典的一个应用）：</p><ol><li>使用者继承 AbstractQueuedSynchronizer 并重写指定的方法。（这些重写方法很简单，无非是对于共享资源 state 的获取和释放）</li><li>将 AQS 组合在自定义同步组件的实现中，并调用其模板方法，而这些模板方法会调用使用者重写的方法。</li></ol><p>这和我们以往通过实现接口的方式有很大区别，这是模板方法模式很经典的一个运用。</p><p><strong>AQS 使用了模板方法模式，自定义同步器时需要重写下面几个 AQS 提供的模板方法：</strong></p><ul><li>isHeldExclusively()<em>//该线程是否正在独占资源。只有用到 condition 才需要去实现它。</em></li><li>tryAcquire(<strong>int</strong>)<em>//独占方式。尝试获取资源，成功则返回 true，失败则返回 false。</em></li><li>tryRelease(<strong>int</strong>)<em>//独占方式。尝试释放资源，成功则返回 true，失败则返回 false。</em></li><li>tryAcquireShared(<strong>int</strong>)<em>//共享方式。尝试获取资源。负数表示失败；0 表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</em></li><li>tryReleaseShared(<strong>int</strong>)<em>//共享方式。尝试释放资源，成功则返回 true，失败则返回 false。</em></li></ul><p>默认情况下，每个方法都抛出 UnsupportedOperationException。 这些方法的实现必须是内部线程安全的，并且通常应该简短而不是阻塞。AQS 类中的其他方法都是 final ，所以无法被其他类使用，只有这几个方法可以被其他类使用。</p><p>以 ReentrantLock 为例，state 初始化为 0，表示未锁定状态。A 线程 lock() 时，会调用 tryAcquire() 独占该锁并将 state+1。此后，其他线程再 tryAcquire() 时就会失败，直到 A 线程 unlock() 到 state=0（即释放锁）为止，其它线程才有机会获取该锁。当然，释放锁之前，A 线程自己是可以重复获取此锁的（state 会累加），这就是可重入的概念。但要注意，获取多少次就要释放多么次，这样才能保证 state 是能回到零态的。</p><p>再以 CountDownLatch 以例，任务分为 N 个子线程去执行，state 也初始化为 N（注意 N 要与线程个数一致）。这 N 个子线程是并行执行的，每个子线程执行完后 countDown() 一次，state 会 CAS(Compare and Swap) 减 1。等到所有子线程都执行完后 (即 state=0)，会 unpark() 主调用线程，然后主调用线程就会从 await() 函数返回，继续后余动作。</p><p>一般来说，自定义同步器要么是独占方法，要么是共享方式，他们也只需实现tryAcquire-tryRelease、tryAcquireShared-tryReleaseShared中的一种即可。但 AQS 也支持自定义同步器同时实现独占和共享两种方式，如ReentrantReadWriteLock。     </p><p>3.3. AQS 组件总结</p><ul><li><strong>Semaphore(信号量)-允许多个线程同时访问：</strong> synchronized 和 ReentrantLock 都是一次只允许一个线程访问某个资源，Semaphore(信号量) 可以指定多个线程同时访问某个资源。</li><li><strong>CountDownLatch （倒计时器）：</strong> CountDownLatch 是一个同步工具类，用来协调多个线程之间的同步。这个工具通常用来控制线程等待，它可以让某一个线程等待直到倒计时结束，再开始执行。</li><li><strong>CyclicBarrier(循环栅栏)：</strong> CyclicBarrier 和 CountDownLatch 非常类似，它也可以实现线程间的技术等待，但是它的功能比 CountDownLatch 更加复杂和强大。主要应用场景和 CountDownLatch 类似。CyclicBarrier 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。它要做的事情是，让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续干活。CyclicBarrier 默认的构造方法是 CyclicBarrier(int parties)，其参数表示屏障拦截的线程数量，每个线程调用 await() 方法告诉 CyclicBarrier 我已经到达了屏障，然后当前线程被阻塞。</li></ul>]]></content>
    
    <summary type="html">
    
      Java 并发基础知识 （下）
    
    </summary>
    
    
      <category term="Java 基础" scheme="http://yoursite.com/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发知识进阶(中)</title>
    <link href="http://yoursite.com/2020/05/19/Java%20%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%AD%EF%BC%89/"/>
    <id>http://yoursite.com/2020/05/19/Java%20%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%AD%EF%BC%89/</id>
    <published>2020-05-19T10:46:58.000Z</published>
    <updated>2020-05-19T11:37:40.137Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-并发知识进阶-中"><a href="#Java-并发知识进阶-中" class="headerlink" title="Java 并发知识进阶(中)"></a>Java 并发知识进阶(中)</h1><ol><li><h4 id="synchronized-关键字"><a href="#synchronized-关键字" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h4><p>1.1. 说一说自己对于 synchronized 关键字的了解<br>1.2. 说说自己是怎么使用 synchronized 关键字，在项目中用到了吗<br>1.3. 讲一下 synchronized 关键字的底层原理<br>1.4. 说说 JDK1.6 之后的synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗<br>1.5. 谈谈 synchronized和ReentrantLock 的区别</p></li><li><h4 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h4><p>2.1. 讲一下Java内存模型<br>2.2. 说说 synchronized 关键字和 volatile 关键字的区别</p></li><li><h4 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h4><p>3.1. ThreadLocal简介<br>3.2. ThreadLocal示例<br>3.3. ThreadLocal原理<br>3.4. ThreadLocal 内存泄露问题</p></li></ol><a id="more"></a><h2 id="synchronized-关键字-1"><a href="#synchronized-关键字-1" class="headerlink" title="synchronized 关键字"></a>synchronized 关键字</h2><p>1.1. 说一说自己对于 synchronized 关键字的了解</p><p>synchronized关键字<strong>解决</strong>的是<strong>多个线程之间访问资源的同步性</strong>，synchronized关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p><p>另外，在 Java <strong>早期版本中，synchronized属于重量级锁，效率低下，因为监视器锁（monitor）是依赖于底层的操作系统的 Mutex Lock</strong> 来实现的，Java 的线程是映射到操作系统的<strong>原生线程之上</strong>的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状<strong>态之间的转换</strong>需要<strong>相对比较长的时间，时间成本相对较高</strong>，这也是为什么早期的 synchronized 效率低的原因。庆幸的是在 <strong>Java 6</strong> 之后 <strong>Java 官方对从 JVM 层面对synchronized 较大优化</strong>，所以现在的 <strong>synchronized 锁效率也优化得很不错了</strong>。JDK1.6对锁的实现<strong>引入了大量的优化，如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销</strong></p><h3 id="1-2-说说自己是怎么使用-synchronized-关键字，在项目中用到了吗"><a href="#1-2-说说自己是怎么使用-synchronized-关键字，在项目中用到了吗" class="headerlink" title="1.2. 说说自己是怎么使用 synchronized 关键字，在项目中用到了吗"></a>1.2. 说说自己是怎么使用 synchronized 关键字，在项目中用到了吗</h3><p><strong>synchronized关键字最主要的三种使用方式：</strong></p><ul><li><strong>修饰实例方法:</strong> 作用于当前对象实例加锁，进入同步代码前要获得当前对象实例的锁</li><li><strong>修饰静态方法:</strong> :也就是给当前类加锁，会作用于类的所有对象实例，因为静态成员不属于任何一个实例对象，是类成员（ static 表明这是该类的一个静态资源，不管new了多少个对象，只有一份）。所以如果一个线程A调用一个实例对象的非静态 synchronized 方法，而线程B需要调用这个实例对象所属类的静态 synchronized 方法，是允许的，不会发生互斥现象，<strong>因为访问静态 synchronized 方法占用的锁是当前类的锁，而访问非静态 synchronized 方法占用的锁是当前实例对象锁</strong>。</li><li><strong>修饰代码块:</strong> 指定加锁对象，对给定对象加锁，进入同步代码库前要获得给定对象的锁。</li></ul><p><strong>总结：</strong> synchronized 关键字加到 static 静态方法和 synchronized(class)代码块上都是是给 Class 类上锁。synchronized 关键字加到实例方法上是给对象实例上锁。尽量不要使用 synchronized(String a) 因为JVM中，字符串常量池具有缓存功能！</p><p><strong>双重校验锁实现对象单例（线程安全）</strong></p><ul><li><strong>public</strong> <strong>class</strong> <strong>Singleton</strong> {</li><li></li><li>​    <strong>private</strong> <strong>volatile</strong> <strong>static</strong> Singleton uniqueInstance;</li><li></li><li>​    <strong>private</strong> <strong>Singleton</strong>() {</li><li>​    }</li><li></li><li>​    <strong>public</strong> <strong>static</strong> Singleton <strong>getUniqueInstance</strong>() {</li><li>​       <em>//先判断对象是否已经实例过，没有实例化过才进入加锁代码</em></li><li>​        <strong>if</strong> (uniqueInstance == <strong>null</strong>) {</li><li>​            <em>//类对象加锁</em></li><li>​            <strong>synchronized</strong> (Singleton.class) {</li><li>​                <strong>if</strong> (uniqueInstance == <strong>null</strong>) {</li><li>​                    uniqueInstance = <strong>new</strong> Singleton();</li><li>​                }</li><li>​            }</li><li>​        }</li><li>​        <strong>return</strong> uniqueInstance;</li><li>​    }</li><li>}</li></ul><p>另外，需要注意 uniqueInstance 采用 volatile 关键字修饰也是很有必要。</p><p>uniqueInstance 采用 volatile 关键字修饰也是很有必要的， uniqueInstance = new Singleton(); 这段代码其实是分为三步执行：</p><ol><li>为 uniqueInstance 分配内存空间</li><li>初始化 uniqueInstance</li><li>将 uniqueInstance 指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。指令重排在单线程环境下不会出先问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 getUniqueInstance() 后发现 uniqueInstance 不为空，因此返回 uniqueInstance，但此时 uniqueInstance 还未被初始化。</p><p>使用 <strong>volatile 可以禁止 JVM 的指令重排</strong>，保证在多线程环境下也能正常运行。</p><h3 id="1-3-讲一下-synchronized-关键字的底层原理"><a href="#1-3-讲一下-synchronized-关键字的底层原理" class="headerlink" title="1.3. 讲一下 synchronized 关键字的底层原理"></a>1.3. 讲一下 synchronized 关键字的底层原理</h3><p><strong>synchronized 关键字底层原理属于 JVM 层面。</strong></p><p><strong>① synchronized 同步语句块的情况</strong></p><ul><li><strong>public</strong> <strong>class</strong> <strong>SynchronizedDemo</strong> {</li><li>​    <strong>public</strong> <strong>void</strong> <strong>method</strong>() {</li><li>​        <strong>synchronized</strong> (<strong>this</strong>) {</li><li>​            System.out.println(“synchronized 代码块”);</li><li>​        }</li><li>​    }</li><li>}</li></ul><p>通过 JDK 自带的 javap 命令查看 SynchronizedDemo 类的相关字节码信息：首先切换到类的对应目录执行 javac SynchronizedDemo.java 命令生成编译后的 .class 文件，然后执行javap -c -s -v -l SynchronizedDemo.class。</p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5C7980bdb3d409483ea4a111231c23c3c7%5C0489278e1a5d.png" alt="img"></p><p>从上面我们可以看出：</p><p><strong>synchronized 同步语句块的实现使用的是 monitorenter 和 monitorexit 指令，其中 monitorenter 指令指向同步代码块的开始位置，monitorexit 指令则指明同步代码块的结束位置。</strong> 当执行 monitorenter 指令时，线程试图获取锁也就是获取 monitor(monitor对象存在于每个Java对象的对象头中，synchronized 锁便是通过这种方式获取锁的，也是为什么Java中任意对象可以作为锁的原因) 的持有权。当计数器为0则可以成功获取，获取后将锁计数器设为1也就是加1。相应的在执行 monitorexit 指令后，将锁计数器设为0，表明锁被释放。如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p><p><strong>② synchronized 修饰方法的的情况</strong></p><ul><li><strong>public</strong> <strong>class</strong> <strong>SynchronizedDemo2</strong> {</li><li>​    <strong>public</strong> <strong>synchronized</strong> <strong>void</strong> <strong>method</strong>() {</li><li>​        System.out.println(“synchronized 方法”);</li><li>​    }</li><li>}</li></ul><p><img src="E:%5CShellExt%5Cerer961115@163.com%5C2d1c1d8ade924f21ab3da430fe3b680f%5Ced03d7f570b8.png" alt="img"></p><p>synchronized关键字原理</p><p>synchronized 修饰的方法并没有 monitorenter 指令和 monitorexit 指令，取得代之的确实是 ACC_SYNCHRONIZED 标识，该标识指明了该方法是一个同步方法，JVM 通过该 ACC_SYNCHRONIZED 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。</p><p>1.4. 说说 JDK1.6 之后的synchronized 关键字底层做了哪些优化，可以详细介绍一下这些优化吗</p><p>JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。</p><p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p><p><strong>①偏向锁</strong></p><p><strong>引入偏向锁的目的和引入轻量级锁的目的很像，他们都是为了没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。但是不同是：轻量级锁在无竞争的情况下使用 CAS 操作去代替使用互斥量。而偏向锁在无竞争的情况下会把整个同步都消除掉</strong>。</p><p><strong>② 轻量级锁</strong></p><p>倘若偏向锁失败，虚拟机并不会立即升级为重量级锁，它还会尝试使用一种称为轻量级锁的优化手段(1.6之后加入的)。<strong>轻量级锁不是为了代替重量级锁，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗，因为使用轻量级锁时，不需要申请互斥量。另外，轻量级锁的加锁和解锁都用到了CAS操作。</strong></p><p><strong>③ 自旋锁和自适应自旋</strong></p><p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。</p><p>互斥同步对性能最大的影响就是阻塞的实现，因为挂起线程/恢复线程的操作都需要转入内核态中完成（用户态转换到内核态会耗费时间）。</p><p><strong>一般线程持有锁的时间都不是太长，所以仅仅为了这一点时间去挂起线程/恢复线程是得不偿失的。</strong> 所以，虚拟机的开发团队就这样去考虑：“我们能不能让后面来的请求获取锁的线程等待一会而不被挂起呢？看看持有锁的线程是否很快就会释放锁”。<strong>为了让一个线程等待，我们只需要让线程执行一个忙循环（自旋），这项技术就叫做自旋</strong>。自旋次数的默认值是10次，用户可以修改<code>--XX:PreBlockSpin</code>来更改。<strong>在 JDK1.6 中引入了自适应的自旋锁。自适应的自旋锁带来的改进就是：自旋的时间不在固定了，而是和前一次同一个锁上的自旋时间以及锁的拥有者的状态来决定</strong></p><p><strong>④ 锁消除</strong></p><p>锁消除理解起来很简单，它指的就是虚拟机即使编译器在运行时，如果检测到那些共享数据不可能存在竞争，那么就执行锁消除。锁消除可以节省毫无意义的请求锁的时间。</p><p><strong>⑤ 锁粗化</strong></p><p>原则上，我们再编写代码的时候，总是推荐将同步快的作用范围限制得尽量小——只在共享数据的实际作用域才进行同步，这样是为了使得需要同步的操作数量尽可能变小，如果存在锁竞争，那等待线程也能尽快拿到锁。</p><h4 id="1-5-谈谈-synchronized和ReentrantLock-的区别"><a href="#1-5-谈谈-synchronized和ReentrantLock-的区别" class="headerlink" title="1.5. 谈谈 synchronized和ReentrantLock 的区别"></a>1.5. 谈谈 synchronized和ReentrantLock 的区别</h4><p><strong>① 两者都是可重入锁</strong></p><p>两者都是可重入锁。“可重入锁”概念是：自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果不可锁重入的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增1，所以要等到锁的计数器下降为0时才能释放锁。</p><p><strong>② synchronized 依赖于 JVM 而 ReenTrantLock 依赖于 API</strong></p><p>synchronized 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 synchronized 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。ReenTrantLock 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。</p><p><strong>③ ReenTrantLock 比 synchronized 增加了一些高级功能</strong></p><p>相比synchronized，ReenTrantLock增加了一些高级功能。主要来说主要有三点：<strong>①等待可中断；②可实现公平锁；③可实现选择性通知（锁可以绑定多个条件）</strong></p><ul><li><strong>ReenTrantLock提供了一种能够中断等待锁的线程的机制</strong>，通过lock.lockInterruptibly()来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li><strong>ReenTrantLock可以指定是公平锁还是非公平锁。而synchronized只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。</strong> ReenTrantLock默认情况是非公平的，可以通过 ReenTrantLock类的<code>ReentrantLock(boolean fair)</code>构造方法来制定是否是公平的。</li><li>synchronized关键字与wait()和notify/notifyAll()方法相结合可以实现等待/通知机制，ReentrantLock类当然也可以实现，但是需要借助于Condition接口与newCondition() 方法。Condition是JDK1.5之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个Lock对象中可以创建多个Condition实例（即对象监视器），<strong>线程对象可以注册在指定的Condition中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用notify/notifyAll()方法进行通知时，被通知的线程是由 JVM 选择的，用ReentrantLock类结合Condition实例可以实现“选择性通知”</strong> ，这个功能非常重要，而且是Condition接口默认提供的。而synchronized关键字就相当于整个Lock对象中只有一个Condition实例，所有的线程都注册在它一个身上。如果执行notifyAll()方法的话就会通知所有处于等待状态的线程这样会造成很大的效率问题，而Condition实例的signalAll()方法 只会唤醒注册在该Condition实例中的所有等待线程。</li></ul><p>如果你想使用上述功能，那么选择ReenTrantLock是一个不错的选择。</p><p><strong>④ 性能已不是选择标准</strong></p><p>在JDK1.6之前，synchronized 的性能是比 ReenTrantLock 差很多。具体表示为：synchronized 关键字吞吐量岁线程数的增加，下降得非常严重。而ReenTrantLock 基本保持一个比较稳定的水平。我觉得这也侧面反映了， synchronized 关键字还有非常大的优化余地。后续的技术发展也证明了这一点，我们上面也讲了在 JDK1.6 之后 JVM 团队对 synchronized 关键字做了很多优化。<strong>JDK1.6 之后，synchronized 和 ReenTrantLock 的性能基本是持平了。所以网上那些说因为性能才选择 ReenTrantLock 的文章都是错的！JDK1.6之后，性能已经不是选择synchronized和ReenTrantLock的影响因素了！而且虚拟机在未来的性能改进中会更偏向于原生的synchronized，所以还是提倡在synchronized能满足你的需求的情况下，优先考虑使用synchronized关键字来进行同步！优化后的synchronized和ReenTrantLock一样，在很多地方都是用到了CAS操作</strong>。</p><h3 id="2-volatile关键字"><a href="#2-volatile关键字" class="headerlink" title="2. volatile关键字"></a>2. volatile关键字</h3><h6 id="2-1-讲一下Java内存模型"><a href="#2-1-讲一下Java内存模型" class="headerlink" title="2.1. 讲一下Java内存模型"></a>2.1. 讲一下Java内存模型</h6><p>在 JDK1.2 之前，Java的内存模型实现总是从<strong>主存</strong>（即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存<strong>本地内存</strong>比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成<strong>数据的不一致</strong>。</p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5Cb58d03d6a8724825862e51db7a075934%5Cf1728707cd89.png" alt="img"></p><p>要解决这个问题，就需要把变量声明为<strong>volatile</strong>，这就指示 JVM，这个变量是不稳定的，每次使用它都到主存中进行读取。</p><p>说白了， <strong>volatile</strong> 关键字的主要作用就是保证变量的可见性然后还有一个作用是防止指令重排序。</p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5Cf014b61ab7004fbaa9a44e4e5c34c548%5Ce48528714ce5.png" alt="img"></p><h5 id="2-2-说说-synchronized-关键字和-volatile-关键字的区别"><a href="#2-2-说说-synchronized-关键字和-volatile-关键字的区别" class="headerlink" title="2.2. 说说 synchronized 关键字和 volatile 关键字的区别"></a>2.2. 说说 synchronized 关键字和 volatile 关键字的区别</h5><p>synchronized关键字和volatile关键字比较</p><ul><li><strong>volatile关键字</strong>是线程同步的<strong>轻量级实现</strong>，所以<strong>volatile性能肯定比synchronized关键字要好</strong>。但是<strong>volatile关键字只能用于变量而synchronized关键字可以修饰方法以及代码块</strong>。synchronized关键字在JavaSE1.6之后进行了主要包括为了减少获得锁和释放锁带来的性能消耗而引入的偏向锁和轻量级锁以及其它各种优化之后执行效率有了显著提升，<strong>实际开发中使用 synchronized 关键字的场景还是更多一些</strong>。</li><li><strong>多线程访问volatile关键字不会发生阻塞，而synchronized关键字可能会发生阻塞</strong></li><li><strong>volatile关键字能保证数据的可见性，但不能保证数据的原子性。synchronized关键字两者都能保证。</strong></li><li><strong>volatile关键字主要用于解决变量在多个线程之间的可见性，而 synchronized关键字解决的是多个线程之间访问资源的同步性。</strong></li></ul><h6 id="3-ThreadLocal"><a href="#3-ThreadLocal" class="headerlink" title="3. ThreadLocal"></a>3. ThreadLocal</h6><p>3.1. ThreadLocal简介</p><p>通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。<strong>如果想实现每一个线程都有自己的专属本地变量该如何解决呢？</strong> JDK中提供的ThreadLocal类正是为了解决这样的问题。 <strong>ThreadLocal</strong>类主要解决的就是让每个线程绑定自己的值，可以将<strong>ThreadLocal</strong>类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。</p><p><strong>如果你创建了一个ThreadLocal</strong>变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是<strong>ThreadLocal变量名的由来。他们可以使用</strong> <strong>get（）</strong> <strong>和</strong> <strong>set（）</strong> <strong>方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。</strong></p><p>再举个简单的例子：</p><p>比如有两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么ThreadLocal就是用来这两个线程竞争的。</p><p>3.2. ThreadLocal示例</p><p>相信看了上面的解释，大家已经搞懂 ThreadLocal 类是个什么东西了。</p><ul><li><strong>import</strong> java.text.SimpleDateFormat;</li><li><strong>import</strong> java.util.Random;</li><li></li><li><strong>public</strong> <strong>class</strong> <strong>ThreadLocalExample</strong> <strong>implements</strong> <strong>Runnable</strong>{</li><li></li><li>​     <em>// SimpleDateFormat 不是线程安全的，所以每个线程都要有自己独立的副本</em></li><li>​    <strong>private</strong> <strong>static</strong> <strong>final</strong> ThreadLocal<SimpleDateFormat> formatter = ThreadLocal.withInitial(() -&gt; <strong>new</strong> SimpleDateFormat(“yyyyMMdd HHmm”));</li><li></li><li>​    <strong>public</strong> <strong>static</strong> <strong>void</strong> <strong>main</strong>(String[] args) <strong>throws</strong> InterruptedException {</li><li>​        ThreadLocalExample obj = <strong>new</strong> ThreadLocalExample();</li><li>​        <strong>for</strong>(<strong>int</strong> i=0 ; i&lt;10; i++){</li><li>​            Thread t = <strong>new</strong> Thread(obj, “”+i);</li><li>​            Thread.sleep(<strong>new</strong> Random().nextInt(1000));</li><li>​            t.start();</li><li>​        }</li><li>​    }</li><li></li><li>​    <strong>@Override</strong></li><li>​    <strong>public</strong> <strong>void</strong> <strong>run</strong>() {</li><li>​        System.out.println(“Thread Name= “+Thread.currentThread().getName()+” default Formatter = “+formatter.get().toPattern());</li><li>​        <strong>try</strong> {</li><li>​            Thread.sleep(<strong>new</strong> Random().nextInt(1000));</li><li>​        } <strong>catch</strong> (InterruptedException e) {</li><li>​            e.printStackTrace();</li><li>​        }</li><li>​        <em>//formatter pattern is changed here by thread, but it won’t reflect to other threads</em></li><li>​        formatter.set(<strong>new</strong> SimpleDateFormat());</li><li></li><li>​        System.out.println(“Thread Name= “+Thread.currentThread().getName()+” formatter = “+formatter.get().toPattern());</li><li>​    }</li><li></li><li>}</li></ul><p>Output:</p><ul><li>Thread Name= 0 default Formatter = yyyyMMdd HHmm</li><li>Thread Name= 0 formatter = yy-M-d ah:mm</li><li>Thread Name= 1 default Formatter = yyyyMMdd HHmm</li><li>Thread Name= 2 default Formatter = yyyyMMdd HHmm</li><li>Thread Name= 1 formatter = yy-M-d ah:mm</li><li>Thread Name= 3 default Formatter = yyyyMMdd HHmm</li><li>Thread Name= 2 formatter = yy-M-d ah:mm</li><li>Thread Name= 4 default Formatter = yyyyMMdd HHmm</li><li>Thread Name= 3 formatter = yy-M-d ah:mm</li><li>Thread Name= 4 formatter = yy-M-d ah:mm</li><li>Thread Name= 5 default Formatter = yyyyMMdd HHmm</li><li>Thread Name= 5 formatter = yy-M-d ah:mm</li><li>Thread Name= 6 default Formatter = yyyyMMdd HHmm</li><li>Thread Name= 6 formatter = yy-M-d ah:mm</li><li>Thread Name= 7 default Formatter = yyyyMMdd HHmm</li><li>Thread Name= 7 formatter = yy-M-d ah:mm</li><li>Thread Name= 8 default Formatter = yyyyMMdd HHmm</li><li>Thread Name= 9 default Formatter = yyyyMMdd HHmm</li><li>Thread Name= 8 formatter = yy-M-d ah:mm</li><li>Thread Name= 9 formatter = yy-M-d ah:mm</li></ul><p>从输出中可以看出，Thread-0已经改变了formatter的值，但仍然是thread-2默认格式化程序与初始化值相同，其他线程也一样。</p><p>上面有一段代码用到了创建 ThreadLocal 变量的那段代码用到了 Java8 的知识，它等于下面这段代码，如果你写了下面这段代码的话，IDEA会提示你转换为Java8的格式(IDEA真的不错！)。因为ThreadLocal类在Java 8中扩展，使用一个新的方法withInitial()，将Supplier功能接口作为参数。</p><ul><li><strong>private</strong> <strong>static</strong> <strong>final</strong> ThreadLocal<SimpleDateFormat> formatter = <strong>new</strong> ThreadLocal<SimpleDateFormat>(){</li><li>​        <strong>@Override</strong></li><li>​        <strong>protected</strong> SimpleDateFormat <strong>initialValue</strong>()</li><li>​        {</li><li>​            <strong>return</strong> <strong>new</strong> SimpleDateFormat(“yyyyMMdd HHmm”);</li><li>​        }</li><li>​    };</li></ul><p>3.3. ThreadLocal原理</p><p>从 Thread类源代码入手。</p><ul><li><strong>public</strong> <strong>class</strong> <strong>Thread</strong> <strong>implements</strong> <strong>Runnable</strong> {</li><li>……</li><li><em>//与此线程有关的ThreadLocal值。由ThreadLocal类维护</em></li><li>ThreadLocal.ThreadLocalMap threadLocals = <strong>null</strong>;</li><li></li><li><em>//与此线程有关的InheritableThreadLocal值。由InheritableThreadLocal类维护</em></li><li>ThreadLocal.ThreadLocalMap inheritableThreadLocals = <strong>null</strong>;</li><li>……</li><li>}</li></ul><p>从上面Thread类 源代码可以看出Thread 类中有一个 threadLocals 和 一个 inheritableThreadLocals 变量，它们都是 ThreadLocalMap 类型的变量,我们可以把 ThreadLocalMap 理解为ThreadLocal 类实现的定制化的 HashMap。默认情况下这两个变量都是null，只有当前线程调用 ThreadLocal 类的 set或get方法时才创建它们，实际上调用这两个方法的时候，我们调用的是ThreadLocalMap类对应的 get()、set()方法。</p><p>ThreadLocal类的set()方法</p><ul><li>​    <strong>public</strong> <strong>void</strong> <strong>set</strong>(T value) {</li><li>​        Thread t = Thread.currentThread();</li><li>​        ThreadLocalMap map = getMap(t);</li><li>​        <strong>if</strong> (map != <strong>null</strong>)</li><li>​            map.set(<strong>this</strong>, value);</li><li>​        <strong>else</strong></li><li>​            createMap(t, value);</li><li>​    }</li><li>​    ThreadLocalMap <strong>getMap</strong>(Thread t) {</li><li>​        <strong>return</strong> t.threadLocals;</li><li>​    }</li></ul><p>通过上面这些内容，我们足以通过猜测得出结论：<strong>最终的变量是放在了当前线程的</strong> <strong>ThreadLocalMap</strong> <strong>中，并不是存在</strong> <strong>ThreadLocal</strong> <strong>上，ThreadLocal 可以理解为只是ThreadLocalMap的封装，传递了变量值。</strong></p><p><strong>每个Thread中都具备一个ThreadLocalMap</strong>，而<strong>ThreadLocalMap可以存储以ThreadLocal为key的键值对。这里解释了为什么每个线程访问同一个ThreadLocal</strong>，得到的确是不同的数值。另外，ThreadLocal <strong>是 map结构是为了让每个线程可以关联多个</strong> ThreadLoca变量。</p><p>ThreadLocalMap是ThreadLocal的静态内部类。</p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5C5b73319094a746b0b30eaf269a40c11e%5Cb7b2ff794db.jpeg" alt="img"></p><p>ThreadLocal内部类</p><p>3.4. ThreadLocal 内存泄露问题</p><p>ThreadLocalMap 中使用的 key 为 ThreadLocal 的弱引用,而 value 是强引用。所以，如果 ThreadLocal 没有被外部强引用的情况下，在垃圾回收的时候会 key 会被清理掉，而 value 不会被清理掉。这样一来，ThreadLocalMap 中就会出现key为null的Entry。假如我们不做任何措施的话，value 永远无法被GC 回收，这个时候就可能会产生内存泄露。ThreadLocalMap实现中已经考虑了这种情况，在调用 set()、get()、remove() 方法的时候，会清理掉 key 为 null 的记录。使用完 ThreadLocal方法后 最好手动调用remove()方法</p><ul><li>​      <strong>static</strong> <strong>class</strong> <strong>Entry</strong> <strong>extends</strong> <strong>WeakReference</strong>&lt;<strong>ThreadLocal</strong>&lt;?&gt;&gt; {</li><li>​            <em>/** The value associated with this ThreadLocal. \</em>/*</li><li>​            Object value;</li><li></li><li>​            Entry(ThreadLocal&lt;?&gt; k, Object v) {</li><li>​                <strong>super</strong>(k);</li><li>​                value = v;</li><li>​            }</li><li>​        }</li></ul><p><strong>弱引用介绍：</strong></p><p>如果一个对象只具有弱引用，那就类似于<strong>可有可无的生活用品</strong>。弱引用与软引用的区别在于：只具有弱引用的对象拥有更短暂的生命周期。在垃圾回收器线程扫描它 所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。不过，由于垃圾回收器是一个优先级很低的线程， 因此不一定会很快发现那些只具有弱引用的对象。</p><p>弱引用可以和一个引用队列（ReferenceQueue）联合使用，如果弱引用所引用的对象被垃圾回收，Java虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p>]]></content>
    
    <summary type="html">
    
      Java 并发基础知识 （中）
    
    </summary>
    
    
      <category term="Java 基础" scheme="http://yoursite.com/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java 并发基础知识 （上）</title>
    <link href="http://yoursite.com/2020/05/19/Java%20%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%8A%EF%BC%89/"/>
    <id>http://yoursite.com/2020/05/19/Java%20%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%EF%BC%88%E4%B8%8A%EF%BC%89/</id>
    <published>2020-05-19T08:16:58.000Z</published>
    <updated>2020-05-19T10:47:28.952Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id="Java-并发基础知识"><a href="#Java-并发基础知识" class="headerlink" title="Java 并发基础知识"></a>Java 并发基础知识</h2><h3 id="什么是线程和进程"><a href="#什么是线程和进程" class="headerlink" title="什么是线程和进程?"></a>什么是线程和进程?</h3><h3 id="何为进程"><a href="#何为进程" class="headerlink" title="何为进程?"></a>何为进程?</h3><h3 id="何为线程"><a href="#何为线程" class="headerlink" title="何为线程?"></a>何为线程?</h3><h3 id="请简要描述线程与进程的关系-区别及优缺点？"><a href="#请简要描述线程与进程的关系-区别及优缺点？" class="headerlink" title="请简要描述线程与进程的关系,区别及优缺点？"></a>请简要描述线程与进程的关系,区别及优缺点？</h3><h3 id="图解进程和线程的关系"><a href="#图解进程和线程的关系" class="headerlink" title="图解进程和线程的关系"></a>图解进程和线程的关系</h3><h3 id="程序计数器为什么是私有的"><a href="#程序计数器为什么是私有的" class="headerlink" title="程序计数器为什么是私有的?"></a>程序计数器为什么是私有的?</h3><h3 id="虚拟机栈和本地方法栈为什么是私有的"><a href="#虚拟机栈和本地方法栈为什么是私有的" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的?"></a>虚拟机栈和本地方法栈为什么是私有的?</h3><h3 id="一句话简单了解堆和方法区"><a href="#一句话简单了解堆和方法区" class="headerlink" title="一句话简单了解堆和方法区"></a>一句话简单了解堆和方法区</h3><h3 id="说说并发与并行的区别"><a href="#说说并发与并行的区别" class="headerlink" title="说说并发与并行的区别?"></a>说说并发与并行的区别?</h3><h3 id="为什么要使用多线程呢"><a href="#为什么要使用多线程呢" class="headerlink" title="为什么要使用多线程呢?"></a>为什么要使用多线程呢?</h3><h3 id="使用多线程可能带来什么问题"><a href="#使用多线程可能带来什么问题" class="headerlink" title="使用多线程可能带来什么问题?"></a>使用多线程可能带来什么问题?</h3><h3 id="说说线程的生命周期和状态"><a href="#说说线程的生命周期和状态" class="headerlink" title="说说线程的生命周期和状态?"></a>说说线程的生命周期和状态?</h3><h3 id="什么是上下文切换"><a href="#什么是上下文切换" class="headerlink" title="什么是上下文切换?"></a>什么是上下文切换?</h3><h3 id="什么是线程死锁-如何避免死锁"><a href="#什么是线程死锁-如何避免死锁" class="headerlink" title="什么是线程死锁?如何避免死锁?"></a>什么是线程死锁?如何避免死锁?</h3><h3 id="认识线程死锁"><a href="#认识线程死锁" class="headerlink" title="认识线程死锁"></a>认识线程死锁</h3><h3 id="如何避免线程死锁"><a href="#如何避免线程死锁" class="headerlink" title="如何避免线程死锁?"></a>如何避免线程死锁?</h3><h3 id="说说sleep-方法和wait-方法区别和共同点"><a href="#说说sleep-方法和wait-方法区别和共同点" class="headerlink" title="说说sleep()方法和wait()方法区别和共同点?"></a>说说sleep()方法和wait()方法区别和共同点?</h3><h3 id="为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？"><a href="#为什么我们调用start-方法时会执行run-方法，为什么我们不能直接调用run-方法？" class="headerlink" title="为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？"></a>为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？</h3><a id="more"></a><h1 id="什么是线程和进程-1"><a href="#什么是线程和进程-1" class="headerlink" title="什么是线程和进程?"></a>什么是线程和进程?</h1><h4 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h4><ul><li><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p></li><li><p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p></li></ul><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><ul><li>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。与进程不同的是同类的多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>，所以系统在产生一个线程，或是在各个线程之间作切换工作时，负担要比进程小得多，也正因为如此，线程也被称为轻量级进程。</li></ul><h6 id="Java-程序天生就是多线程程序，我们可以通过-JMX-来看一下一个普通的-Java-程序有哪些线程，代码如下。"><a href="#Java-程序天生就是多线程程序，我们可以通过-JMX-来看一下一个普通的-Java-程序有哪些线程，代码如下。" class="headerlink" title="Java 程序天生就是多线程程序，我们可以通过 JMX 来看一下一个普通的 Java 程序有哪些线程，代码如下。"></a>Java 程序天生就是多线程程序，我们可以通过 JMX 来看一下一个普通的 Java 程序有哪些线程，代码如下。</h6><ul><li><strong>public</strong> <strong>class</strong> <strong>MultiThread</strong> {</li><li>​    <strong>public</strong> <strong>static</strong> <strong>void</strong> <strong>main</strong>(String[] args) {</li><li>​        <em>// 获取 Java 线程管理 MXBean</em></li><li>​    ThreadMXBean threadMXBean = ManagementFactory.getThreadMXBean();</li><li>​        <em>// 不需要获取同步的 monitor 和 synchronizer 信息，仅获取线程和线程堆栈信息</em></li><li>​        ThreadInfo[] threadInfos = threadMXBean.dumpAllThreads(<strong>false</strong>, <strong>false</strong>);</li><li>​        <em>// 遍历线程信息，仅打印线程 ID 和线程名称信息</em></li><li>​        <strong>for</strong> (ThreadInfo threadInfo : threadInfos) {</li><li>​            System.out.println(“[“ + threadInfo.getThreadId() + “] “ + threadInfo.getThreadName());</li><li>​        }</li><li>​    }</li><li>}</li></ul><ul><li>[<strong>5</strong>] Attach Listener <em>//添加事件</em></li><li>[<strong>4</strong>] Signal Dispatcher <em>// 分发处理给 JVM 信号的线程</em></li><li>[<strong>3</strong>] Finalizer <em>//调用对象 finalize 方法的线程</em></li><li>[<strong>2</strong>] Reference Handler <em>//清除 reference 线程</em></li><li>[<strong>1</strong>] main <em>//main 线程,程序入口</em></li></ul><p>从上面的输出内容可以看出：<strong>一个 Java 程序的运行是 main 线程和多个其他线程同时运行</strong>。</p><h1 id="简单说一下线程与进程的关系-区别及优缺点？"><a href="#简单说一下线程与进程的关系-区别及优缺点？" class="headerlink" title="简单说一下线程与进程的关系,区别及优缺点？"></a>简单说一下线程与进程的关系,区别及优缺点？</h1><p><strong>从 JVM 角度说进程和线程之间的关系</strong></p><p>图解进程和线程的关系</p><p>下图是 Java 内存区域，通过下图我们从 JVM 的角度来说一下线程和进程之间的关系。如果你对 Java 内存区域 (运行时数据区) 这部分知识不太了解的话可以阅读一下这篇文章：<a href="https://snailclimb.gitee.io/javaguide/#/docs/java/jvm/Java内存区域" target="_blank" rel="noopener">《可能是把 Java 内存区域讲的最清楚的一篇文章》</a></p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5Cbde32dcf987842b6936354f532916aa7%5Cc84dcedf503a.png" alt="img"></p><p>从上图可以看出：一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)</strong>资源，但是每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong> 和 <strong>本地方法栈</strong>。</p><p><strong>总结：</strong> <strong>线程 是 进程</strong> 划分成的<strong>更小的运行单位</strong>。线程和进程最大的<strong>不同在于基本上各进程是独立的</strong>，而各<strong>线程则不一定</strong>，因为<strong>同一进程中的线程极有可能会相互影响。线程执行开销小，但不利于资源的管理和保护；而进程正相反</strong></p><p>下面是该知识点的扩展内容！</p><p>下面来思考这样一个问题：为什么<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong>是线程私有的呢？为什么堆和方法区是线程共享的呢？</p><h6 id="程序计数器为什么是私有的-1"><a href="#程序计数器为什么是私有的-1" class="headerlink" title="程序计数器为什么是私有的?"></a>程序计数器为什么是私有的?</h6><p><strong>程序计数器主要有下面两个作用：</strong></p><ol><li><strong>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理</strong>。</li><li><strong>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</strong></li></ol><p>需要注意的是，如果执行的是 native 方法，那么程序计数器记录的是 undefined 地址，只有执行的是 Java 代码时程序计数器记录的才是下一条指令的地址。</p><p>所以，<strong>程序计数器私有主要是</strong>为了<strong>线程切换后能恢复到正确的执行位置</strong>。</p><h5 id="虚拟机栈和本地方法栈为什么是私有的-1"><a href="#虚拟机栈和本地方法栈为什么是私有的-1" class="headerlink" title="虚拟机栈和本地方法栈为什么是私有的?"></a>虚拟机栈和本地方法栈为什么是私有的?</h5><ul><li><strong>虚拟机栈：</strong>每个 Java 方法在执行的同时会创建一个栈帧用于存储局部变量表、操作数栈、常量池引用等信息。从方法调用直至执行完成的过程，就对应着一个栈帧在 Java 虚拟机栈中入栈和出栈的过程。</li><li><strong>本地方法栈：</strong>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</li></ul><p>所以，为了<strong>保证线程中的局部变量不被别的线程访问到</strong>，虚拟机栈和本地方法栈是线程私有的。</p><h5 id="一句话简单了解堆和方法区-1"><a href="#一句话简单了解堆和方法区-1" class="headerlink" title="一句话简单了解堆和方法区"></a>一句话简单了解堆和方法区</h5><p><strong>堆和方法区是所有线程共享的资源，其中堆是进程中最大的一块内存，主要用于存放新创建的对象 (所有对象都在这里分配内存)，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</strong></p><p>说说并发与并行的区别?</p><ul><li><strong>并发：</strong> 同一时间段，多个任务都在执行 (单位时间内不一定同时执行)；</li><li><strong>并行：</strong>单位时间内，多个任务同时执行。</li></ul><p>为什么要使用多线程呢?</p><p>先从总体上来说：</p><ul><li><strong>从计算机底层来说：</strong>线程可以比作是轻量级的进程，是程序执行的最小单位,线程间的切换和调度的成本远远小于进程。另外，多核 CPU 时代意味着多个线程可以同时运行，这减少了线程上下文切换的开销。</li><li><strong>从当代互联网发展趋势来说：</strong>现在的系统动不动就要求百万级甚至千万级的并发量，而多线程并发编程正是开发高并发系统的基础，利用好多线程机制可以大大提高系统整体的并发能力以及性能。</li></ul><p>再深入到计算机底层来探讨：</p><ul><li><strong>单核时代：</strong> 在单核时代多线程主要是为了提高 CPU 和 IO 设备的综合利用率。举个例子：当只有一个线程的时候会导致 CPU 计算时，IO 设备空闲；进行 IO 操作时，CPU 空闲。我们可以简单地说这两者的利用率目前都是 50%左右。但是当有两个线程的时候就不一样了，当一个线程执行 CPU 计算时，另外一个线程可以进行 IO 操作，这样两个的利用率就可以在理想情况下达到 100%了。</li><li><strong>多核时代:</strong> 多核时代多线程主要是为了提高 CPU 利用率。举个例子：假如我们要计算一个复杂的任务，我们只用一个线程的话，CPU 只会一个 CPU 核心被利用到，而创建多个线程就可以让多个 CPU 核心被利用到，这样就提高了 CPU 的利用率。</li></ul><h5 id="使用多线程可能带来什么问题-1"><a href="#使用多线程可能带来什么问题-1" class="headerlink" title="使用多线程可能带来什么问题?"></a>使用多线程可能带来什么问题?</h5><p>并发编程的目的就是为了能提高程序的执行效率提高程序运行速度，但是并发编程并不总是能提高程序运行速度的，而且并发编程可能会遇到很多问题，比如：内存泄漏、上下文切换、死锁还有受限于硬件和软件的资源闲置问题。</p><p>说说线程的生命周期和状态?</p><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态（图源《Java 并发编程艺术》4.1.4 节）。</p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5Cabe4fc03b3d9430880c2d6b23036ac14%5C23a7ed9a59df.png" alt="img"></p><p>Java 线程的状态</p><p>线程在生命周期中并不是固定处于某一个状态而是随着代码的执行在不同状态之间切换。Java 线程状态变迁如下图所示（图源《Java 并发编程艺术》4.1.4 节）：</p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5Cc096732d8bc641e38fe10bb3f46fe6f0%5C27b9455a3777.png" alt="img"></p><p>Java 线程状态变迁</p><p>由上图可以看出：线程创建之后它将处于 <strong>NEW（新建）</strong> 状态，调用 start() 方法后开始运行，线程这时候处于 <strong>READY（可运行）</strong> 状态。可运行状态的线程获得了 CPU 时间片（timeslice）后就处于 <strong>RUNNING（运行）</strong> 状态。</p><p>操作系统隐藏 Java 虚拟机（JVM）中的 RUNNABLE 和 RUNNING 状态，它只能看到 RUNNABLE 状态（图源：<a href="https://howtodoinjava.com/" target="_blank" rel="noopener">HowToDoInJava</a>：<a href="https://howtodoinjava.com/java/multi-threading/java-thread-life-cycle-and-thread-states/" target="_blank" rel="noopener">Java Thread Life Cycle and Thread States</a>），所以 Java 系统一般将这两个状态统称为 <strong>RUNNABLE（运行中）</strong> 状态 。</p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5C5b77df2b2a85430b821d528c246c5f7b%5C7c2a945b7661.png" alt="img"></p><p>RUNNABLE-VS-RUNNING</p><p>当线程执行 wait()方法之后，线程进入 <strong>WAITING（等待）</strong>状态。进入等待状态的线程需要依靠其他线程的通知才能够返回到运行状态，而 <strong>TIME_WAITING(超时等待)</strong> 状态相当于在等待状态的基础上增加了超时限制，比如通过 sleep（long millis）方法或 wait（long millis）方法可以将 Java 线程置于 TIMED WAITING 状态。当超时时间到达后 Java 线程将会返回到 RUNNABLE 状态。当线程调用同步方法时，在没有获取到锁的情况下，线程将会进入到 <strong>BLOCKED（阻塞）</strong> 状态。线程在执行 Runnable 的run()方法之后将会进入到 <strong>TERMINATED（终止）</strong> 状态。</p><p>什么是上下文切换?</p><p>多线程编程中一般线程的个数都大于 CPU 核心的个数，而一个 CPU 核心在任意时刻只能被一个线程使用，为了让这些线程都能得到有效执行，CPU 采取的策略是为每个线程分配时间片并轮转的形式。当一个线程的时间片用完的时候就会重新处于就绪状态让给其他线程使用，这个过程就属于一次上下文切换。</p><p>概括来说就是：当前任务在执行完 CPU 时间片切换到另一个任务之前会先保存自己的状态，以便下次再切换会这个任务时，可以再加载这个任务的状态。<strong>任务从保存到再加载的过程就是一次上下文切换</strong>。</p><p>上下文切换通常是计算密集型的。也就是说，它需要相当可观的处理器时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间。所以，上下文切换对系统来说意味着消耗大量的 CPU 时间，事实上，可能是操作系统中时间消耗最大的操作。</p><p>Linux 相比与其他操作系统（包括其他类 Unix 系统）有很多的优点，其中有一项就是，其上下文切换和模式切换的时间消耗非常少。</p><p>什么是线程死锁?如何避免死锁?</p><p>认识线程死锁</p><p>多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><p>如下图所示，线程 A 持有资源 2，线程 B 持有资源 1，他们同时都想申请对方的资源，所以这两个线程就会互相等待而进入死锁状态。</p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5Cc213dd5ca1dd41e8a23fba3cad69c506%5Ca389c1b661cc.png" alt="img"></p><p>线程死锁示意图</p><p>下面通过一个例子来说明线程死锁,代码模拟了上图的死锁的情况 (代码来源于《并发编程之美》)：</p><ul><li><strong>public</strong> <strong>class</strong> <strong>DeadLockDemo</strong> {</li><li>​    <strong>private</strong> <strong>static</strong> Object resource1 = <strong>new</strong> Object();<em>//资源 1</em></li><li>​    <strong>private</strong> <strong>static</strong> Object resource2 = <strong>new</strong> Object();<em>//资源 2</em></li><li></li><li>​    <strong>public</strong> <strong>static</strong> <strong>void</strong> <strong>main</strong>(String[] args) {</li><li>​        <strong>new</strong> Thread(() -&gt; {</li><li>​            <strong>synchronized</strong> (resource1) {</li><li>​                System.out.println(Thread.currentThread() + “get resource1”);</li><li>​                <strong>try</strong> {</li><li>​                    Thread.sleep(1000);</li><li>​                } <strong>catch</strong> (InterruptedException e) {</li><li>​                    e.printStackTrace();</li><li>​                }</li><li>​                System.out.println(Thread.currentThread() + “waiting get resource2”);</li><li>​                <strong>synchronized</strong> (resource2) {</li><li>​                    System.out.println(Thread.currentThread() + “get resource2”);</li><li>​                }</li><li>​            }</li><li>​        }, “线程 1”).start();</li><li></li><li>​        <strong>new</strong> Thread(() -&gt; {</li><li>​            <strong>synchronized</strong> (resource2) {</li><li>​                System.out.println(Thread.currentThread() + “get resource2”);</li><li>​                <strong>try</strong> {</li><li>​                    Thread.sleep(1000);</li><li>​                } <strong>catch</strong> (InterruptedException e) {</li><li>​                    e.printStackTrace();</li><li>​                }</li><li>​                System.out.println(Thread.currentThread() + “waiting get resource1”);</li><li>​                <strong>synchronized</strong> (resource1) {</li><li>​                    System.out.println(Thread.currentThread() + “get resource1”);</li><li>​                }</li><li>​            }</li><li>​        }, “线程 2”).start();</li><li>​    }</li><li>}</li></ul><p>Output</p><ul><li><strong>Thread</strong>[线程 1,5,main]<strong>get</strong> resource1</li><li><strong>Thread</strong>[线程 2,5,main]<strong>get</strong> resource2</li><li><strong>Thread</strong>[线程 1,5,main]waiting <strong>get</strong> resource2</li><li><strong>Thread</strong>[线程 2,5,main]waiting <strong>get</strong> resource1</li></ul><p>线程 A 通过 synchronized (resource1) 获得 resource1 的监视器锁，然后通过Thread.sleep(1000);让线程 A 休眠 1s 为的是让线程 B 得到执行然后获取到 resource2 的监视器锁。线程 A 和线程 B 休眠结束了都开始企图请求获取对方的资源，然后这两个线程就会陷入互相等待的状态，这也就产生了死锁。上面的例子符合产生死锁的四个必要条件。</p><p>产生死锁必须具备以下四个条件：</p><ol><li><strong>互斥条件</strong>：该资源任意一个时刻只由一个线程占用。</li><li><strong>请求与保持条件</strong>：一个线程因请求资源而阻塞时，对已获得的资源保持不放。</li><li><strong>不剥夺条件</strong>:线程已获得的资源在末使用完之前不能被其他线程强行剥夺，只有自己使用完毕后才释放资源。</li><li><strong>循环等待条件</strong>:若干线程之间形成一种头尾相接的循环等待资源关系。</li></ol><p>如何避免线程死锁?</p><p>我们只要破坏产生死锁的四个条件中的其中一个就可以了。</p><p><strong>破坏互斥条件</strong></p><p>这个条件我们没有办法破坏，因为我们用锁本来就是想让他们互斥的（临界资源需要互斥访问）。</p><p><strong>破坏请求与保持条件</strong></p><p>一次性申请所有的资源。</p><p><strong>破坏不剥夺条件</strong></p><p>占用部分资源的线程进一步申请其他资源时，如果申请不到，可以主动释放它占有的资源。</p><p><strong>破坏循环等待条件</strong></p><p>靠按序申请资源来预防。按某一顺序申请资源，释放资源则反序释放。破坏循环等待条件。</p><p>我们对线程 2 的代码修改成下面这样就不会产生死锁了。</p><ul><li>​        <strong>new</strong> Thread(() -&gt; {</li><li>​            <strong>synchronized</strong> (resource1) {</li><li>​                System.out.println(Thread.currentThread() + “get resource1”);</li><li>​                <strong>try</strong> {</li><li>​                    Thread.sleep(1000);</li><li>​                } <strong>catch</strong> (InterruptedException e) {</li><li>​                    e.printStackTrace();</li><li>​                }</li><li>​                System.out.println(Thread.currentThread() + “waiting get resource2”);</li><li>​                <strong>synchronized</strong> (resource2) {</li><li>​                    System.out.println(Thread.currentThread() + “get resource2”);</li><li>​                }</li><li>​            }</li><li>​        }, “线程 2”).start();</li></ul><p>Output</p><ul><li><strong>Thread</strong>[线程 1,5,main]<strong>get</strong> resource1</li><li><strong>Thread</strong>[线程 1,5,main]waiting <strong>get</strong> resource2</li><li><strong>Thread</strong>[线程 1,5,main]<strong>get</strong> resource2</li><li><strong>Thread</strong>[线程 2,5,main]<strong>get</strong> resource1</li><li><strong>Thread</strong>[线程 2,5,main]waiting <strong>get</strong> resource2</li><li><strong>Thread</strong>[线程 2,5,main]<strong>get</strong> resource2</li><li></li><li><strong>Process</strong> finished with exit code 0</li></ul><p>我们分析一下上面的代码为什么避免了死锁的发生?</p><p>线程 1 首先获得到 resource1 的监视器锁,这时候线程 2 就获取不到了。然后线程 1 再去获取 resource2 的监视器锁，可以获取到。然后线程 1 释放了对 resource1、resource2 的监视器锁的占用，线程 2 获取到就可以执行了。这样就破坏了破坏循环等待条件，因此避免了死锁。</p><p><strong>说说sleep()方法和wait()方法区别和共同点?</strong></p><ul><li>两者最主要的区别在于：<strong>sleep方法没有释放锁，而wait方法释放了锁</strong> 。</li><li>两者都可以暂停线程的执行。</li><li>Wait通常被用于线程间交互/通信，sleep通常被用于暂停执行。</li><li>wait()方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的notify()或者notifyAll()方法。sleep()方法执行完成后，线程会自动苏醒。</li></ul><p>为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？</p><p>这是另一个非常经典的java多线程面试问题，而且在面试中会经常被问到。很简单，但是很多人都会答不上来！</p><p>new一个Thread，线程进入了新建状态;调用start()方法，会启动一个线程并使线程进入了就绪状态，当分配到时间片后就可以开始运行了。 start()会执行线程的相应准备工作，然后自动执行run()方法的内容，这是真正的多线程工作。 而直接执行run()方法，会把run方法当成一个main线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p><p><strong>总结： 调用start方法方可启动线程并使线程进入就绪状态，而run方法只是thread的一个普通方法调用，还是在主线程里执行。</strong></p>]]></content>
    
    <summary type="html">
    
      Java 并发基础知识 （上）
    
    </summary>
    
    
      <category term="Java 基础" scheme="http://yoursite.com/categories/Java-%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="并发" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91/"/>
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>数据库初识</title>
    <link href="http://yoursite.com/2020/05/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E8%AF%86/"/>
    <id>http://yoursite.com/2020/05/19/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%88%9D%E8%AF%86/</id>
    <published>2020-05-19T06:10:50.000Z</published>
    <updated>2020-05-20T07:48:50.171Z</updated>
    
    <content type="html"><![CDATA[<h1 id="数据库知识基础"><a href="#数据库知识基础" class="headerlink" title="数据库知识基础"></a>数据库知识基础</h1><ul><li>数据库知识基础，这部分内容一定要理解记忆。虽然这部分内容只是理论知识，但是非常重要，这是后面学习MySQL数据库的基础。</li></ul><a id="more"></a><h1 id="什么是数据库-数据库管理系统-数据库系统-数据库管理员"><a href="#什么是数据库-数据库管理系统-数据库系统-数据库管理员" class="headerlink" title="什么是数据库,数据库管理系统,数据库系统,数据库管理员?"></a>什么是数据库,数据库管理系统,数据库系统,数据库管理员?</h1><ul><li><strong>数据库</strong> :数据库(DataBase简称DB)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。</li><li><strong>数据库管理系统</strong> : 数据库管理系统(Database Management System 简称DBMS)是一种操纵和管理数据库的大型软件，通常用语用于建立、使用和维护数据库。</li><li><strong>数据库系统</strong> : 数据库系统(Data Base System，简称DBS)通常由软件、数据库和数据管理员(DBA)组成。</li><li><strong>数据库管理员</strong> : 数据库管理员(Database Administrator,简称DBA)负责全面管理和控制数据库系统。</li></ul><p>数据库系统基本构成如下图所示：</p><img src="E:%5CShellExt%5Cerer961115@163.com%5Ceae22654b4604b41925613ade654632c%5Ccaea8678708.jpeg" alt="img" style="zoom:70%;" /><h1 id="什么是元组-码-候选码-主码-外码-主属性-非主属性？"><a href="#什么是元组-码-候选码-主码-外码-主属性-非主属性？" class="headerlink" title="什么是元组,码,候选码,主码,外码,主属性,非主属性？"></a>什么是元组,码,候选码,主码,外码,主属性,非主属性？</h1><ul><li><strong>元组</strong> ： 元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。</li><li><strong>码</strong> ：码就是能唯一标识实体的属性，对应表中的列。</li><li><strong>候选码</strong> ： 若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何、子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。</li><li><strong>主码</strong> : 主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。</li><li><strong>外码</strong> : 外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。</li><li><strong>主属性</strong> ： 候选码中出现过的属性称为主属性。比如关系 工人（工号，身份证号，姓名，性别，部门）.显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。</li><li><strong>非主属性：</strong> 不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生（学号，姓名，年龄，性别，班级）中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。</li></ul><h1 id="主键和外键有什么区别"><a href="#主键和外键有什么区别" class="headerlink" title="主键和外键有什么区别?"></a>主键和外键有什么区别?</h1><ul><li><strong>主键(主码)</strong> ：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。</li><li><strong>外键(外码)</strong> ：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。</li></ul><h1 id="什么是ER图？"><a href="#什么是ER图？" class="headerlink" title="什么是ER图？"></a>什么是ER图？</h1><p>我们做一个项目的时候一定要试着花ER图来捋清数据库设计，这个也是面试官问你项目的时候经常会被问道的。</p><p><strong>E-R图</strong>也称实体-联系图(Entity Relationship Diagram)，提供了表示实体类型、属性和联系的方法，用来描述现实世界的概念模型。 它是描述现实世界关系概念模型的有效方法。 是表示概念关系模型的一种方式。</p><p>下图是一个学生选课的ER图，每个学生可以选若干门课程，同一门课程也可以被若干人选择，所以它们之间的关系是多对多（M:N）。另外，还有其他两种关系是：1对1（1:1）、1对多（1:N）。</p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5C2415cf4495e14d34a89cd1b3a66d7514%5Ccf4b7fbcb1ef.png" alt="img"></p><p>ER图示例</p><p>我们试着将上面的ER图转换成数据库实际的关系模型(实际设计中，我们通常会将任课教师也作为一个实体来处理)：</p><img src="E:%5CShellExt%5Cerer961115@163.com%5C09b755dd2268469d8a129573db3a3397%5Cecf8919bdf1a.png" alt="img" style="zoom:75%;" /><h1 id="数据库范式"><a href="#数据库范式" class="headerlink" title="数据库范式"></a>数据库范式</h1><p><strong>1NF(第一范式)</strong></p><p>属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。<strong>1NF是所有关系型数据库的最基本要求</strong> ，也就是说关系型数据库中创建的表一定满足第一范式。</p><p><strong>2NF(第二范式)</strong></p><p>2NF在1NF的基础之上，消除了非主属性对于码的部分函数依赖。如下图所示，展示了第一范式到第二范式的过渡。第二范式在第一范式的基础上增加了一个列，这个列称为主键，非主属性都依赖于主键。</p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5C14b26c0a6b0144979c5ac9780cd9f2f0%5Ca7cff05f59fb.png" alt="img"></p><p>第二范式</p><p>一些重要的概念：</p><ul><li><strong>函数依赖（functional dependency）</strong> ：若在一张表中，在属性（或属性组）X的值确定的情况下，必定能确定属性Y的值，那么就可以说Y函数依赖于X，写作 X → Y。</li><li><strong>部分函数依赖（partial functional dependency）</strong> ：如果X→Y，并且存在X的一个真子集X0，使得X0→Y，则称Y对X部分函数依赖。比如学生基本信息表R中（学号，身份证号，姓名）当然学号属性取值是唯一的，在R关系中，（学号，身份证号）-&gt;（姓名），（学号）-&gt;（姓名），（身份证号）-&gt;（姓名）；所以姓名部分函数依赖与（学号，身份证号）；</li><li><strong>完全函数依赖(Full functional dependency)</strong> ：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。比如学生基本信息表R（学号，班级，姓名）假设不同的班级学号有相同的，班级内学号不能相同，在R关系中，（学号，班级）-&gt;（姓名），但是（学号）-&gt;(姓名)不成立，（班级）-&gt;(姓名)不成立，所以姓名完全函数依赖与（学号，班级）；</li><li><strong>传递函数依赖</strong> ： 在关系模式R(U)中，设X，Y，Z是U的不同的属性子集，如果X确定Y、Y确定Z，且有X不包含Y，Y不确定X，（X∪Y）∩Z=空集合，则称Z传递函数依赖(transitive functional dependency) 于X。传递函数依赖会导致数据冗余和异常。传递函数依赖的Y和Z子集往往同属于某一个事物，因此可将其合并放到一个表中。比如在关系R(学号 ,姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。。</li></ul><p><strong>3NF(第三范式)</strong></p><p>3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖 。符合3NF要求的数据库设计，<strong>基本</strong>上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系R(学号 ,姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合3NF的要求。</p><p><strong>总结</strong></p><ul><li>1NF：属性不可再分。</li><li>2NF：1NF的基础之上，消除了非主属性对于码的部分函数依赖。</li><li>3NF：3NF在2NF的基础之上，消除了非主属性对于码的传递函数依赖 。</li></ul><h1 id="什么是存储过程"><a href="#什么是存储过程" class="headerlink" title="什么是存储过程?"></a>什么是存储过程?</h1><p>我们可以把存储过程看成是一些 SQL 语句的集合，中间加了点逻辑控制语句。存储过程在业务比较复杂的时候是非常实用的，比如很多时候我们完成一个操作可能需要写一大串SQL语句，这时候我们就可以写有一个存储过程，这样也方便了我们下一次的调用。存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯SQL语句执行要快，因为存储过程是预编译过的。</p><p>存储过程在互联网公司应用不多，因为存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源。</p><p>阿里巴巴Java开发手册里要求禁止使用存储过程。</p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5C7ad48798e3f94844b996cecc113085d6%5C4fd42fa48b5b.png" alt="img"></p><h1 id="drop、delete与truncate区别？"><a href="#drop、delete与truncate区别？" class="headerlink" title="drop、delete与truncate区别？"></a>drop、delete与truncate区别？</h1><p>用法不同</p><ul><li>drop(丢弃数据): drop table 表名 ，直接将表都删除掉，在删除表的时候使用。</li><li>truncate (清空数据) : truncate table 表名 ，只删除表中的数据，再插入数据的时候自增长id又从1开始，在清空表中数据的时候使用。</li><li>delete（删除数据） : delete from 表名 where 列名=值，删除某一列的数据，如果不加 where 子句和truncate table 表名作用类似。</li></ul><p>truncate 和不带 where 子句的 delete、以及 drop 都会删除表内的数据，但是 <strong>truncate 和 delete 只删除数据不删除表的结构(定义)，执行drop语句，此表的结构也会删除，也就是执行 drop 之后对应的表不复存在。</strong></p><p>属于不同的数据库语言</p><p>truncate和drop 属于DDL(数据定义语言)语句，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。而 delete 语句是DML (数据库操作语言)语句，这个操作会放到 rollback segement 中，事务提交之后才生效。</p><p><strong>DML 语句和 DDL 语句区别：</strong></p><ul><li>DML 是数据库操作语言（Data Manipulation Language）的缩写，是指对数据库中表记录的操作，主要包括表记录的插入（insert）、更新（update）、删除（delete）和查询（select），是开发人员日常使用最频繁的操作。</li><li>DDL （Data Definition Language）是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。</li></ul><p>执行速度不同</p><p>一般来说:drop&gt;truncate&gt;delete（这个我没有设计测试过）。</p><p>数据库设计通常分为哪几步?</p><ol><li><strong>需求分析</strong> : 分析用户的需求，包括数据、功能和性能需求。</li><li><strong>概念结构设计</strong> : 主要采用E-R模型进行设计，包括画E-R图。</li><li><strong>逻辑结构设计</strong> : 通过将E-R图转换成表，实现从E-R模型到关系模型的转换。</li><li><strong>物理结构设计</strong> : 主要是为所设计的数据库选择合适的存储结构和存取路径。</li><li><strong>数据库实施</strong> : 包括编程、测试和试运行</li><li><strong>数据库的运行和维护</strong> : 系统的运行与数据库的日常维护。</li></ol>]]></content>
    
    <summary type="html">
    
      数据库初识
    
    </summary>
    
    
      <category term="数据库" scheme="http://yoursite.com/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="初识" scheme="http://yoursite.com/tags/%E5%88%9D%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>linux 基础入门</title>
    <link href="http://yoursite.com/2020/05/19/linux%20%E5%85%A5%E9%97%A8/"/>
    <id>http://yoursite.com/2020/05/19/linux%20%E5%85%A5%E9%97%A8/</id>
    <published>2020-05-19T03:15:58.000Z</published>
    <updated>2020-05-19T03:17:55.927Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><h2 id=""><a href="#" class="headerlink" title=""></a></h2><ul><li><p>Linux 基本命令；</p></li><li><p>比如目录的增删改查命令；</p></li><li><p>文件的增删改查命令;</p></li></ul><a id="more"></a><h1 id="一-从认识操作系统开始："><a href="#一-从认识操作系统开始：" class="headerlink" title="一 从认识操作系统开始："></a>一 从认识操作系统开始：</h1><h3 id="1-1-操作系统简介"><a href="#1-1-操作系统简介" class="headerlink" title="1.1 操作系统简介"></a>1.1 操作系统简介</h3><p>我通过以下四点介绍什么操作系统：</p><ul><li><strong>操作系统（Operation System，简称OS）是管理计算机硬件与软件资源的程序，是计算机系统的内核与基石；</strong></li><li><strong>操作系统本质上是运行在计算机上的软件程序 ；</strong></li><li><strong>为用户提供一个与系统交互的操作界面 ；</strong></li><li><strong>操作系统分内核与外壳（我们可以把外壳理解成围绕着内核的应用程序，而内核就是能操作硬件的程序）。</strong></li></ul><h3 id="1-2-操作系统简单分类"><a href="#1-2-操作系统简单分类" class="headerlink" title="1.2 操作系统简单分类"></a>1.2 操作系统简单分类</h3><ol><li><strong>Windows:</strong> 目前最流行的个人桌面操作系统 ，不做多的介绍，大家都清楚。</li><li><strong>Unix：</strong> 最早的多用户、多任务操作系统 .按照操作系统的分类，属于分时操作系统。Unix 大多被用在服务器、工作站，现在也有用在个人计算机上。它在创建互联网、计算机网络或客户端/服务器模型方面发挥着非常重要的作用。</li><li><strong>Linux:</strong> Linux是一套免费使用和自由传播的类Unix操作系统.Linux存在着许多不同的Linux版本，但它们都使用了 <strong>Linux内核</strong> 。Linux可安装在各种计算机硬件设备中，比如手机、平板电脑、路由器、视频游戏控制台、台式计算机、大型机和超级计算机。严格来讲，Linux这个词本身只表示Linux内核，但实际上人们已经习惯了用Linux来形容整个基于Linux内核，并且使用GNU 工程各种工具和数据库的操作系统。</li></ol><h1 id="二-初识Linux"><a href="#二-初识Linux" class="headerlink" title="二 初识Linux"></a>二 初识Linux</h1><h3 id="2-1-Linux简介"><a href="#2-1-Linux简介" class="headerlink" title="2.1 Linux简介"></a>2.1 Linux简介</h3><ul><li><strong>类Unix系统：</strong> Linux是一种自由、开放源码的类似Unix的操作系统</li><li><strong>Linux内核：</strong> 严格来说，Linux这个词本身只表示Linux内核</li><li><strong>Linux之父：</strong> 一个编程领域的传奇式人物。他是Linux内核的最早作者，随后发起了这个开源项目，担任Linux内核的首要架构师与项目协调者，是当今世界最著名的电脑程序员、黑客之一。他还发起了Git这个开源项目，并为主要的开发者。</li></ul><h3 id="2-2-Linux诞生"><a href="#2-2-Linux诞生" class="headerlink" title="2.2 Linux诞生"></a>2.2 Linux诞生</h3><ul><li>1991年，芬兰的业余计算机爱好者Linus Torvalds编写了一款类似Minix的系统（基于微内核架构的类Unix操作系统）被ftp管理员命名为Linux 加入到自由软件基金的GNU计划中;</li><li>Linux以一只可爱的企鹅作为标志，象征着敢作敢为、热爱生活。</li></ul><h3 id="2-3-Linux的分类"><a href="#2-3-Linux的分类" class="headerlink" title="2.3 Linux的分类"></a>2.3 Linux的分类</h3><p><strong>Linux根据原生程度，分为两种：</strong></p><ol><li><strong>内核版本：</strong> Linux不是一个操作系统，严格来讲，Linux只是一个操作系统中的内核。内核是什么？内核建立了计算机软件与硬件之间通讯的平台，内核提供系统服务，比如文件管理、虚拟内存、设备I/O等；</li><li><strong>发行版本：</strong> 一些组织或公司在内核版基础上进行二次开发而重新发行的版本。Linux发行版本有很多种（ubuntu和CentOS用的都很多，初学建议选择CentOS；</li></ol><h1 id="三-Linux文件系统概览"><a href="#三-Linux文件系统概览" class="headerlink" title="三 Linux文件系统概览"></a>三 Linux文件系统概览</h1><h3 id="3-1-Linux文件系统简介"><a href="#3-1-Linux文件系统简介" class="headerlink" title="3.1 Linux文件系统简介"></a>3.1 Linux文件系统简介</h3><p><strong>在Linux操作系统中，所有被操作系统管理的资源，例如网络接口卡、磁盘驱动器、打印机、输入输出设备、普通文件或是目录都被看作是一个文件。</strong></p><p>也就是说在LINUX系统中有一个重要的概念：<strong>一切都是文件</strong>。其实这是UNIX哲学的一个体现，而Linux是重写UNIX而来，所以这个概念也就传承了下来。在UNIX系统中，把一切资源都看作是文件，包括硬件设备。UNIX系统把每个硬件都看成是一个文件，通常称为设备文件，这样用户就可以用读写文件的方式实现对硬件的访问。</p><h3 id="3-2-常见目录说明："><a href="#3-2-常见目录说明：" class="headerlink" title="3.2 常见目录说明："></a><strong>3.2 常见目录说明：</strong></h3><ul><li><strong>/bin：</strong> 存放二进制可执行文件(ls、cat、mkdir等)，常用命令一般都在这里；</li><li><strong>/etc：</strong> 存放系统管理和配置文件；</li><li><strong>/home：</strong> 存放所有用户文件的根目录，是用户主目录的基点，比如用户user的主目录就是/home/user，可以用~user表示；</li><li><strong>/usr ：</strong> 用于存放系统应用程序；</li><li><strong>/opt：</strong> 额外安装的可选应用程序包所放置的位置。一般情况下，我们可以把tomcat等都安装到这里；</li><li><strong>/proc：</strong> 虚拟文件系统目录，是系统内存的映射。可直接访问这个目录来获取系统信息；</li><li><strong>/root：</strong> 超级用户（系统管理员）的主目录（特权阶级^o^）；</li><li><strong>/sbin:</strong> 存放二进制可执行文件，只有root才能访问。这里存放的是系统管理员使用的系统级别的管理命令和程序。如ifconfig等；</li><li><strong>/dev：</strong> 用于存放设备文件；</li><li><strong>/mnt：</strong> 系统管理员安装临时文件系统的安装点，系统提供这个目录是让用户临时挂载其他的文件系统；</li><li><strong>/boot：</strong> 存放用于系统引导时使用的各种文件；</li><li><strong>/lib ：</strong> 存放着和系统运行相关的库文件 ；</li><li><strong>/tmp：</strong> 用于存放各种临时文件，是公用的临时文件存储点；</li><li><strong>/var：</strong> 用于存放运行时需要改变数据的文件，也是某些大文件的溢出区，比方说各种服务的日志文件（系统启动日志等。）等；</li><li><strong>/lost+found：</strong> 这个目录平时是空的，系统非正常关机而留下“无家可归”的文件（windows下叫什么.chk）就在这里。</li></ul><h1 id="四-Linux基本命令"><a href="#四-Linux基本命令" class="headerlink" title="四 Linux基本命令"></a>四 Linux基本命令</h1><p>下面只是给出了一些比较常用的命令。推荐一个Linux命令快查网站，大家如果遗忘某些命令或者对某些命令不理解都可以在这里得到解决。</p><p>Linux命令大全：<a href="http://man.linuxde.net/" target="_blank" rel="noopener">http://man.linuxde.net/</a></p><h3 id="4-1-目录切换命令"><a href="#4-1-目录切换命令" class="headerlink" title="4.1 目录切换命令"></a>4.1 目录切换命令</h3><ul><li><strong>cd usr</strong>： 切换到该目录下 usr 目录</li><li><strong>cd ..（或cd../）</strong>： 切换到上一层目录</li><li><strong>cd /</strong>： 切换到系统根目录</li><li><strong>cd ~</strong>： 切换到用户主目录</li><li><strong>cd -</strong>： 切换到上一个操作所在目录</li></ul><p>4.2 目录的操作命令(增删改查)</p><ol><li><strong>mkdir 目录名称</strong>： 增加目录</li><li><strong>ls或者ll</strong>（ll是ls -l的别名，ll命令可以看到该目录下的所有目录和文件的详细信息）：查看目录信息</li><li><strong>find 目录 参数</strong>： 寻找目录（查）</li></ol><p>示例：</p><ul><li><ul><li>列出当前目录及子目录下所有文件和文件夹: find .</li><li>在/home目录下查找以.txt结尾的文件名:find /home -name “*.txt”</li><li>同上，但忽略大小写: find /home -iname “*.txt”</li><li>当前目录及子目录下查找所有以.txt和.pdf结尾的文件:find . ( -name “<em>.txt” -o -name “</em>.pdf” )或find . -name “<em>.txt” -o -name “</em>.pdf”</li></ul></li></ul><ol><li><strong>mv 目录名称 新目录名称**</strong>：** 修改目录的名称（改）</li></ol><p>注意：mv的语法不仅可以对目录进行重命名而且也可以对各种文件，压缩包等进行 重命名的操作。mv命令用来对文件或目录重新命名，或者将文件从一个目录移到另一个目录中。后面会介绍到mv命令的另一个用法。</p><ol><li><strong>mv 目录名称 目录的新位置</strong>： 移动目录的位置—剪切（改）</li></ol><p>注意：mv语法不仅可以对目录进行剪切操作，对文件和压缩包等都可执行剪切操作。另外mv与cp的结果不同，mv好像文件“搬家”，文件个数并未增加。而cp对文件进行复制，文件个数增加了。</p><ol><li><strong>cp -r 目录名称 目录拷贝的目标位置*</strong> 拷贝目录（改），-r代表递归拷贝 </li></ol><p>注意：cp命令不仅可以拷贝目录还可以拷贝文件，压缩包等，拷贝文件和压缩包时不 用写-r递归</p><ol><li><strong>rm -rf</strong> 目录/文件/压缩包</li></ol><p>4.3 文件的操作命令(增删改查)</p><ol><li><strong>touch 文件名称</strong>: 文件的创建（增）</li><li><strong>cat/more/less/tail 文件名称</strong> 文件的查看（查）</li></ol><ul><li><ul><li><strong>cat</strong>： 查看显示文件内容</li><li><strong>more</strong>： 可以显示百分比，回车可以向下一行， 空格可以向下一页，q可以退出查看</li><li><strong>less</strong>：可以使用键盘上的PgUp和PgDn向上 和向下翻页，q结束查看</li><li><strong>tail-10</strong> <strong>：</strong> 查看文件的后10行，Ctrl+C结束</li></ul></li></ul><p>注意：命令 tail -f 文件 可以对某个文件进行动态监控，例如tomcat的日志文件， 会随着程序的运行，日志会变化，可以使用tail -f …..1541.log 监控 文 件的变化</p><ol><li><strong>vim 文件</strong>： 修改文件的内容（改）</li></ol><p>vim编辑器是Linux中的强大组件，是vi编辑器的加强版，vim编辑器的命令和快捷方式有很多，但此处不一一阐述，大家也无需研究的很透彻，使用vim编辑修改文件的方式基本会使用就可以了。</p><h3 id="在实际开发中，使用vim编辑器主要作用就是修改配置文件，下面是一般步骤："><a href="#在实际开发中，使用vim编辑器主要作用就是修改配置文件，下面是一般步骤：" class="headerlink" title="在实际开发中，使用vim编辑器主要作用就是修改配置文件，下面是一般步骤："></a><strong>在实际开发中，使用vim编辑器主要作用就是修改配置文件，下面是一般步骤：</strong></h3><p>vim 文件——&gt;进入文件—–&gt;命令模式——&gt;按i进入编辑模式—–&gt;编辑文件 ——-&gt;按Esc进入底行模式—–&gt;输入：wq/q! （输入wq代表写入内容并退出，即保存；输入q!代表强制退出不保存。）</p><ol><li><strong>rm -rf 文件</strong>： 删除文件（删）</li></ol><p>同目录删除：熟记 rm -rf 文件 即可</p><p>4.4 压缩文件的操作命令</p><p><strong>1）打包并压缩文件：</strong></p><p>Linux中的打包文件一般是以.tar结尾的，压缩的命令一般是以.gz结尾的。</p><p>而一般情况下打包和压缩是一起进行的，打包并压缩后的文件的后缀名一般.tar.gz。</p><p>命令：<strong>tar -zcvf 打包压缩后的文件名 要打包压缩的文件</strong></p><p>其中：</p><p>z：调用gzip压缩命令进行压缩</p><p>c：打包文件</p><p>v：显示运行过程</p><p>f：指定文件名</p><p>比如：加入test目录下有三个文件分别是：aaa.txt bbb.txt ccc.txt，如果我们要打包test目录并指定压缩后的压缩包名称为test.tar.gz可以使用命令：<strong>tar -zcvf test.tar.gz aaa.txt bbb.txt ccc.txt**</strong>或：<strong>**tar -zcvf test.tar.gz /test/</strong></p><p><strong>2）解压压缩包：</strong></p><p>命令：tar [-xvf] 压缩文件</p><p>其中：x：代表解压</p><p>示例：</p><p>1 将/test下的test.tar.gz解压到当前目录下可以使用命令：<strong>tar -xvf test.tar.gz</strong></p><p>2 将/test下的test.tar.gz解压到根目录/usr下:<strong>tar -xvf xxx.tar.gz -C /usr</strong>（- C代表指定解压的位置）</p><p>4.5 Linux的权限命令</p><p>操作系统中每个文件都拥有特定的权限、所属用户和所属组。权限是操作系统用来限制资源访问的机制，在Linux中权限一般分为读(readable)、写(writable)和执行(excutable)，分为三组。分别对应文件的属主(owner)，属组(group)和其他用户(other)，通过这样的机制来限制哪些用户、哪些组可以对特定的文件进行什么样的操作。通过 <strong>ls -l</strong> 命令我们可以 查看某个目录下的文件或目录的权限</p><p>示例：在随意某个目录下ls -l</p><p><img src="https://images.xiaozhuanlan.com/photo/2019/ff57f96cdec1f148fd7e1cb5a73453c4." alt="img"></p><p>第一列的内容的信息解释如下：</p><p><img src="https://images.xiaozhuanlan.com/photo/2019/109975850c71f073b36f0129503739cf." alt="img"></p><p>下面将详细讲解文件的类型、Linux中权限以及文件有所有者、所在组、其它组具体是什么？</p><p><strong>文件的类型：</strong></p><ul><li>d： 代表目录</li><li>-： 代表文件</li><li>l： 代表软链接（可以认为是window中的快捷方式）</li></ul><p><strong>Linux中权限分为以下几种：</strong></p><ul><li>r：代表权限是可读，r也可以用数字4表示</li><li>w：代表权限是可写，w也可以用数字2表示</li><li>x：代表权限是可执行，x也可以用数字1表示</li></ul><p><strong>文件和目录权限的区别：</strong></p><p>对文件和目录而言，读写执行表示不同的意义。</p><p>对于文件：</p><table><thead><tr><th>权限名称</th><th>可执行操作</th></tr></thead><tbody><tr><td>r</td><td>可以使用cat查看文件的内容</td></tr><tr><td>w</td><td>可以修改文件的内容</td></tr><tr><td>x</td><td>可以将其运行为二进制文件</td></tr></tbody></table><p>对于目录：</p><table><thead><tr><th>权限名称</th><th>可执行操作</th></tr></thead><tbody><tr><td>r</td><td>可以查看目录下列表</td></tr><tr><td>w</td><td>可以创建和删除目录下文件</td></tr><tr><td>x</td><td>可以使用cd进入目录</td></tr></tbody></table><p><strong>需要注意的是超级用户可以无视普通用户的权限，即使文件目录权限是000，依旧可以访问。</strong></p><p><strong>在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者、所在组、其它组的概念。</strong></p><ul><li><strong>所有者</strong></li></ul><p>一般为文件的创建者，谁创建了该文件，就天然的成为该文件的所有者，用ls ‐ahl命令可以看到文件的所有者 也可以使用chown 用户名 文件名来修改文件的所有者 。</p><ul><li><strong>文件所在组</strong></li></ul><p>当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组 用ls ‐ahl命令可以看到文件的所有组 也可以使用chgrp 组名 文件名来修改文件所在的组。</p><ul><li><strong>其它组</strong></li></ul><p>除开文件的所有者和所在组的用户外，系统的其它用户都是文件的其它组</p><p>我们再来看看如何修改文件/目录的权限。</p><p><strong>修改文件/目录的权限的命令：**</strong>chmod**</p><p>示例：修改/test下的aaa.txt的权限为属主有全部权限，属主所在的组有读写权限，</p><p>其他用户只有读的权限</p><p><strong>chmod u=rwx,g=rw,o=r aaa.txt</strong></p><p><img src="https://images.xiaozhuanlan.com/photo/2019/d698d9b526e2ed8c55afac32f087a00d." alt="img"></p><p>上述示例还可以使用数字表示：</p><p>chmod 765 aaa.txt</p><h1 id="补充一个比较常用的东西"><a href="#补充一个比较常用的东西" class="headerlink" title="补充一个比较常用的东西:"></a><strong>补充一个比较常用的东西:</strong></h1><p>假如我们装了一个zookeeper，我们每次开机到要求其自动启动该怎么办？</p><ol><li>新建一个脚本zookeeper</li><li>为新建的脚本zookeeper添加可执行权限，命令是:chmod +x zookeeper</li><li>把zookeeper这个脚本添加到开机启动项里面，命令是：chkconfig –add zookeeper</li><li>如果想看看是否添加成功，命令是：chkconfig –list</li></ol><p>4.6 Linux 用户管理</p><p>Linux系统是一个多用户多任务的分时操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统。</p><p>用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪，并控制他们对系统资源的访问；另一方面也可以帮助用户组织文件，并为用户提供安全性保护。</p><p><strong>Linux用户管理相关命令:</strong></p><ul><li>useradd 选项 用户名:添加用户账号</li><li>userdel 选项 用户名:删除用户帐号</li><li>usermod 选项 用户名:修改帐号</li><li>passwd 用户名:更改或创建用户的密码</li><li>passwd -S 用户名 :显示用户账号密码信息</li><li>passwd -d 用户名: 清除用户密码</li></ul><p>useradd命令用于Linux中创建的新的系统用户。useradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码．而可用userdel删除帐号。使用useradd指令所建立的帐号，实际上是保存在/etc/passwd文本文件中。</p><p>passwd命令用于设置用户的认证信息，包括用户密码、密码过期时间等。系统管理者则能用它管理系统用户的密码。只有管理者可以指定用户名称，一般用户只能变更自己的密码。</p><p>4.7 Linux系统用户组的管理</p><p>每个用户都有一个用户组，系统可以对一个用户组中的所有用户进行集中管理。不同Linux 系统对用户组的规定有所不同，如Linux下的用户属于与它同名的用户组，这个用户组在创建用户时同时创建。</p><p>用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。</p><p><strong>Linux系统用户组的管理相关命令:</strong></p><ul><li>groupadd 选项 用户组 :增加一个新的用户组</li><li>groupdel 用户组:要删除一个已有的用户组</li><li>groupmod 选项 用户组 : 修改用户组的属性</li></ul><p>4.8 其他常用命令</p><ul><li><strong>pwd**</strong>：** 显示当前所在位置</li><li><strong>grep 要搜索的字符串 要搜索的文件 –color**</strong>：** 搜索命令，–color代表高亮显示</li><li><strong>ps -ef**</strong>/<strong><strong>ps -aux</strong></strong>：** 这两个命令都是查看当前系统正在运行进程，两者的区别是展示格式不同。如果想要查看特定的进程可以使用这样的格式：<strong>ps aux|grep redis</strong> （查看包括redis字符串的进程），也可使用 pgrep redis -a。</li></ul><p>注意：如果直接用ps（（Process Status））命令，会显示所有进程的状态，通常结合grep命令查看某进程的状态。</p><ul><li><strong>kill -9 进程的pid**</strong>：** 杀死进程（-9 表示强制终止。）</li></ul><p>先用ps查找进程，然后用kill杀掉</p><ul><li><p><strong>网络通信命令：</strong></p></li><li><ul><li>查看当前系统的网卡信息：ifconfig</li><li>查看与某台机器的连接情况：ping</li><li>查看当前系统的端口使用：netstat -an</li></ul></li><li><p><strong>net-tools 和 iproute2 ：</strong></p></li></ul><p>net-tools起源于BSD的TCP/IP工具箱，后来成为老版本Linux内核中配置网络功能的工具。但自2001年起，Linux社区已经对其停止维护。同时，一些Linux发行版比如Arch Linux和CentOS/RHEL 7则已经完全抛弃了net-tools，只支持iproute2。linux ip命令类似于ifconfig，但功能更强大，旨在替代它。更多详情请阅读<a href="https://linoxide.com/linux-command/use-ip-command-linux" target="_blank" rel="noopener">如何在Linux中使用IP命令和示例</a></p><ul><li><strong>shutdown**</strong>：** shutdown -h now： 指定现在立即关机；shutdown +5 “System will shutdown after 5 minutes”：指定5分钟后关机，同时送出警告信息给登入用户。</li><li><strong>reboot**</strong>：** <strong>reboot**</strong>：** 重开机。<strong>reboot -w**</strong>：** 做个重开机的模拟（只有纪录并不会真的重开机）。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;h2 id=&quot;&quot;&gt;&lt;a href=&quot;#&quot; class=&quot;headerlink&quot; title=&quot;&quot;&gt;&lt;/a&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Linux 基本命令；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;比如目录的增删改查命令；&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;文件的增删改查命令;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="基本命令" scheme="http://yoursite.com/categories/%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
    
      <category term="linux" scheme="http://yoursite.com/tags/linux/"/>
    
      <category term="操作系统" scheme="http://yoursite.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>容器</title>
    <link href="http://yoursite.com/2020/05/19/Java%20%E9%9B%86%E5%90%88/"/>
    <id>http://yoursite.com/2020/05/19/Java%20%E9%9B%86%E5%90%88/</id>
    <published>2020-05-19T02:47:58.000Z</published>
    <updated>2020-05-19T08:16:37.071Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>集合：</p><ul><li>list；</li><li>set；</li><li>map</li></ul><a id="more"></a><h1 id="说说List-Set-Map三者的区别？"><a href="#说说List-Set-Map三者的区别？" class="headerlink" title="说说List,Set,Map三者的区别？"></a>说说List,Set,Map三者的区别？</h1><ul><li><strong>List(对付顺序的好帮手)：</strong> List接口存储一组不唯一（可以有多个元素引用相同的对象），有序的对象</li><li><strong>Set(注重独一无二的性质):</strong> 不允许重复的集合。不会有多个元素引用相同的对象。</li><li><strong>Map(用Key来搜索的专家):</strong> 使用键值对存储。Map会维护与Key有关联的值。两个Key可以引用相同的对象，但Key不能重复，典型的Key是String类型，但也可以是任何对象。</li></ul><h1 id="Arraylist-与-LinkedList-区别"><a href="#Arraylist-与-LinkedList-区别" class="headerlink" title="Arraylist 与 LinkedList 区别?"></a>Arraylist 与 LinkedList 区别?</h1><ul><li><strong>1. 是否保证线程安全：</strong> ArrayList 和 LinkedList 都是不同步的，也就是<strong>不保证线程安全</strong>；</li><li><strong>2. 底层数据结构：</strong> Arraylist 底层使用的是<strong>Object数组</strong>；LinkedList 底层使用的是<strong>双向链表数据结构</strong>（JDK1.6之前为循环链表，JDK1.7取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</li><li><strong>3. 插入和删除是否受元素位置的影响：</strong> ① <strong>ArrayList 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。</strong> 比如：执行add(E e)方法的时候， ArrayList 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是O(1)。但是如果要在指定位置 i 插入和删除元素的话（add(int index, E element)）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。 ② <strong>LinkedList 采用链表存储，所以插入，删除元素时间复杂度不受元素位置的影响，都是近似 O（1）而数组为近似 O（n）。</strong></li><li><strong>4. 是否支持快速随机访问：</strong> <strong>LinkedList 不支持高效的随机元素访问</strong>，而 <strong>ArrayList 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于get(int index)方法)。</strong></li><li><strong>5. 内存空间占用：</strong> ArrayList的空 间浪费主要体现在在list列表的结尾会预留一定的容量空间，而LinkedList的空间花费则体现在它的每一个元素都需要消耗比ArrayList更多的空间（因为要存放直接后继和直接前驱以及数据）。</li></ul><h1 id="ArrayList-与-Vector-区别呢-为什么要用Arraylist取代Vector呢？"><a href="#ArrayList-与-Vector-区别呢-为什么要用Arraylist取代Vector呢？" class="headerlink" title="ArrayList 与 Vector 区别呢?为什么要用Arraylist取代Vector呢？"></a>ArrayList 与 Vector 区别呢?为什么要用Arraylist取代Vector呢？</h1><p>Vector类的所有方法都是同步的。可以由两个线程安全地访问一个Vector对象、但是一个线程访问Vector的话代码要在同步操作上耗费大量的时间。</p><p>Arraylist不是同步的，所以在不需要保证线程安全时时建议使用Arraylist。</p><h1 id="HashMap-和-Hashtable-的区别"><a href="#HashMap-和-Hashtable-的区别" class="headerlink" title="HashMap 和 Hashtable 的区别"></a>HashMap 和 Hashtable 的区别</h1><ol><li><strong>线程是否安全：</strong> HashMap 是非线程安全的，HashTable 是线程安全的；HashTable 内部的方法基本都经过synchronized 修饰。（如果你要保证线程安全的话就使用 <strong>ConcurrentHashMap</strong> 吧！）；</li><li><strong>效率：</strong> 因为线程安全的问题，HashMap 要比 HashTable 效率高一点。另外，HashTable 基本被淘汰，不要在代码中使用它；</li><li><strong>对Null key 和Null value的支持：</strong> HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。。但是在 HashTable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。</li><li><strong>初始容量大小和每次扩充容量大小的不同 ：</strong> ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的2倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小（HashMap 中的tableSizeFor()方法保证，下面给出了源代码）。也就是说 HashMap 总是使用2的幂作为哈希表的大小,后面会介绍到为什么是2的幂次方。</li><li><strong>底层数据结构：</strong> JDK1.8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。</li></ol><h1 id="HashMap-和-HashSet区别"><a href="#HashMap-和-HashSet区别" class="headerlink" title="HashMap 和 HashSet区别"></a>HashMap 和 HashSet区别</h1><p>HashSet 底层就是基于 HashMap 实现的。（HashSet 的源码非常非常少，因为除了 clone()、writeObject()、readObject()是 HashSet 自己不得不实现之外，其他方法都是直接调用 HashMap 中的方法。</p><h1 id="HashSet如何检查重复"><a href="#HashSet如何检查重复" class="headerlink" title="HashSet如何检查重复"></a>HashSet如何检查重复</h1><p>当你把对象<strong>加入HashSet</strong>时，HashSet会<strong>先计算对象的hashcode值</strong>来<strong>判断</strong>对象<strong>加入的位置</strong>，同时<strong>也会与**</strong>其他加入<strong>的对象的</strong>hashcode<strong>值作比较，如果</strong>没有<strong>相符的hashcode</strong>，HashSet会假<strong>设对象没有重复</strong>出现。但是如果<strong>发现有相同ha</strong>shcode值的对象，这时会调<strong>用equals（）方</strong>法来检查hashcode相等的对象是否真的相同。如果<strong>两者相同，HashSet就不会让加入操作成功</strong>。</p><h1 id="hashCode（）与equals（）的相关规定："><a href="#hashCode（）与equals（）的相关规定：" class="headerlink" title="hashCode（）与equals（）的相关规定："></a><strong>hashCode（）与equals（）的相关规定：</strong></h1><ol><li>如果两个对象相等，则hashcode一定也是相同的</li><li>两个对象相等,对两个equals方法返回true</li><li>两个对象有相同的hashcode值，它们也不一定是相等的</li><li>综上，equals方法被覆盖过，则hashCode方法也必须被覆盖</li><li>hashCode()的默认行为是对堆上的对象产生独特值。如果没有重写hashCode()，则该class的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li></ol><h1 id="与equals的区别"><a href="#与equals的区别" class="headerlink" title="==与equals的区别"></a><strong>==与equals的区别</strong></h1><ol><li>==是判断两个变量或实例是不是指向同一个内存空间 equals是判断两个变量或实例所指向的内存空间的值是不是相同</li><li>==是指对内存地址进行比较 equals()是对字符串的内容进行比较</li><li>==指引用是否相同 equals()指的是值是否相同</li></ol><h1 id="HashMap的底层实现"><a href="#HashMap的底层实现" class="headerlink" title="HashMap的底层实现"></a>HashMap的底层实现</h1><p>JDK1.8 之前 HashMap 底层是 <strong>数组和链表</strong> 结合在一起使用也就是 <strong>链表散列</strong>。<strong>HashMap 通过 key 的 hashCode 经过扰动函数处理过后得到 hash 值，然后通过 (n - 1) &amp; hash 判断当前元素存放的位置（这里的 n 指的是数组的长度），如果当前位置存在元素的话，就判断该元素与要存入的元素的 hash 值以及 key 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</strong></p><p><strong>所谓扰动函数指的就是 HashMap 的 hash 方法。使用 hash 方法也就是扰动函数是为了防止一些实现比较差的 hashCode() 方法 换句话说使用扰动函数之后可以减少碰撞。</strong></p><p>所谓 <strong>“拉链法”</strong> 就是：将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><h1 id="HashMap-的长度为什么是2的幂次方"><a href="#HashMap-的长度为什么是2的幂次方" class="headerlink" title="HashMap 的长度为什么是2的幂次方"></a>HashMap 的长度为什么是2的幂次方</h1><p>为了能让 <strong>HashMap 存取高效，尽量较少碰撞，也就是要尽量把数据分配均匀</strong>。我们上面也讲到了过了，<strong>Hash 值的范围值</strong>-2147483648到2147483647，前后加起来大概<strong>40亿的映射空间</strong>，<strong>只要哈希函数映射得比较均匀松</strong>散，一般应用是很难出现碰撞的。<strong>但问题是一个40亿长度的数组</strong>，<strong>内存是放不下的</strong>。所以这个散列值是不<strong>能直接拿来用</strong>的。用<strong>之前还要先做对数组的长度取模运算</strong>，得<strong>到的余数</strong>才能<strong>用来要存放的位置</strong>也就是<strong>对应的数组下标</strong>。这个数组下标的计算方法是<strong>“ (n - 1) &amp; hash”</strong>。（n代表数组长度）。这也就<strong>解释了 HashMap 的长度为什么是2的幂次方</strong>。</p><p><strong>这个算法应该如何设计呢？</strong></p><p>我们首先可能会想到采用%取余的操作来实现。但是，重点来了：<strong>“取余(%)操作中如果除数是2的幂次则等价于与其除数减一的与(&amp;)操作（也就是说 hash%length==hash&amp;(length-1)的前提是 length 是2的 n 次方；）。”</strong> 并且 <strong>采用二进制位操作 &amp;，相对于%能够提高运算效率，这就解释了 HashMap 的长度为什么是2的幂次方。</strong></p><h1 id="HashMap-多线程操作导致死循环问题"><a href="#HashMap-多线程操作导致死循环问题" class="headerlink" title="HashMap 多线程操作导致死循环问题"></a>HashMap 多线程操作导致死循环问题</h1><p>主要原因在于 <strong>并发下的Rehash 会造成元素之间会形成一个循环链表</strong>。<strong>不过，jdk 1.8 后解决了这个问题</strong>，但是还是不建议在多线程下使用 HashMap,<strong>因为多线程下使用 HashMap 还是会存在其他问题比如数据丢失</strong>。<strong>并发</strong>环境下推荐使用 <strong>ConcurrentHashMap</strong> 。</p><h1 id="ConcurrentHashMap-和-Hashtable-的区别"><a href="#ConcurrentHashMap-和-Hashtable-的区别" class="headerlink" title="ConcurrentHashMap 和 Hashtable 的区别"></a>ConcurrentHashMap 和 Hashtable 的区别</h1><p>ConcurrentHashMap 和 Hashtable 的区别主要体现在<strong>实现线程安全的方式上不同</strong>。</p><ul><li><strong>底层数据结构：</strong> <strong>JDK1.7的 ConcurrentHashMap 底层</strong>采用 <strong>分段的数组+链表</strong> 实现，<strong>JDK1.8 采用的数据结构跟HashMap1.8的结构一样，数组+链表/红黑二叉树</strong>。Hashtable 和 JDK1.8 之前的 HashMap 的底层数据结构类似都是采用 <strong>数组+链表</strong> 的形式，<strong>数组是 HashMap 的主体</strong>，链表则是主要为了<strong>解决哈希冲突而存在的</strong>；</li><li><strong>实现线程安全的方式（重要）：</strong> ① <strong>在JDK1.7的时候，ConcurrentHashMap（分段锁）</strong> 对整个桶数组进行了分割分段(Segment)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。 <strong>到了 JDK1.8 的时候已经摒弃了Segment的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 synchronized 和 CAS 来操作。（JDK1.6以后 对 synchronized锁做了很多优化）</strong> 整个看起来就像是优化过且线程安全的 HashMap，虽然在JDK1.8中还能看到 Segment 的数据结构，但是已经简化了属性，只是为了兼容旧版本；② <strong>Hashtable(同一把锁)</strong> :使用 <strong>synchronized 来保证线程安全</strong>，效率非常低下。<strong>当一个线程访问同步方法时，其他线程也访问同步方法，可能会进入阻塞或轮询状态，如使用 put 添加元素，另一个线程不能使用 put 添加元素，也不能使用 get，竞争会越来越激烈效率越低。</strong></li></ul><h1 id="ConcurrentHashMap线程安全的具体实现方式-底层具体实现"><a href="#ConcurrentHashMap线程安全的具体实现方式-底层具体实现" class="headerlink" title="ConcurrentHashMap线程安全的具体实现方式/底层具体实现"></a>ConcurrentHashMap线程安全的具体实现方式/底层具体实现</h1><h3 id="JDK1-7"><a href="#JDK1-7" class="headerlink" title="JDK1.7"></a>JDK1.7</h3><p>首先将数据分为一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据时，其他段的数据也能被其他线程访问。</p><p><strong>ConcurrentHashMap 是由 Segment 数组结构和 HashEntry 数组结构组成</strong>。</p><p>Segment 实现了 ReentrantLock,所以 Segment 是一种可重入锁，扮演锁的角色。HashEntry 用于存储键值对数据。</p><ul><li><strong>static</strong> <strong>class</strong> <strong>Segment</strong>&lt;<strong>K</strong>,<strong>V</strong>&gt; <strong>extends</strong> <strong>ReentrantLock</strong> <strong>implements</strong> <strong>Serializable</strong> {</li><li>}</li></ul><p>一个 ConcurrentHashMap 里包含一个 Segment 数组。Segment 的结构和HashMap类似，是一种数组和链表结构，一个 Segment 包含一个 HashEntry 数组，每个 HashEntry 是一个链表结构的元素，每个 Segment 守护着一个HashEntry数组里的元素，当对 HashEntry 数组的数据进行修改时，必须首先获得对应的 Segment的锁。</p><h3 id="JDK1-8"><a href="#JDK1-8" class="headerlink" title="JDK1.8"></a>JDK1.8</h3><p>ConcurrentHashMap<strong>取消了Segment分段锁采用CAS和synchronized来保证并发安全。数据结构跟HashMap1.8的结构类似，数组+链表/红黑二叉树。Java 8在链表长度超过一定阈值（8）时将链表（寻址时间复杂度为O(N)）转换为红黑树（寻址时间复杂度为O(long(N))）</strong></p><p><strong>synchronized只锁定当前链表或红黑二叉树的首节点，这样只要hash不冲突，就不会产生并发，效率又提升N倍。</strong></p><h2 id="comparable-和-Comparator的区别"><a href="#comparable-和-Comparator的区别" class="headerlink" title="comparable 和 Comparator的区别"></a>comparable 和 Comparator的区别</h2><ul><li>comparable接口实际上是出自java.lang包 它有一个 compareTo(Object obj)方法用来排序</li><li>comparator接口实际上是出自 java.util 包它有一个compare(Object obj1, Object obj2)方法用来排序</li></ul><p>一般我们需要对一个集合使用自定义排序时，我们就要重写compareTo()方法或compare()方法，当我们需要对某一个集合实现两种排序方式，比如一个song对象中的歌名和歌手名分别采用一种排序方法的话，我们可以重写compareTo()方法和使用自制的Comparator方法或者以两个Comparator来实现歌名排序和歌星名排序，第二种代表我们只能使用两个参数版的 Collections.sort().</p><h2 id="Comparator定制排序"><a href="#Comparator定制排序" class="headerlink" title="Comparator定制排序"></a>Comparator定制排序</h2><ul><li>​        ArrayList<Integer> arrayList = <strong>new</strong> ArrayList<Integer>();</li><li>​        arrayList.add(-1);</li><li>​        arrayList.add(3);</li><li>​        arrayList.add(3);</li><li>​        arrayList.add(-5);</li><li>​        arrayList.add(7);</li><li>​        arrayList.add(4);</li><li>​        arrayList.add(-9);</li><li>​        arrayList.add(-7);</li><li>​        System.out.println(“原始数组:”);</li><li>​        System.out.println(arrayList);</li><li>​        <em>// void reverse(List list)：反转</em></li><li>​        Collections.reverse(arrayList);</li><li>​        System.out.println(“Collections.reverse(arrayList):”);</li><li>​        System.out.println(arrayList);</li><li></li><li>​        <em>// void sort(List list),按自然排序的升序排序</em></li><li>​        Collections.sort(arrayList);</li><li>​        System.out.println(“Collections.sort(arrayList):”);</li><li>​        System.out.println(arrayList);</li><li>​        <em>// 定制排序的用法</em></li><li>​        Collections.sort(arrayList, <strong>new</strong> Comparator<Integer>() {</li><li></li><li>​            <strong>@Override</strong></li><li>​            <strong>public</strong> <strong>int</strong> <strong>compare</strong>(Integer o1, Integer o2) {</li><li>​                <strong>return</strong> o2.compareTo(o1);</li><li>​            }</li><li>​        });</li><li>​        System.out.println(“定制排序后：”);</li><li>​        System.out.println(arrayList);</li></ul><p>Output:</p><ul><li>原始数组:</li><li>[-1, 3, 3, -5, 7, 4, -9, -7]</li><li><strong>Collections</strong>.reverse(<strong>arrayList</strong>):</li><li>[-7, -9, 4, 7, -5, 3, 3, -1]</li><li><strong>Collections</strong>.sort(<strong>arrayList</strong>):</li><li>[-9, -7, -5, -1, 3, 3, 4, 7]</li><li>定制排序后：</li><li>[7, 4, 3, 3, -1, -5, -7, -9]</li></ul><h2 id="重写compareTo方法实现按年龄来排序"><a href="#重写compareTo方法实现按年龄来排序" class="headerlink" title="重写compareTo方法实现按年龄来排序"></a>重写compareTo方法实现按年龄来排序</h2><ul><li><p><em>// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列</em></p></li><li><p><em>// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他</em></p></li><li><p><em>// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了</em></p></li><li></li><li><p><strong>public</strong>  <strong>class</strong> <strong>Person</strong> <strong>implements</strong> <strong>Comparable</strong>&lt;<strong>Person</strong>&gt; {</p></li><li><p>​    <strong>private</strong> String name;</p></li><li><p>​    <strong>private</strong> <strong>int</strong> age;</p></li><li></li><li><p>​    <strong>public</strong> <strong>Person</strong>(String name, <strong>int</strong> age) {</p></li><li><p>​        <strong>super</strong>();</p></li><li><p>​        <strong>this</strong>.name = name;</p></li><li><p>​        <strong>this</strong>.age = age;</p></li><li><p>​    }</p></li><li></li><li><p>​    <strong>public</strong> String <strong>getName</strong>() {</p></li><li><p>​        <strong>return</strong> name;</p></li><li><p>​    }</p></li><li></li><li><p>​    <strong>public</strong> <strong>void</strong> <strong>setName</strong>(String name) {</p></li><li><p>​        <strong>this</strong>.name = name;</p></li><li><p>​    }</p></li><li></li><li><p>​    <strong>public</strong> <strong>int</strong> <strong>getAge</strong>() {</p></li><li><p>​        <strong>return</strong> age;</p></li><li><p>​    }</p></li><li></li><li><p>​    <strong>public</strong> <strong>void</strong> <strong>setAge</strong>(<strong>int</strong> age) {</p></li><li><p>​        <strong>this</strong>.age = age;</p></li><li><p>​    }</p></li><li></li><li><p>​    <em>/**</em></p></li><li><p>​     <em>* TODO重写compareTo方法实现按年龄来排序</em></p></li><li><p>​     <em>*/</em></p></li><li><p>​    <strong>@Override</strong></p></li><li><p>​    <strong>public</strong> <strong>int</strong> <strong>compareTo</strong>(Person o) {</p></li><li><p>​        <em>// TODO Auto-generated method stub</em></p></li><li><p>​        <strong>if</strong> (<strong>this</strong>.age &gt; o.getAge()) {</p></li><li><p>​            <strong>return</strong> 1;</p></li><li><p>​        } <strong>else</strong> <strong>if</strong> (<strong>this</strong>.age &lt; o.getAge()) {</p></li><li><p>​            <strong>return</strong> -1;</p></li><li><p>​        }</p></li><li><p>​        <strong>return</strong> age;</p></li><li><p>​    }</p></li><li><p>}</p></li><li><p>​    <strong>public</strong> <strong>static</strong> <strong>void</strong> <strong>main</strong>(String[] args) {</p></li><li><p>​        TreeMap&lt;Person, String&gt; pdata = <strong>new</strong> TreeMap&lt;Person, String&gt;();</p></li><li><p>​        pdata.put(<strong>new</strong> Person(“张三”, 30), “zhangsan”);</p></li><li><p>​        pdata.put(<strong>new</strong> Person(“李四”, 20), “lisi”);</p></li><li><p>​        pdata.put(<strong>new</strong> Person(“王五”, 10), “wangwu”);</p></li><li><p>​        pdata.put(<strong>new</strong> Person(“小红”, 5), “xiaohong”);</p></li><li><p>​        <em>// 得到key的值的同时得到key所对应的值</em></p></li><li><p>​        Set<Person> keys = pdata.keySet();</p></li><li><p>​        <strong>for</strong> (Person key : keys) {</p></li><li><p>​            System.out.println(key.getAge() + “-“ + key.getName());</p></li><li></li><li><p>​        }</p></li><li><p>​    }</p></li></ul><p>Output：</p><ul><li>5-小红</li><li>10-王五</li><li>20-李四</li><li>30-张三</li></ul><h1 id="集合框架底层数据结构总结"><a href="#集合框架底层数据结构总结" class="headerlink" title="集合框架底层数据结构总结"></a>集合框架底层数据结构总结</h1><p>Collection</p><p>\1. List</p><ul><li><strong>Arraylist：</strong> Object数组</li><li><strong>Vector：</strong> Object数组</li><li><strong>LinkedList：</strong> 双向链表(JDK1.6之前为循环链表，JDK1.7取消了循环) 详细可阅读<a href="https://www.cnblogs.com/xingele0917/p/3696593.html" target="_blank" rel="noopener">JDK1.7-LinkedList循环链表优化</a></li></ul><p>\2. Set</p><ul><li><strong>HashSet（无序，唯一）:</strong> 基于 HashMap 实现的，底层采用 HashMap 来保存元素</li><li><strong>LinkedHashSet：</strong> LinkedHashSet 继承与 HashSet，并且其内部是通过 LinkedHashMap 来实现的。有点类似于我们之前说的LinkedHashMap 其内部是基于 Hashmap 实现一样，不过还是有一点点区别的。</li><li><strong>TreeSet（有序，唯一）：</strong> 红黑树(自平衡的排序二叉树。)</li></ul><p>Map</p><ul><li><strong>HashMap：</strong> JDK1.8之前HashMap由数组+链表组成的，数组是HashMap的主体，链表则是主要为了解决哈希冲突而存在的（“拉链法”解决冲突）。JDK1.8以后在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间</li><li><strong>LinkedHashMap：</strong> LinkedHashMap 继承自 HashMap，所以它的底层仍然是基于拉链式散列结构即由数组和链表或红黑树组成。另外，LinkedHashMap 在上面结构的基础上，增加了一条双向链表，使得上面的结构可以保持键值对的插入顺序。同时通过对链表进行相应的操作，实现了访问顺序相关逻辑。详细可以查看：<a href="https://www.imooc.com/article/22931" target="_blank" rel="noopener">《LinkedHashMap 源码详细分析（JDK1.8）》</a></li><li><strong>Hashtable：</strong> 数组+链表组成的，数组是 HashMap 的主体，链表则是主要为了解决哈希冲突而存在的</li><li><strong>TreeMap：</strong> 红黑树（自平衡的排序二叉树）</li></ul><h1 id="如何选用集合"><a href="#如何选用集合" class="headerlink" title="如何选用集合?"></a>如何选用集合?</h1><h2 id="集合的选用"><a href="#集合的选用" class="headerlink" title="集合的选用"></a>集合的选用</h2><p>主要根据<strong>集合的特点来选用</strong>，比如我们需要<strong>根据键值获取到元素值时就选用Map接口下的集合</strong>，需要<strong>排序时选择TreeMap,不需要排序时就选择HashMap,需要保证线程安全就选用ConcurrentHashMap</strong>.当我们<strong>只需要存放元素值时，就选择实现Collection接口的集合，需要保证元素唯一时选择实现Set接口的集合比如TreeSet或HashSet，不需要就选择实现List接口的比如ArrayList或LinkedList</strong>，然后再根据实现这些接口的集合的特点来选用。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;集合：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;list；&lt;/li&gt;
&lt;li&gt;set；&lt;/li&gt;
&lt;li&gt;map&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Java基础" scheme="http://yoursite.com/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="集合" scheme="http://yoursite.com/tags/%E9%9B%86%E5%90%88/"/>
    
      <category term="容器" scheme="http://yoursite.com/tags/%E5%AE%B9%E5%99%A8/"/>
    
  </entry>
  
  <entry>
    <title>git基本</title>
    <link href="http://yoursite.com/2020/05/19/git/"/>
    <id>http://yoursite.com/2020/05/19/git/</id>
    <published>2020-05-19T00:48:58.000Z</published>
    <updated>2020-05-18T23:51:09.718Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言-git"><a href="#前言-git" class="headerlink" title="前言 git"></a>前言 git</h1><ul><li><p>认识 Git</p></li><li><p>Git 与其他版本管理系统的主要区别</p></li><li><p>Git 的三种状态</p></li><li><p>基本的 Git 工作流程</p></li><li><p>基本命令</p><a id="more"></a></li></ul><h2 id="认识-Git"><a href="#认识-Git" class="headerlink" title="认识 Git"></a>认识 Git</h2><p>​        Linux 内核项目组当时使用分布式版本控制系统 BitKeeper 来管理和维护代码。但是，后来开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。 Linux 开源社区（特别是 Linux 的缔造者 Linus Torvalds）基于使用 BitKeeper 时的经验教训，开发出自己的版本系统，而且对新的版本控制系统做了很多改进。</p><h3 id="Git-与其他版本管理系统的主要区别"><a href="#Git-与其他版本管理系统的主要区别" class="headerlink" title="Git 与其他版本管理系统的主要区别"></a>Git 与其他版本管理系统的主要区别</h3><p>主要差别：<strong>对待数据的方式</strong>。</p><p><strong>Git采用的是直接记录快照的方式，而非差异比较。我后面会详细介绍这两种方式的差别。</strong></p><p>大部分版本控制系统（CVS、Subversion、Perforce、Bazaar 等等）都是以文件变更列表的方式存储信息，这类系统<strong>将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异。</strong></p><p><img src="C:%5CUsers%5Cx%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200519074004392.png" alt="image-20200519074004392"></p><p><strong>我们怎样才能得到一个文件的最终版本呢？</strong></p><p>很简单，高中数学的基本知识，我们只需要将这些原文件和这些增加进行相加就行了。</p><p><strong>这种方式有什么问题呢？</strong></p><p>比如我们的增量特别特别多的话，如果我们要得到最终的文件是不是会耗费时间和性能。</p><p>Git 不按照以上方式对待或保存数据。 反之，Git 更像是把数据看作是对小型文件系统的一组快照。 每次你提交更新，或在 Git 中保存项目状态时，它主要对当时的全部文件制作一个快照并保存这个快照的索引。 为了高效，如果文件没有修改，Git 不再重新存储该文件，而是只保留一个链接指向之前存储的文件。 Git 对待数据更像是一个 <strong>快照流</strong>。下图来源于Git官网。</p><p><img src="C:%5CUsers%5Cx%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200519074105838.png" alt="image-20200519074105838"></p><h3 id="Git-的三种状态"><a href="#Git-的三种状态" class="headerlink" title="Git 的三种状态"></a>Git 的三种状态</h3><p>Git 有三种状态，你的文件可能处于其中之一：</p><p>•<strong>已提交（committed）</strong>：数据已经安全的保存在本地数据库中。•<strong>已修改（modified）</strong>：已修改表示修改了文件，但还没保存到数据库中。•<strong>已暂存（staged）</strong>：表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</p><p>由此引入 Git 项目的三个工作区域的概念：<strong>Git 仓库(.git directoty) 、**</strong>工作目录(Working Directory)** 以及 <strong>暂存区域(Staging Area)</strong> 。</p><p><img src="C:%5CUsers%5Cx%5CAppData%5CRoaming%5CTypora%5Ctypora-user-images%5Cimage-20200519074139658.png" alt="image-20200519074139658"></p><p><strong>基本的 Git 工作流程如下：</strong></p><p>•在工作目录中修改文件。•暂存文件，将文件的快照放入暂存区域。•提交更新，找到暂存区域的文件，将快照永久性存储到 Git 仓库目录。</p><h3 id="获取-Git-仓库"><a href="#获取-Git-仓库" class="headerlink" title="获取 Git 仓库"></a>获取 Git 仓库</h3><p>有两种取得 Git 项目仓库的方法。</p><p>•在现有目录中初始化仓库: 进入项目目录运行 <code>git init</code> 命令,该命令将创建一个名为 <code>.git</code> 的子目录。•从一个服务器克隆一个现有的 Git 仓库: <code>git clone [url]</code> 自定义本地仓库的名字: <code>git clone [url]</code> directoryname</p><h3 id="记录每次更新到仓库"><a href="#记录每次更新到仓库" class="headerlink" title="记录每次更新到仓库"></a>记录每次更新到仓库</h3><p>•<strong>检测当前文件状态</strong> : <code>git status</code>•<strong>提出更改（把它们添加到暂存区</strong>）：<code>git add filename</code> (针对特定文件)、<code>git add *</code>(所有文件)、<code>git add *.txt</code>（支持通配符，所有 .txt 文件）•<strong>忽略文件</strong>：<code>.gitignore</code> 文件•<strong>提交更新:</strong> <code>git commit -m &quot;代码提交信息&quot;</code> （每次准备提交前，先用 <code>git status</code> 看下，是不是都已暂存起来了， 然后再运行提交命令 <code>git commit</code>）•<strong>跳过使用暂存区域更新的方式</strong> : <code>git commit -a -m &quot;代码提交信息&quot;</code>。 <code>git commit</code> 加上 <code>-a</code> 选项，Git 就会自动把所有已经跟踪过的文件暂存起来一并提交，从而跳过 <code>git add</code> 步骤。•<strong>移除文件</strong> ：<code>git rm filename</code> （从暂存区域移除，然后提交。）•<strong>对文件重命名</strong> ：<code>git mv README.md README</code>(这个命令相当于<code>mv README.md README</code>、<code>git rm README.md</code>、<code>git add README</code> 这三条命令的集合)</p><h3 id="推送改动到远程仓库"><a href="#推送改动到远程仓库" class="headerlink" title="推送改动到远程仓库"></a>推送改动到远程仓库</h3><ul><li>如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：·<code>git remote add origin</code> ,比如我们要让本地的一个仓库和 Github 上创建的一个仓库关联可以这样<code>git remote add origin https://github.com/Snailclimb/test.git</code>将</li><li>将这些改动提交到远端仓库：<code>git push origin master</code> (可以把 <strong>master</strong> 换成你想要推送的任何分支)</li></ul><h3 id="远程仓库的移除与重命名"><a href="#远程仓库的移除与重命名" class="headerlink" title="远程仓库的移除与重命名"></a>远程仓库的移除与重命名</h3><p>•将 test 重命名位 test1：<code>git remote rename test test1</code>•移除远程仓库 test1:<code>git remote rm test1</code></p><h3 id="远程仓库的移除与重命名-1"><a href="#远程仓库的移除与重命名-1" class="headerlink" title="远程仓库的移除与重命名"></a>远程仓库的移除与重命名</h3><p>•将 test 重命名位 test1：<code>git remote rename test test1</code>•移除远程仓库 test1:<code>git remote rm test1</code></p><p><strong>可以添加一些参数来查看自己希望看到的内容：</strong></p><ul><li>只看某个人的提交记录：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log --author&#x3D;xxx可以添加一些参数来查看自己希望看到的内容：</span><br></pre></td></tr></table></figure><h3 id="撤销操作"><a href="#撤销操作" class="headerlink" title="撤销操作"></a>撤销操作</h3><p>有时候我们提交完了才发现漏掉了几个文件没有添加，或者提交信息写错了。 此时，可以运行带有 <code>--amend</code> 选项的提交命令尝试重新提交：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure><p>取消暂存的文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset filename</span><br></pre></td></tr></table></figure><p>撤消对文件的修改:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- filename</span><br></pre></td></tr></table></figure><p>假如你想丢弃你在本地的所有改动与提交，可以到服务器上获取最新的版本历史，并将你本地主分支指向它：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch origingit reset --hard origin&#x2F;master</span><br></pre></td></tr></table></figure><h3 id="分支"><a href="#分支" class="headerlink" title="分支"></a>分支</h3><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，<strong>master</strong> 是“默认的”分支。在其他分支上进行开发，完成后再将它们合并到主分支上。</p><p>我们通常在开发新功能、修复一个紧急 bug 等等时候会选择创建分支。单分支开发好还是多分支开发好，还是要看具体场景来说。</p><p>创建一个名字叫做 test 的分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch test</span><br></pre></td></tr></table></figure><p>切换当前分支到 test（当你切换分支的时候，Git 会重置你的工作目录，使其看起来像回到了你在那个分支上最后一次提交的样子。 Git 会自动添加、删除、修改文件以确保此时你的工作目录和这个分支最后一次提交时的样子一模一样）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout test</span><br></pre></td></tr></table></figure><p>你也可以直接这样创建分支并切换过去(上面两条命令的合写)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b feature_x</span><br></pre></td></tr></table></figure><p>切换到主分支</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p>合并分支(可能会有冲突)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge test</span><br></pre></td></tr></table></figure><p>把新建的分支删掉</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d feature_x</span><br></pre></td></tr></table></figure><p>将分支推送到远端仓库（推送成功后其他人可见）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      github pages服务搭建博客
    
    </summary>
    
    
      <category term="git" scheme="http://yoursite.com/categories/git/"/>
    
    
      <category term="基本命令" scheme="http://yoursite.com/tags/%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    
      <category term="git" scheme="http://yoursite.com/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>hexo+github搭建免费博客</title>
    <link href="http://yoursite.com/2020/05/19/diyici/"/>
    <id>http://yoursite.com/2020/05/19/diyici/</id>
    <published>2020-05-18T22:16:58.000Z</published>
    <updated>2020-05-18T22:21:30.750Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>使用github pages服务搭建博客的好处有：</p><ul><li><p>全是静态文件，访问速度快；</p></li><li><p>免费方便，不用花一分钱就可以搭建一个自由的个人博客，不需要服务器不需要后台；</p></li><li><p>可以随意绑定自己的域名，不仔细看的话根本看不出来你的网站是基于github的；</p></li><li><p>数据绝对安全，基于github的版本管理，想恢复到哪个历史版本都行；</p></li><li><p>博客内容可以轻松打包、转移、发布到其它平台；</p></li><li><p>等等；</p></li></ul><a id="more"></a><h1 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h1><ul><li>有一个github账号，没有的话去注册一个；</li><li>安装了node.js、npm，并了解相关基础知识；</li><li>安装了git for windows（或者其它git客户端）</li></ul><h1 id="搭建github博客"><a href="#搭建github博客" class="headerlink" title="搭建github博客"></a>搭建github博客</h1><ul><li><p>创建仓库<br>新建一个名为  你的用户名.github.io的仓库，比如说，如果你的github用户名是test，那么你就新建test.github.io的仓库（必须是你的用户名，其它名称无效）</p></li><li><p>配置SSH key</p><p>  $ cd ~/. ssh #检查本机已存在的ssh密钥</p><p>  $ ssh-keygen -t rsa -C “邮件地址”</p></li><li><p>然后连续3次回车，最终会生成一个文件在用户目录下，打开用户目录，找到.ssh\id_rsa.pub文件</p><pre><code>复制里面的内容，打开你的github主页，进入个人设置 -&gt; SSH and GPG keys -&gt; New SSH key：</code></pre></li></ul><h1 id="配置："><a href="#配置：" class="headerlink" title="配置："></a>配置：</h1><ul><li>$ git config –global user.name “liuxianan”// 你的github用户名，非昵称</li><li>$ git config –global user.email  “<a href="mailto:xxx@qq.com">xxx@qq.com</a>“// 填写你的github注册邮箱</li></ul><h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><ul><li><p>$ npm install -g hexo</p><h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>在电脑的某个地方新建一个名为hexo的文件夹由于这个文件夹将来就作为你存放代码的地方，所以最好不要随便放注意一定要是空文件夹。</p></li><li><p>$ cd /f/Workspaces/hexo/</p></li><li><p>$ hexo init</p></li></ul><h1 id="生成"><a href="#生成" class="headerlink" title="生成"></a>生成</h1><ul><li>$ hexo g # 生成</li><li>$ hexo s # 启动服务</li></ul><h1 id="主题替换"><a href="#主题替换" class="headerlink" title="主题替换"></a>主题替换</h1><ul><li>git clone <a href="https://github.com/litten/hexo-theme-yilia.git" target="_blank" rel="noopener">https://github.com/litten/hexo-theme-yilia.git</a> themes/yilia</li></ul><h2 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h2><p>*修改_config.yml中的theme: landscape改为theme: yilia，然后重新执行hexo g来重新生成。</p><p>如果出现一些莫名其妙的问题，可以先执行hexo clean来清理一下public的内容，然后再来重新生成和发布</p><ul><li>deploy:<ul><li>type: git</li><li>repository: <a href="mailto:git@github.com">git@github.com</a>:liuxianan/liuxianan.github.io.git</li><li>branch: master</li></ul></li></ul><p>执行npm install hexo-deployer-git –save</p><h1 id="常用hexo命令"><a href="#常用hexo命令" class="headerlink" title="常用hexo命令"></a>常用hexo命令</h1><p>hexo new “postName” #新建文章</p><p>hexo new page “pageName” #新建页面</p><p>hexo generate #生成静态页面至public目录</p><p>hexo server #开启预览访问端口（默认端口4000，’ctrl + c’关闭server）</p><p>hexo deploy #部署到GitHub</p><p>hexo help  # 查看帮助</p><p>hexo version  #查看Hexo的版本</p><p>hexo s -g #生成并本地预览</p><p>hexo d -g #生成并上传</p><h1 id="写博客工具"><a href="#写博客工具" class="headerlink" title="写博客工具"></a>写博客工具</h1><p>推荐 Visual Studio Code</p><h1 id="最终效果"><a href="#最终效果" class="headerlink" title="最终效果"></a>最终效果</h1><p>liushijiexy.github.io</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://blog.haoji.me/build-blog-website-by-hexo-github.html?from=xa" target="_blank" rel="noopener">http://blog.haoji.me/build-blog-website-by-hexo-github.html?from=xa</a></p>]]></content>
    
    <summary type="html">
    
      github pages服务搭建博客
    
    </summary>
    
    
      <category term="默认分类" scheme="http://yoursite.com/categories/%E9%BB%98%E8%AE%A4%E5%88%86%E7%B1%BB/"/>
    
    
      <category term="博客" scheme="http://yoursite.com/tags/%E5%8D%9A%E5%AE%A2/"/>
    
  </entry>
  
  <entry>
    <title>计算机网络</title>
    <link href="http://yoursite.com/2020/05/19/%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2020/05/19/%E7%BD%91%E7%BB%9C/</id>
    <published>2020-05-18T22:16:58.000Z</published>
    <updated>2020-05-20T12:31:41.666Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机网络基础"><a href="#计算机网络基础" class="headerlink" title="计算机网络基础"></a>计算机网络基础</h1><a id="more"></a><h1 id="OSI与TCP-IP各层的结构与功能-都有哪些协议"><a href="#OSI与TCP-IP各层的结构与功能-都有哪些协议" class="headerlink" title="OSI与TCP/IP各层的结构与功能,都有哪些协议"></a>OSI与TCP/IP各层的结构与功能,都有哪些协议</h1><p>学习计算机网络时我们一般采用折中的办法，也就是中和 OSI 和 TCP/IP 的优点，采用一种只有五层协议的体系结构，这样既简洁又能将概念阐述清楚。</p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5C4022b24541314fe88292a5028bc47175%5Cc837fbab5c9b.png" alt="img"></p><p>五层协议的体系结构</p><p>结合互联网的情况，自上而下地，非常简要的介绍一下各层的作用。</p><h1 id="1-1-应用层"><a href="#1-1-应用层" class="headerlink" title="1.1 应用层"></a>1.1 应用层</h1><p><strong>应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用。</strong>应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如<strong>域名系统DNS</strong>，支持万维网应用的 <strong>HTTP协议</strong>，支持电子邮件的 <strong>SMTP协议</strong>等等。我们把应用层交互的数据单元称为报文。</p><p><strong>域名系统</strong></p><p>域名系统(Domain Name System缩写 DNS，Domain Name被译为域名)是因特网的一项核心服务，它作为可以将域名和IP地址相互映射的一个分布式数据库，能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。（百度百科）例如：一个公司的 Web 网站可看作是它在网上的门户，而域名就相当于其门牌地址，通常域名都使用该公司的名称或简称。例如上面提到的微软公司的域名，类似的还有：IBM 公司的域名是 <a href="http://www.ibm.xn--comoracle-xj3h/" target="_blank" rel="noopener">www.ibm.com、Oracle</a> 公司的域名是 <a href="http://www.oracle.xn--comcisco-hm3g8360a63fhh376bwz2c1gzc/" target="_blank" rel="noopener">www.oracle.com、Cisco公司的域名是</a> <a href="http://www.cisco.com/" target="_blank" rel="noopener">www.cisco.com</a> 等。</p><p><strong>HTTP协议</strong></p><p>超文本传输协议（HTTP，HyperText Transfer Protocol)是互联网上应用最为广泛的一种网络协议。所有的 WWW（万维网） 文件都必须遵守这个标准。设计 HTTP 最初的目的是为了提供一种发布和接收 HTML 页面的方法。（百度百科）</p><h2 id="1-2-运输层"><a href="#1-2-运输层" class="headerlink" title="1.2 运输层"></a>1.2 运输层</h2><p><strong>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务</strong>。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p><p><strong>运输层主要使用以下两种协议:</strong></p><ol><li><strong>传输控制协议 TCP</strong>（Transmission Control Protocol）–提供<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。</li><li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）–提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）。</li></ol><p><strong>TCP 与 UDP 的对比见问题三。</strong></p><h2 id="1-3-网络层"><a href="#1-3-网络层" class="headerlink" title="1.3 网络层"></a>1.3 网络层</h2><p><strong>在 计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。</strong> 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 <strong>IP 协议</strong>，因此分组也叫 <strong>IP 数据报</strong> ，简称 <strong>数据报</strong>。</p><p>这里要注意：<strong>不要把运输层的“用户数据报 UDP ”和网络层的“ IP 数据报”弄混</strong>。另外，无论是哪一层的数据单元，都可笼统地用“分组”来表示。</p><p>这里强调指出，网络层中的“网络”二字已经不是我们通常谈到的具体网络，而是指计算机网络体系结构模型中第三层的名称.</p><p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Protocol）和许多路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或<strong>IP层</strong>。</p><h2 id="1-4-数据链路层"><a href="#1-4-数据链路层" class="headerlink" title="1.4 数据链路层"></a>1.4 数据链路层</h2><p><strong>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</strong> 在两个相邻节点之间传送数据时，<strong>数据链路层将网络层交下来的 IP 数据报组装程帧</strong>，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p><p>在接收数据时，控制信息使接收端能够知道一个帧从哪个比特开始和到哪个比特结束。这样，数据链路层在收到一个帧后，就可从中提出数据部分，上交给网络层。</p><p>控制信息还使接收端能够检测到所收到的帧中有误差错。如果发现差错，数据链路层就简单地丢弃这个出了差错的帧，以避免继续在网络中传送下去白白浪费网络资源。如果需要改正数据在链路层传输时出现差错（这就是说，数据链路层不仅要检错，而且还要纠错），那么就要采用可靠性传输协议来纠正出现的差错。这种方法会使链路层的协议复杂些。</p><h2 id="1-5-物理层"><a href="#1-5-物理层" class="headerlink" title="1.5 物理层"></a>1.5 物理层</h2><p>在物理层上所传送的数据单位是比特。</p><p><strong>物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异。</strong> 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p><p>在互联网使用的各种协中最重要和最著名的就是 TCP/IP 两个协议。现在人们经常提到的TCP/IP并不一定单指TCP和IP这两个具体的协议，而往往表示互联网所使用的整个TCP/IP协议族。</p><p>1.6 总结一下</p><p>上面我们对计算机网络的五层体系结构有了初步的了解，下面附送一张七层体系结构图总结一下。图片来源：<a href="https://blog.csdn.net/yaopeng_2005/article/details/7064869" target="_blank" rel="noopener">https://blog.csdn.net/yaopeng_2005/article/details/7064869</a></p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5C36f2bb68e0b841dd983d36300db5345d%5C6479a9d300a3.png" alt="img"></p><p>七层体系结构图</p><h1 id="二-TCP-三次握手和四次挥手-面试常客"><a href="#二-TCP-三次握手和四次挥手-面试常客" class="headerlink" title="二 TCP 三次握手和四次挥手(面试常客)"></a>二 TCP 三次握手和四次挥手(面试常客)</h1><p>为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。</p><h2 id="2-1-TCP-三次握手漫画图解"><a href="#2-1-TCP-三次握手漫画图解" class="headerlink" title="2.1 TCP 三次握手漫画图解"></a>2.1 TCP 三次握手漫画图解</h2><p>如下图所示，下面的两个机器人通过3次握手确定了对方能正确接收和发送消息(图片来源：《图解HTTP》)。</p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5C0887c80073a1494bade07ab599fd4692%5C4f2622ebd2ba.png" alt="img"></p><p>TCP三次握手</p><p><strong>简单示意图：</strong></p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5C4ce3724af74243908f3ddf3f132bd4d3%5Cf82b583c490e.png" alt="img"></p><p>TCP三次握手</p><ul><li>客户端–发送带有 SYN 标志的数据包–一次握手–服务端</li><li>服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端</li><li>客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端</li></ul><h2 id="2-2-为什么要三次握手"><a href="#2-2-为什么要三次握手" class="headerlink" title="2.2 为什么要三次握手"></a>2.2 为什么要三次握手</h2><p><strong>三次握手的目的是建立可靠的通信信道，说到通讯，简单来说就是数据的发送与接收，而三次握手最主要的目的就是双方确认自己与对方的发送与接收是正常的。</strong></p><p>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</p><p>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</p><p>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</p><p>所以三次握手就能确认双发收发功能都正常，缺一不可。</p><h2 id="2-3-为什么要传回-SYN"><a href="#2-3-为什么要传回-SYN" class="headerlink" title="2.3 为什么要传回 SYN"></a>2.3 为什么要传回 SYN</h2><p>接收端传回发送端所发送的 SYN 是为了告诉发送端，我接收到的信息确实就是你所发送的信号了。</p><p>SYN 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement[汉译：确认字符 ,在数据通信传输中，接收站发给发送站的一种传输控制字符。它表示确认发来的数据已经接受无误。 ]）消息响应。这样在客户机和服务器之间才能建立起可靠的TCP连接，数据才可以在客户机和服务器之间传递。</p><h2 id="2-4-传了-SYN-为啥还要传-ACK"><a href="#2-4-传了-SYN-为啥还要传-ACK" class="headerlink" title="2.4 传了 SYN,为啥还要传 ACK"></a>2.4 传了 SYN,为啥还要传 ACK</h2><p>双方通信无误必须是两者互相发送信息都无误。传了 SYN，证明发送方到接收方的通道没有问题，但是接收方到发送方的通道还需要 ACK 信号来进行验证。</p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5Cb8693ba4c9194427879cfb62c705261e%5C3bf19ce9c30a.png" alt="img"></p><p>TCP四次挥手</p><p>断开一个 TCP 连接则需要“四次挥手”：</p><ul><li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li><li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加1 。和 SYN 一样，一个 FIN 将占用一个序号</li><li>服务器-关闭与客户端的连接，发送一个FIN给客户端</li><li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加1</li></ul><h3 id="2-5-为什么要四次挥手"><a href="#2-5-为什么要四次挥手" class="headerlink" title="2.5 为什么要四次挥手"></a>2.5 为什么要四次挥手</h3><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了TCP连接。</p><p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p><p>上面讲的比较概括，推荐一篇讲的比较细致的文章：<a href="https://blog.csdn.net/qzcsu/article/details/72861891" target="_blank" rel="noopener">https://blog.csdn.net/qzcsu/article/details/72861891</a></p><h1 id="三-TCP-UDP-协议的区别"><a href="#三-TCP-UDP-协议的区别" class="headerlink" title="三 TCP,UDP 协议的区别"></a>三 TCP,UDP 协议的区别</h1><p><img src="E:%5CShellExt%5Cerer961115@163.com%5C7b9ff1c37f0240f7b8b2d3435bb47c32%5Cf610aee54b94.png" alt="img"></p><p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 确是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等</p><p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP的可靠体现在TCP在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p><h1 id="四-TCP-协议如何保证可靠传输"><a href="#四-TCP-协议如何保证可靠传输" class="headerlink" title="四 TCP 协议如何保证可靠传输"></a>四 TCP 协议如何保证可靠传输</h1><ol><li>应用数据被分割成 TCP 认为最适合发送的数据块。</li><li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li><li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li><li>TCP 的接收端会丢弃重复的数据。</li><li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li><li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li><li><strong>ARQ协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li><li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li></ol><p>4.1 ARQ协议</p><p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是OSI模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ包括停止等待ARQ协议和连续ARQ协议。</p><p>停止等待ARQ协议</p><ul><li>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；</li><li>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认；</li></ul><p><strong>优点：</strong> 简单</p><p><strong>缺点：</strong> 信道利用率低，等待时间长</p><p><strong>1) 无差错情况:</strong></p><p>发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。</p><p><strong>2) 出现差错情况（超时重传）:</strong></p><p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。<strong>连续 ARQ 协议</strong> 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p><p><strong>3) 确认丢失和确认迟到</strong></p><ul><li><strong>确认丢失</strong> ：确认消息在传输过程丢失。当A发送M1消息，B收到后，B向A发送了一个M1确认消息，但却在传输过程中丢失。而A并不知道，在超时计时过后，A重传M1消息，B再次收到该消息后采取以下两点措施：1. 丢弃这个重复的M1消息，不向上层交付。 2. 向A发送确认消息。（不会认为已经发送过了，就不再发送。A能重传，就证明B的确认消息丢失）。</li><li><strong>确认迟到</strong> ：确认消息在传输过程中迟到。A发送M1消息，B收到并发送确认。在超时时间内没有收到确认消息，A重传M1消息，B仍然收到并继续发送确认消息（B收到了2份M1）。此时A收到了B第二次发送的确认消息。接着发送其他数据。过了一会，A收到了B第一次发送的对M1的确认消息（A也收到了2份确认消息）。处理如下：1. A收到重复的确认后，直接丢弃。2. B收到重复的M1后，也直接丢弃重复的M1。</li></ul><p>连续ARQ协议</p><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p><p><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</p><p><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5条 消息，中间第三条丢失（3号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</p><p>4.2 滑动窗口和流量控制</p><p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p><p>4.3 拥塞控制</p><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p><p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p><p>TCP的拥塞控制采用了四种算法，即 <strong>慢开始</strong> 、 <strong>拥塞避免</strong> 、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p><ul><li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd初始值为1，每经过一个传播轮次，cwnd加倍。</li></ul><p><img src="https://images.xiaozhuanlan.com/photo/2019/f443e912eaa5185c74abfebdcfc07a0a." alt="img"></p><ul><li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送放的cwnd加1.</li><li><strong>快重传与快恢复：</strong></li></ul><p>在 TCP/IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个不按顺序的数据段，它会立即给发送机发送一个重复确认。如果发送机接收到三个重复确认，它会假定确认件指出的数据段丢失了，并立即重传这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。 　当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</p><h1 id="五-在浏览器中输入url地址-gt-gt-显示主页的过程-面试常客"><a href="#五-在浏览器中输入url地址-gt-gt-显示主页的过程-面试常客" class="headerlink" title="五 在浏览器中输入url地址 -&gt;&gt; 显示主页的过程(面试常客)"></a>五 在浏览器中输入url地址 -&gt;&gt; 显示主页的过程(面试常客)</h1><p>百度好像最喜欢问这个问题。</p><p>打开一个网页，整个过程会使用哪些协议</p><p>图解（图片来源：《图解HTTP》）：</p><p>总体来说分为以下几个过程:</p><ol><li>DNS解析</li><li>TCP连接</li><li>发送HTTP请求</li><li>服务器处理请求并返回HTTP报文</li><li>浏览器解析渲染页面</li><li>连接结束</li></ol><p>具体可以参考下面这篇文章：</p><ul><li><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006879700</a></li></ul><p>六 状态码</p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5C8ebd92602fee4963a3f9a6d1088e98db%5Cfb719981796.jpeg" alt="img"></p><p>状态码</p><p>七 各种协议与HTTP协议之间的关系</p><p>一般面试官会通过这样的问题来考察你对计算机网络知识体系的理解。</p><p>图片来源：《图解HTTP》</p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5Cccabbb0233b74e1aadb4e6f9686cf03a%5C23c95015316.jpeg" alt="img"></p><p>各种协议与HTTP协议的关系</p><p>八 HTTP长连接,短连接</p><p>在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。</p><p>而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：</p><ul><li><strong>Connection</strong>:keep-alive</li></ul><p>在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。</p><p><strong>HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。</strong></p><p>—— <a href="https://www.cnblogs.com/gotodsp/p/6366163.html" target="_blank" rel="noopener">《HTTP长连接、短连接究竟是什么？》</a></p><p>九 HTTP是不保存状态的协议,如何保存用户状态?</p><p>HTTP 是一种不保存状态，即无状态（stateless）协议。也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。那么我们保存用户状态呢？Session 机制的存在就是为了解决这个问题，Session 的主要作用就是通过服务端记录用户的状态。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个Session）。</p><p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库redis保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是通过在 Cookie 中附加一个 Session ID 来方式来跟踪。</p><p><strong>Cookie 被禁用怎么办?</strong></p><p>最常用的就是利用 URL 重写把 Session ID 直接附加在URL路径的后面。</p><p><img src="E:%5CShellExt%5Cerer961115@163.com%5C4038b5f564b649bcabdeebd85820f8f1%5C1d7a6c7f8805.png" alt="img"></p><p>HTTP是无状态协议</p><p>十 Cookie的作用是什么?和Session有什么区别？</p><p>Cookie 和 Session都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p><p><strong>Cookie 一般用来保存用户信息</strong> 比如①我们在 Cookie 中保存已经登录过得用户信息，下次访问网站的时候页面可以自动帮你登录的一些基本信息给填了；②一般的网站都会有保持登录也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；③登录一次网站后访问网站其他页面不需要重新登录。<strong>Session 的主要作用就是通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p><p>Cookie 数据保存在客户端(浏览器端)，Session 数据保存在服务器端。</p><p>Cookie 存储在客户端中，而Session存储在服务器上，相对来说 Session 安全性更高。如果使用 Cookie 的一些敏感信息不要写入 Cookie 中，最好能将 Cookie 信息加密然后使用到的时候再去服务器端解密。</p><p>十一 HTTP 1.0和HTTP 1.1的主要区别是什么?</p><p>这部分回答引用这篇文章 <a href="https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A?12" target="_blank" rel="noopener">https://mp.weixin.qq.com/s/GICbiyJpINrHZ41u_4zT-A?12</a> 的一些内容。</p><p>HTTP1.0最早在网页中使用是在1996年，那个时候只是使用一些较为简单的网页上和网络请求上，而HTTP1.1则在1999年才开始广泛应用于现在的各大浏览器网络请求中，同时HTTP1.1也是当前使用最为广泛的HTTP协议。 主要区别主要体现在：</p><ol><li><strong>长连接</strong> : <strong>在HTTP/1.0中，默认使用的是短连接</strong>，也就是说每次请求都要重新建立一次连接。HTTP 是基于TCP/IP协议的,每一次建立或者断开连接都需要三次握手四次挥手的开销，如果每次请求都要这样的话，开销会比较大。因此最好能维持一个长连接，可以用个长连接来发多个请求。<strong>HTTP 1.1起，默认使用长连接</strong> ,默认开启Connection： keep-alive。 <strong>HTTP/1.1的持续连接有非流水线方式和流水线方式</strong> 。流水线方式是客户在收到HTTP的响应报文之前就能接着发送新的请求报文。与之相对应的非流水线方式是客户在收到前一个响应后才能发送下一个请求。</li><li><strong>错误状态响应码</strong> :在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。</li><li><strong>缓存处理</strong> :在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。</li><li><strong>带宽优化及网络连接的使用</strong> :HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li></ol><p>十二 URI和URL的区别是什么?</p><ul><li>URI (Uniform Resource Identifier) 是同一资源标志符，可以唯一标识一个资源。</li><li>URL  (Uniform Resource Location) 是同一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li></ul><p>URI的作用像身份证号一样，URL的作用更像家庭住址一样。URL是一种具体的URI，它不仅唯一标识资源，而且还提供了定位该资源的信息。</p><p>十三 HTTP 和 HTTPS 的区别？</p><ol><li><strong>端口</strong> ：HTTP的URL由“http://”起始且默认使用端口80，而HTTPS的URL由“https://”起始且默认使用端口443。</li><li><strong>安全性和资源消耗：</strong> HTTP协议运行在TCP之上，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份。HTTPS是运行在SSL/TLS之上的HTTP协议，SSL/TLS 运行在TCP之上。所有传输的内容都经过加密，加密采用对称加密，但对称加密的密钥用服务器方的证书进行了非对称加密。所以说，HTTP 安全性没有 HTTPS高，但是 HTTPS 比HTTP耗费更多服务器资源。</li></ol><ul><li><ul><li>对称加密：密钥只有一个，加密解密为同一个密码，且加解密速度快，典型的对称加密算法有DES、AES等；</li><li>非对称加密：密钥成对出现（且根据公钥无法推知私钥，根据私钥也无法推知公钥），加密解密使用不同密钥（公钥加密需要私钥解密，私钥加密需要公钥解密），相对对称加密速度较慢，典型的非对称加密算法有RSA、DSA等。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      计算机网络基础
    
    </summary>
    
    
      <category term="基础,网络" scheme="http://yoursite.com/categories/%E5%9F%BA%E7%A1%80-%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="基础" scheme="http://yoursite.com/tags/%E5%9F%BA%E7%A1%80/"/>
    
      <category term="网络" scheme="http://yoursite.com/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
</feed>
